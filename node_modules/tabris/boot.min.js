!function(){"use strict";const t=["",".js",".json","/package.json","/index.js","/index.json"],e=["/package.json","/index.js","/index.json"],r="(function (module, exports, require, __filename, __dirname) { ",n="\n});";class o{constructor(t,e,r){this.exports={},this._cache={},this._paths={},this.id=t||"",this.parent=e||null;let n={},o=!1;const i=this.require.bind(this);Object.defineProperty(this,"_cache",{enumerable:!1,writable:!1,value:this.parent?this.parent._cache:this._cache}),Object.defineProperty(this,"_paths",{enumerable:!1,writable:!1,value:this.parent?this.parent._paths:this._paths}),t&&(this._cache[t]=this),Object.defineProperty(this,"exports",{set(t){n=t},get(){return o||(o=!0,"function"==typeof r&&t?r(this,n,i,t.slice(1),l(t).slice(1)):r instanceof Object&&(n=r)),n}})}require(t){if("."!==t.slice(0,1)){const e=this._cache[t];if(e)return e.exports;const r=function(t){if(-1!==this.id.indexOf("/node_modules"))return null;let e,r,n=0;for(const o in this._paths){const i=o.indexOf("*");if(-1!==i){const s=o.substr(0,i),a=o.substr(i+1);t.length>=s.length+a.length&&t.startsWith(s)&&t.endsWith(a)&&n<s.length&&(n=s.length,e=o,r=t.substr(s.length,t.length-a.length))}else if(o===t){e=o,r=void 0;break}}if(!e)return null;const o=[];for(const n of this._paths[e]){const e=r?n.replace("*",r):n;o.push(e);const s=i.call(this,e,c(t));if(s)return s}throw new Error(`Cannot find module "${t}" at "${o.join('" or "')}"`)}.call(this,t);return r?r.exports:(this._cache[t]=!1,function(t){let e=l(this.id);const r=c(t),n="/node_modules/"+t;let o;do{o=i.call(this,h(e+n),r),(e=h(e+"/.."))&&"/node_modules"===e.slice(-1*"/node_modules".length)&&(e=h(e+"/.."))}while(!o&&e);if(!o)throw new Error("Cannot find module '"+t+"'");return o}.call(this,t).exports)}return function(t){const e=h(l(this.id)+"/"+t),r=i.call(this,e,c(t));if(!r)throw new Error("Cannot find module '"+t+"'");return r}.call(this,t).exports}static createLoader(t){let e;try{e=tabris._client.loadAndExecute(t,r,n)}catch(e){throw new Error("Could not parse "+t+":"+e)}return e.loadError?null:e.executeResult}static execute(t,e){return tabris._client.execute(t,e).executeResult}static readJSON(t){const e=this.load(t);if(e)try{return JSON.parse(e)}catch(e){throw new Error("Could not parse "+t+": "+e.message)}}static getSourceMap(){return null}static load(t){return tabris._client.load(t)}static createRequire(t){if("string"!=typeof t||"/"!==t[0])throw new Error(`The argument 'path' must be an absolute path string. Received ${t}`);return function(e){return o.root.require(h(l("."+t)+"/"+e))}}static define(t,e){if(2!==arguments.length)throw new Error(`Expected exactly 2 arguments, got ${arguments.length}`);if("string"!=typeof t)throw new Error("Expected argument 1 to be of type string");if("/"!==t.charAt(0))throw new Error('Path needs to start with a "/"');const r="."+t;if(o.root._cache[r])throw new Error(`Module "${t}" is already defined'`);if(!1===o.root._cache[r])throw new Error(`Module "${t}" was accessed before it was defined'`);if(e instanceof o)throw new Error("Expected argument 2 to be module exports, got a module instance");new o("."+t,this.root,t=>t.exports=e)}static addPath(t,e){if(t instanceof Object){!function(t){if(!("paths"in t))throw new Error('Missing option "paths"');if(!(t.paths instanceof Object))throw new Error('Expected option "paths" to be an object');if("baseUrl"in t&&"string"!=typeof t.baseUrl)throw new Error('Expected option "baseUrl" to be a string');if(t.baseUrl&&!t.baseUrl.startsWith("/"))throw new Error('Expected baseUrl to start with "/"')}(t);for(const e in t.paths){const r=t.paths[e];if(!Array.isArray(r)||r.some(t=>"string"!=typeof t))throw new Error(`Expected paths for pattern "${e}" to be array of strings`);this.addPath(e,r.map(e=>t.baseUrl?"./"+h(t.baseUrl+"/"+e):e))}}else{if(arguments.length<=1)throw new Error("Expected argument 1 to be of type object");if(function(t,e){if("string"!=typeof t)throw new Error("Expected argument 1 to be of type string");if(!Array.isArray(e))throw new Error(`Expected paths for pattern "${t}" to be array of strings`);if(e.some(t=>"string"!=typeof t))throw new Error(`Expected paths for pattern "${t}" to be array of strings`);if(""===t)throw new Error("Pattern not be empty string");if(/^[./]./.test(t))throw new Error(`Pattern may not start with "${t.charAt(0)}"`);if(t.split("*").length>2)throw new Error('Pattern may contain only one "*"');if(t.includes(" "))throw new Error("Pattern may not contain spaces");if(0===e.length)throw new Error(`Paths array for pattern "${t}" is empty`);const r=t.includes("*");e.forEach(e=>{if(!e.startsWith("./"))throw new Error(`Expected path "${e}" for pattern "${t}" to start with "./"`);const n=e.split("*").length-1;if(r){if(1!==n)throw new Error(`Expected path "${e}" for pattern "${t}" to contain exactly one "*"`)}else if(0!==n)throw new Error(`Expected path "${e}" for pattern "${t}" to not contain "*"`)})}(t,e),this.root._paths[t])throw new Error(`Pattern "${t}" is already registered`);const r=t.split("*")[0];if(Object.keys(this.root._cache).some(t=>t.startsWith(r)))throw new Error(`Can not add pattern "${t}" since a matching module was already imported'`);this.root._paths[t]=e}}}function i(e,r){if(e)for(const n of r){let r=a.call(this,e+n);if("/package.json"===n)if(s(r)){const n=h(e+"/"+s(r));r=i.call(this,n,t)}else r=null;if(r)return r}return null}function s(t){return t&&t.exports&&t.exports.main}function a(t){if(t in this._cache)return this._cache[t]||null;if(".json"===t.slice(-5)){const e=o.readJSON(t);if(e)return new o(t,this,e)}else{const e=o.createLoader(t);if(e)return new o(t,this,e)}return this._cache[t]=!1,null}function c(r){return"/"===r.slice(-1)?e:t}function l(t){return t&&"."===t.slice(0,1)?t.slice(0,t.lastIndexOf("/")):"./"}function h(t){const e=[],r=t.split("/");for(const t of r)if(".."===t){const t=e.pop();if(!t||"."===t)return""}else("."===t?0===e.length:""!==t)&&e.push(t);return e.join("/")}function u(t,e){console.print?console.print("error",t+(e.stack||e)):console.error(t,e)}o.root=new o,global.window=global.self=global,global.tabris={},tabris._start=function(t){try{tabris._client=t;const e=o.root;global.module=e,global.require=e.require.bind(e),global.exports=e.exports,global.__dirname="./",global.__filename=".";try{e.require("tabris"),tabris._client=t}catch(t){return void u("Could not load tabris module:",t)}tabris.Module=o,tabris._defineModule=function(t,r){return new o(t,e,r)};const r=document.createElement("script");r.src="./cordova.js",document.head.appendChild(r);const n=void 0!==global.workerScriptPath;tabris._init&&tabris._init(t,{headless:n});const i=function(){try{global.debugClient&&!n&&global.debugClient.start(e),e.require("./"+(n?global.workerScriptPath:"")),tabris.flush()}catch(t){u("Could not load "+(n?"worker":"main module")+":",t)}};tabris._entryPoint?(tabris._entryPoint(i),tabris._entryPoint=null):i(),delete global.workerScriptPath,tabris.flush()}catch(t){u("Could not start tabris:",t)}},tabris._notify=function(...t){return tabris._notify.apply(this,t)}}();