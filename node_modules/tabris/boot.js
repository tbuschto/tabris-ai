/*!
 * Tabris.js 3.7.1
 * 
 * Copyright (c) 2014, 2020 EclipseSource Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Tabris.js nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(function(){
'use strict';

/* eslint-disable @typescript-eslint/member-ordering */
/* eslint-disable @typescript-eslint/explicit-member-accessibility */
/* eslint-disable no-invalid-this */
const FILE_POSTFIXES = ['', '.js', '.json', '/package.json', '/index.js', '/index.json'];
const FOLDER_POSTFIXES = ['/package.json', '/index.js', '/index.json'];
const MODULE_PREFIX = '(function (module, exports, require, __filename, __dirname) { ';
const MODULE_POSTFIX = '\n});';
class Module {
    constructor(id, parent, content) {
        this.exports = {};
        this._cache = {};
        this._paths = {};
        this.id = id || '';
        this.parent = parent || null;
        let exports = {};
        let resolved = false;
        const require = this.require.bind(this);
        Object.defineProperty(this, '_cache', {
            enumerable: false, writable: false, value: this.parent ? this.parent._cache : this._cache
        });
        Object.defineProperty(this, '_paths', {
            enumerable: false, writable: false, value: this.parent ? this.parent._paths : this._paths
        });
        if (id) {
            this._cache[id] = this;
        }
        Object.defineProperty(this, 'exports', {
            set(value) {
                exports = value;
            },
            get() {
                if (!resolved) {
                    resolved = true;
                    if (typeof content === 'function' && id) {
                        content(this, exports, require, id.slice(1), dirname(id).slice(1));
                    }
                    else if (content instanceof Object) {
                        exports = content;
                    }
                }
                return exports;
            }
        });
    }
    require(request) {
        if (request.slice(0, 1) !== '.') {
            const cached = this._cache[request];
            if (cached) {
                return cached.exports;
            }
            const mapped = findMappedModule.call(this, request);
            if (mapped) {
                return mapped.exports;
            }
            this._cache[request] = false;
            return findNodeModule.call(this, request).exports;
        }
        return findFileModule.call(this, request).exports;
    }
    static createLoader(url) {
        let result;
        try {
            result = tabris._client.loadAndExecute(url, MODULE_PREFIX, MODULE_POSTFIX);
        }
        catch (ex) {
            throw new Error('Could not parse ' + url + ':' + ex);
        }
        if (result.loadError) {
            return null;
        }
        return result.executeResult;
    }
    static execute(code, url) {
        return tabris._client.execute(code, url).executeResult;
    }
    static readJSON(url) {
        const src = this.load(url);
        if (src) {
            try {
                return JSON.parse(src);
            }
            catch (ex) {
                throw new Error('Could not parse ' + url + ': ' + ex.message);
            }
        }
    }
    static getSourceMap() {
        return null;
    }
    static load(url) {
        return tabris._client.load(url);
    }
    static createRequire(path) {
        if ((typeof path !== 'string') || path[0] !== '/') {
            throw new Error(`The argument 'path' must be an absolute path string. Received ${path}`);
        }
        return function (request) {
            return Module.root.require(normalizePath(dirname('.' + path) + '/' + request));
        };
    }
    static define(path, exports) {
        if (arguments.length !== 2) {
            throw new Error(`Expected exactly 2 arguments, got ${arguments.length}`);
        }
        if (typeof path !== 'string') {
            throw new Error('Expected argument 1 to be of type string');
        }
        if (path.charAt(0) !== '/') {
            throw new Error('Path needs to start with a "/"');
        }
        const id = '.' + path;
        if (Module.root._cache[id]) {
            throw new Error(`Module "${path}" is already defined'`);
        }
        if (Module.root._cache[id] === false) {
            throw new Error(`Module "${path}" was accessed before it was defined'`);
        }
        if (exports instanceof Module) {
            throw new Error('Expected argument 2 to be module exports, got a module instance');
        }
        new Module('.' + path, this.root, module => module.exports = exports);
    }
    static addPath(arg1, arg2) {
        if (arg1 instanceof Object) {
            checkAddPathOptions(arg1);
            for (const pattern in arg1.paths) {
                const paths = arg1.paths[pattern];
                if (!Array.isArray(paths) || paths.some(path => typeof path !== 'string')) {
                    throw new Error(`Expected paths for pattern "${pattern}" to be array of strings`);
                }
                this.addPath(pattern, paths.map(path => arg1.baseUrl ? ('./' + normalizePath(arg1.baseUrl + '/' + path)) : path));
            }
        }
        else {
            if (arguments.length <= 1) {
                throw new Error('Expected argument 1 to be of type object');
            }
            checkAddPathArgs(arg1, arg2);
            if (this.root._paths[arg1]) {
                throw new Error(`Pattern "${arg1}" is already registered`);
            }
            const prefix = arg1.split('*')[0];
            if (Object.keys(this.root._cache).some(request => request.startsWith(prefix))) {
                throw new Error(`Can not add pattern "${arg1}" since a matching module was already imported'`);
            }
            this.root._paths[arg1] = arg2;
        }
    }
}
Module.root = new Module();
function findFileModule(request) {
    const path = normalizePath(dirname(this.id) + '/' + request);
    const result = findModule.call(this, path, getPostfixes(request));
    if (!result) {
        throw new Error('Cannot find module \'' + request + '\'');
    }
    return result;
}
function findNodeModule(request) {
    let currentDir = dirname(this.id);
    const postfixes = getPostfixes(request);
    const modulesPath = '/node_modules';
    const filePath = modulesPath + '/' + request;
    let result;
    do {
        result = findModule.call(this, normalizePath(currentDir + filePath), postfixes);
        currentDir = normalizePath(currentDir + '/..');
        if (currentDir && currentDir.slice(-1 * modulesPath.length) === modulesPath) {
            currentDir = normalizePath(currentDir + '/..');
        }
    } while (!result && currentDir);
    if (!result) {
        throw new Error('Cannot find module \'' + request + '\'');
    }
    return result;
}
function findMappedModule(request) {
    if (this.id.indexOf('/node_modules') !== -1) {
        return null;
    }
    // Based on https://github.com/Microsoft/TypeScript/issues/5039#pathMappings
    let matchedPattern;
    let matchedWildcard;
    let longestMatchedPrefixLength = 0;
    for (const pattern in this._paths) {
        const indexOfWildcard = pattern.indexOf('*');
        if (indexOfWildcard !== -1) {
            const prefix = pattern.substr(0, indexOfWildcard);
            const suffix = pattern.substr(indexOfWildcard + 1);
            if (request.length >= prefix.length + suffix.length
                && request.startsWith(prefix)
                && request.endsWith(suffix)
                && longestMatchedPrefixLength < prefix.length) {
                longestMatchedPrefixLength = prefix.length;
                matchedPattern = pattern;
                matchedWildcard = request.substr(prefix.length, request.length - suffix.length);
            }
        }
        else if (pattern === request) {
            matchedPattern = pattern;
            matchedWildcard = undefined;
            break;
        }
    }
    if (!matchedPattern) {
        return null;
    }
    const attempts = [];
    for (const subst of this._paths[matchedPattern]) {
        const path = matchedWildcard ? subst.replace('*', matchedWildcard) : subst;
        attempts.push(path);
        const module = findModule.call(this, path, getPostfixes(request));
        if (module) {
            return module;
        }
    }
    throw new Error(`Cannot find module "${request}" at "${attempts.join('" or "')}"`);
}
function findModule(path, postfixes) {
    if (path) {
        for (const postfix of postfixes) {
            let module = getModule.call(this, path + postfix);
            if (postfix === '/package.json') {
                if (getMain(module)) {
                    const normalizedPath = normalizePath(path + '/' + getMain(module));
                    module = findModule.call(this, normalizedPath, FILE_POSTFIXES);
                }
                else {
                    module = null;
                }
            }
            if (module) {
                return module;
            }
        }
    }
    return null;
}
function getMain(module) {
    return module && module.exports && module.exports.main;
}
function getModule(url) {
    if (url in this._cache) {
        return this._cache[url] || null;
    }
    if (url.slice(-5) === '.json') {
        const data = Module.readJSON(url);
        if (data) {
            return new Module(url, this, data);
        }
    }
    else {
        const loader = Module.createLoader(url);
        if (loader) {
            return new Module(url, this, loader);
        }
    }
    this._cache[url] = false;
    return null;
}
function getPostfixes(request) {
    return request.slice(-1) === '/' ? FOLDER_POSTFIXES : FILE_POSTFIXES;
}
function dirname(id) {
    if (!id || id.slice(0, 1) !== '.') {
        return './';
    }
    return id.slice(0, id.lastIndexOf('/'));
}
function normalizePath(path) {
    const segments = [];
    const pathSegments = path.split('/');
    for (const segment of pathSegments) {
        if (segment === '..') {
            const removed = segments.pop();
            if (!removed || removed === '.') {
                return '';
            }
        }
        else if (segment === '.' ? segments.length === 0 : segment !== '') {
            segments.push(segment);
        }
    }
    return segments.join('/');
}
function checkAddPathOptions(arg1) {
    if (!('paths' in arg1)) {
        throw new Error('Missing option "paths"');
    }
    if (!(arg1.paths instanceof Object)) {
        throw new Error('Expected option "paths" to be an object');
    }
    if (('baseUrl' in arg1) && typeof arg1.baseUrl !== 'string') {
        throw new Error('Expected option "baseUrl" to be a string');
    }
    if (arg1.baseUrl && !arg1.baseUrl.startsWith('/')) {
        throw new Error('Expected baseUrl to start with "/"');
    }
}
function checkAddPathArgs(arg1, arg2) {
    if (typeof arg1 !== 'string') {
        throw new Error('Expected argument 1 to be of type string');
    }
    if (!Array.isArray(arg2)) {
        throw new Error(`Expected paths for pattern "${arg1}" to be array of strings`);
    }
    if (arg2.some(path => typeof path !== 'string')) {
        throw new Error(`Expected paths for pattern "${arg1}" to be array of strings`);
    }
    if (arg1 === '') {
        throw new Error('Pattern not be empty string');
    }
    if (/^[./]./.test(arg1)) {
        throw new Error(`Pattern may not start with "${arg1.charAt(0)}"`);
    }
    if (arg1.split('*').length > 2) {
        throw new Error('Pattern may contain only one "*"');
    }
    if (arg1.includes(' ')) {
        throw new Error('Pattern may not contain spaces');
    }
    if (arg2.length === 0) {
        throw new Error(`Paths array for pattern "${arg1}" is empty`);
    }
    const wildcard = arg1.includes('*');
    arg2.forEach(path => {
        if (!path.startsWith('./')) {
            throw new Error(`Expected path "${path}" for pattern "${arg1}" to start with "./"`);
        }
        const pathWildcards = path.split('*').length - 1;
        if (wildcard) {
            if (pathWildcards !== 1) {
                throw new Error(`Expected path "${path}" for pattern "${arg1}" to contain exactly one "*"`);
            }
        }
        else if (pathWildcards !== 0) {
            throw new Error(`Expected path "${path}" for pattern "${arg1}" to not contain "*"`);
        }
    });
}

/* global document: true */
global.window = global.self = global;
global.tabris = {};
tabris._start = function (client) {
    try {
        tabris._client = client;
        const rootModule = Module.root;
        global.module = rootModule;
        global.require = rootModule.require.bind(rootModule);
        global.exports = rootModule.exports;
        global.__dirname = './';
        global.__filename = '.';
        try {
            rootModule.require('tabris');
            tabris._client = client; // required by head.append
        }
        catch (error) {
            printError('Could not load tabris module:', error);
            return;
        }
        tabris.Module = Module;
        tabris._defineModule = function (id, fn) {
            return new Module(id, rootModule, fn);
        };
        const cordovaScript = document.createElement('script');
        cordovaScript.src = './cordova.js';
        document.head.appendChild(cordovaScript);
        const isWorker = global.workerScriptPath !== undefined;
        if (tabris._init) {
            tabris._init(client, { headless: isWorker });
        }
        const loadModule = function () {
            try {
                if (global.debugClient && !isWorker) {
                    global.debugClient.start(rootModule);
                }
                rootModule.require('./' + (isWorker ? global.workerScriptPath : ''));
                tabris.flush();
            }
            catch (error) {
                printError('Could not load ' + (isWorker ? 'worker' : 'main module') + ':', error);
            }
        };
        if (tabris._entryPoint) {
            tabris._entryPoint(loadModule);
            tabris._entryPoint = null;
        }
        else {
            loadModule();
        }
        delete global.workerScriptPath;
        tabris.flush();
    }
    catch (error) {
        printError('Could not start tabris:', error);
    }
};
tabris._notify = function (...args) {
    // client may get the reference to _notify before tabris has been loaded
    return tabris._notify.apply(this, args);
};
function printError(msg, error) {
    if (console.print) {
        console.print('error', msg + (error.stack || error));
    }
    else {
        console.error(msg, error);
    }
}
}());