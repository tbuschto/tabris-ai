/*!
 * Tabris.js 3.7.1
 * 
 * Copyright (c) 2014, 2020 EclipseSource Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Tabris.js nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
'use strict';

if (typeof global === 'undefined') { window.global = window; }

const numbersOnlyRE = /^\d+$/;
const objectHasOwnProperty = Object.prototype.hasOwnProperty;
const propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
const regExpToString = RegExp.prototype.toString;
const dateToISOString = Date.prototype.toISOString;
let CIRCULAR_ERROR_MESSAGE;
// TODO: Add support for Map, Set, MapIterator, SetIterator, DataView
function tryStringify(arg) {
    try {
        return JSON.stringify(arg);
    }
    catch (err) {
        // Populate the circular error message lazily
        if (!CIRCULAR_ERROR_MESSAGE) {
            try {
                const a = {};
                a.a = a;
                JSON.stringify(a);
            }
            catch (innerErr) {
                CIRCULAR_ERROR_MESSAGE = innerErr.message;
            }
        }
        if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE) {
            return '[Circular]';
        }
        throw err;
    }
}
function format(f) {
    if (typeof f !== 'string') {
        const objects = new Array(arguments.length);
        for (let index = 0; index < arguments.length; index++) {
            objects[index] = inspect(arguments[index]);
        }
        return objects.join(' ');
    }
    if (arguments.length === 1) {
        return f;
    }
    let str = '';
    let a = 1;
    let lastPos = 0;
    for (let i = 0; i < f.length;) {
        if (f.charCodeAt(i) === 37 /* '%' */ && i + 1 < f.length) {
            if (f.charCodeAt(i + 1) !== 37 /* '%' */ && a >= arguments.length) {
                ++i;
                continue;
            }
            switch (f.charCodeAt(i + 1)) {
                case 100: // 'd'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += Number(arguments[a++]);
                    break;
                case 105: // 'i'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += parseInt(arguments[a++]);
                    break;
                case 102: // 'f'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += parseFloat(arguments[a++]);
                    break;
                case 106: // 'j'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += tryStringify(arguments[a++]);
                    break;
                case 115: // 's'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += String(arguments[a++]);
                    break;
                case 37: // '%'
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += '%';
                    break;
                default: // any other character is not a correct placeholder
                    if (lastPos < i) {
                        str += f.slice(lastPos, i);
                    }
                    str += '%';
                    lastPos = i = i + 1;
                    continue;
            }
            lastPos = i = i + 2;
            continue;
        }
        ++i;
    }
    if (lastPos === 0) {
        str = f;
    }
    else if (lastPos < f.length) {
        str += f.slice(lastPos);
    }
    while (a < arguments.length) {
        const x = arguments[a++];
        if (x === null || (typeof x !== 'object' && typeof x !== 'symbol')) {
            str += ` ${x}`;
        }
        else {
            str += ` ${inspect(x)}`;
        }
    }
    return str;
}
function inspect(obj) {
    // default options
    const ctx = {
        seen: [],
        breakLength: 60,
        maxArrayLength: 20
    };
    return formatValue(ctx, obj, 2);
}
function arrayToHash(array) {
    const hash = Object.create(null);
    for (let i = 0; i < array.length; i++) {
        const val = array[i];
        hash[val] = true;
    }
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Primitive types cannot have properties
    const primitive = formatPrimitive(ctx, value);
    if (primitive) {
        return primitive;
    }
    // Look up the keys of the object.
    let keys = Object.keys(value);
    const visibleKeys = arrayToHash(keys);
    const symbolKeys = Object.getOwnPropertySymbols(value);
    const enumSymbolKeys = symbolKeys.filter((key) => propertyIsEnumerable.call(value, key));
    keys = keys.concat(enumSymbolKeys);
    // This could be a boxed primitive (new String(), etc.), check valueOf()
    // NOTE: Avoid calling `valueOf` on `Date` instance because it will return
    // a number which, when object has some additional user-stored `keys`,
    // will be printed out.
    let formatted;
    let raw = value;
    try {
        // the .valueOf() call can fail for a multitude of reasons
        if (!isDate(value)) {
            raw = value.valueOf();
        }
    }
    catch (e) {
        // ignore...
    }
    if (typeof raw === 'string') {
        // for boxed Strings, we have to remove the 0-n indexed entries,
        // since they just noisy up the output and are redundant
        keys = keys.filter((key) => {
            if (typeof key === 'symbol') {
                return true;
            }
            return !(key >= 0 && key < raw.length);
        });
    }
    // On iOS, errors have these extra enumerable fields
    if (isError(value) && tabris.device.platform === 'iOS') {
        keys = keys.filter((key) => !['line', 'column', 'sourceURL'].includes(key));
    }
    let constructor = getConstructorOf(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (typeof value === 'function') {
            const ctorName = constructor ? constructor.name : 'Function';
            return `[${ctorName}${value.name ? `: ${value.name}` : ''}]`;
        }
        if (isRegExp(value)) {
            return regExpToString.call(value);
        }
        if (isDate(value)) {
            if (Number.isNaN(value.getTime())) {
                return value.toString();
            }
            else {
                return dateToISOString.call(value);
            }
        }
        if (isError(value)) {
            return formatError(value);
        }
        // now check the `raw` value to handle boxed primitives
        if (typeof raw === 'string') {
            formatted = formatPrimitive(ctx, raw);
            return `[String: ${formatted}]`;
        }
        if (typeof raw === 'symbol') {
            formatted = formatPrimitive(ctx, raw);
            return `[Symbol: ${formatted}]`;
        }
        if (typeof raw === 'number') {
            formatted = formatPrimitive(ctx, raw);
            return `[Number: ${formatted}]`;
        }
        if (typeof raw === 'boolean') {
            formatted = formatPrimitive(ctx, raw);
            return `[Boolean: ${formatted}]`;
        }
    }
    let base = '';
    let empty = false;
    let formatter = formatObject;
    let braces;
    // We can't compare constructors for various objects using a comparison like
    // `constructor === Array` because the object could have come from a different
    // context and thus the constructor won't match. Instead we check the
    // constructor names (including those up the prototype chain where needed) to
    // determine object types.
    if (Array.isArray(value)) {
        // Unset the constructor to prevent "Array [...]" for ordinary arrays.
        if (constructor && constructor.name === 'Array') {
            constructor = null;
        }
        braces = ['[', ']'];
        empty = value.length === 0;
        formatter = formatArray;
    }
    else if (isArrayBuffer(value)) {
        braces = ['{', '}'];
        keys.unshift('byteLength');
        visibleKeys.byteLength = true;
    }
    else if (isTypedArray(value)) {
        braces = ['[', ']'];
        formatter = formatTypedArray;
    }
    else if (isPromise(value)) {
        braces = ['{', '}'];
        formatter = formatPromise;
    }
    else {
        try {
            if (value instanceof Object && (value.toString !== Object.prototype.toString)) {
                const result = value.toString();
                if (typeof result === 'string') {
                    return result;
                }
            }
        }
        catch (ex) {
            // try something else
        }
        // Unset the constructor to prevent "Object {...}" for ordinary objects.
        if (constructor && constructor.name === 'Object') {
            constructor = null;
        }
        braces = ['{', '}'];
        empty = true; // No other data than keys.
    }
    empty = empty === true && keys.length === 0;
    // Make functions say that they are functions
    if (typeof value === 'function') {
        const ctorName = constructor ? constructor.name : 'Function';
        base = ` [${ctorName}${value.name ? `: ${value.name}` : ''}]`;
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
        base = ` ${regExpToString.call(value)}`;
    }
    // Make dates with properties first say the date
    if (isDate(value)) {
        base = ` ${dateToISOString.call(value)}`;
    }
    // Make error with message first say the error
    if (isError(value)) {
        return formatError(value);
    }
    // Make boxed primitive Strings look like such
    if (typeof raw === 'string') {
        formatted = formatPrimitive(ctx, raw);
        base = ` [String: ${formatted}]`;
    }
    // Make boxed primitive Numbers look like such
    if (typeof raw === 'number') {
        formatted = formatPrimitive(ctx, raw);
        base = ` [Number: ${formatted}]`;
    }
    // Make boxed primitive Booleans look like such
    if (typeof raw === 'boolean') {
        formatted = formatPrimitive(ctx, raw);
        base = ` [Boolean: ${formatted}]`;
    }
    // Add constructor name if available
    if (base === '' && constructor) {
        braces[0] = `${constructor.name} ${braces[0]}`;
    }
    if (empty === true) {
        return `${braces[0]}${base}${braces[1]}`;
    }
    if (recurseTimes < 0) {
        if (isRegExp(value)) {
            return regExpToString.call(value);
        }
        else if (Array.isArray(value)) {
            return '[Array]';
        }
        else {
            return '[Object]';
        }
    }
    ctx.seen.push(value);
    const output = formatter(ctx, value, recurseTimes, visibleKeys, keys);
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces, ctx.breakLength);
}
function formatNumber(ctx, value) {
    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0.
    if (Object.is(value, -0)) {
        return '-0';
    }
    return `${value}`;
}
function formatPrimitive(ctx, value) {
    if (value === undefined) {
        return 'undefined';
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
        return 'null';
    }
    const type = typeof value;
    if (type === 'string') {
        const simple = JSON.stringify(value)
            .replace(/^"|"$/g, '')
            .replace(/'/g, '\\\'')
            .replace(/\\"/g, '"');
        return `'${simple}'`;
    }
    if (type === 'number') {
        return formatNumber(ctx, value);
    }
    if (type === 'boolean') {
        return `${value}`;
    }
    // es6 symbol primitive
    if (type === 'symbol') {
        return value.toString();
    }
}
function formatObject(ctx, value, recurseTimes, visibleKeys, keys) {
    return keys.map((key) => formatProperty(ctx, value, recurseTimes, visibleKeys, key, false));
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    const output = [];
    let visibleLength = 0;
    let index = 0;
    while (index < value.length && visibleLength < ctx.maxArrayLength) {
        let emptyItems = 0;
        while (index < value.length && !hasOwnProperty(value, String(index))) {
            emptyItems++;
            index++;
        }
        if (emptyItems > 0) {
            const ending = emptyItems > 1 ? 's' : '';
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(message);
        }
        else {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(index), true));
            index++;
        }
        visibleLength++;
    }
    const remaining = value.length - index;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
    }
    for (let n = 0; n < keys.length; n++) {
        const key = keys[n];
        if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    }
    return output;
}
function formatTypedArray(ctx, value, recurseTimes, visibleKeys, keys) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    for (let i = 0; i < maxLength; ++i) {
        output[i] = formatNumber(ctx, value[i]);
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
    }
    for (const key of keys) {
        if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    }
    return output;
}
function formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {
    const output = [];
    if (isPending(value)) {
        output.push('<pending>');
    }
    else {
        const nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
        const result = getPromiseResult(value);
        const str = formatValue(ctx, result, nextRecurseTimes);
        if (isRejected(value)) {
            output.push(`<rejected> ${str}`);
        }
        else {
            output.push(str);
        }
    }
    for (let n = 0; n < keys.length; n++) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, keys[n], false));
    }
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    let name, str;
    const desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
        if (desc.set) {
            str = '[Getter/Setter]';
        }
        else {
            str = '[Getter]';
        }
    }
    else {
        if (desc.set) {
            str = '[Setter]';
        }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
        if (typeof key === 'symbol') {
            name = `[${key.toString()}]`;
        }
        else {
            name = `[${key}]`;
        }
    }
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (recurseTimes === null) {
                str = formatValue(ctx, desc.value, null);
            }
            else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
                if (array) {
                    str = str.replace(/\n/g, '\n  ');
                }
                else {
                    str = str.replace(/^|\n/g, '\n   ');
                }
            }
        }
        else {
            str = '[Circular]';
        }
    }
    if (name === undefined) {
        if (array && numbersOnlyRE.test(key)) {
            return str;
        }
        name = JSON.stringify(`${key}`);
        if (/^"[a-zA-Z_][a-zA-Z_0-9]*"$/.test(name)) {
            name = name.substr(1, name.length - 2);
        }
        else {
            name = name.replace(/'/g, '\\\'')
                .replace(/\\"/g, '"')
                .replace(/^"|"$/g, '\'')
                .replace(/\\\\/g, '\\');
        }
    }
    return `${name}: ${str}`;
}
function reduceToSingleString(output, base, braces, breakLength) {
    const length = output.reduce((prev, cur) => prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1, 0);
    if (length > breakLength) {
        return braces[0] +
            // If the opening "brace" is too large, like in the case of "Set {",
            // we need to force the first item to be on the next line or the
            // items will not line up correctly.
            (base === '' && braces[0].length === 1 ? '' : `${base}\n `) +
            ` ${output.join(',\n  ')} ${braces[1]}`;
    }
    return `${braces[0]}${base} ${output.join(', ')} ${braces[1]}`;
}
function hasOwnProperty(obj, prop) {
    return objectHasOwnProperty.call(obj, prop);
}
function isError(value) {
    return objectToString(value) === '[object Error]' || value instanceof Error;
}
function isDate(value) {
    return objectToString(value) === '[object Date]' || value instanceof Date;
}
function isPromise(value) {
    return objectToString(value) === '[object Promise]' || value instanceof Promise$1;
}
function isRegExp(value) {
    return objectToString(value) === '[object RegExp]' || value instanceof RegExp;
}
const typedArrayTypes = [
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array'
];
const typedArrayNames = {};
for (const type of typedArrayTypes) {
    typedArrayNames[`[object ${type}]`] = true;
}
function isTypedArray(value) {
    return typedArrayNames[objectToString(value)];
}
function isArrayBuffer(value) {
    return objectToString(value) === '[object ArrayBuffer]' || value instanceof ArrayBuffer;
}
function getConstructorOf(obj) {
    while (obj) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
        if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
            return descriptor.value;
        }
        obj = Object.getPrototypeOf(obj);
    }
    return null;
}
function objectToString(o) {
    return Object.prototype.toString.call(o);
}

const equals = Symbol('equals');
const creationAllowed = Symbol('creationAllowed');
const bytes = Symbol('bytes');
const nativeObject = Symbol('nativeObject');
const toXML = Symbol('toXML');
const notify = Symbol('notify');
const data = Symbol('data');
const listenersStore = Symbol('listenersStore');
const originalComponent = Symbol('originalComponent');
const proxyHandler = Symbol('proxyHandler');
const setterTargetType = Symbol('setterTargetType');
const observable = Symbol('observable');
const nativeObservables = Symbol('nativeObservables');
const jsxFactory = Symbol('jsxFactory');
const jsxType = Symbol('jsxType');

var symbols = /*#__PURE__*/Object.freeze({
  equals: equals,
  creationAllowed: creationAllowed,
  bytes: bytes,
  nativeObject: nativeObject,
  toXML: toXML,
  notify: notify,
  data: data,
  listenersStore: listenersStore,
  originalComponent: originalComponent,
  proxyHandler: proxyHandler,
  setterTargetType: setterTargetType,
  observable: observable,
  nativeObservables: nativeObservables,
  jsxFactory: jsxFactory,
  jsxType: jsxType
});

const toXML$1 = toXML;
class Console {
    constructor() {
        Reflect.ownKeys(Console.prototype).forEach(key => {
            if (this[key] instanceof Function) {
                this[key] = this[key].bind(this);
            }
        });
        this._registerPrintMethods(arguments[0]);
        Object.defineProperties(this, {
            _prefixSpaces: { enumerable: false, writable: true, value: 0 },
            _count: { enumerable: false, writable: false, value: {} }
        });
    }
    trace() {
        this.log(getStackTrace(new Error('StackTrace')));
    }
    assert(expression, ...args) {
        if (!expression) {
            args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
            this.error(...args);
        }
    }
    count(label) {
        label = label ? label : 'default';
        if (!this._count[label]) {
            this._count[label] = 0;
        }
        this.log('%s: %s', label, ++this._count[label]);
    }
    countReset(label) {
        label = label ? label : 'default';
        this.log('%s: %s', label, this._count[label] = 0);
    }
    dirxml(obj) {
        if (obj && obj[toXML$1] instanceof Function) {
            this.log(obj[toXML$1]());
        }
        else {
            this.log(obj);
        }
    }
    group(...args) {
        this.log(...args);
        this._prefixSpaces += 2;
    }
    groupEnd() {
        if (this._prefixSpaces > 0) {
            this._prefixSpaces -= 2;
        }
    }
    debug(...args) {
        this._console.debug(...args);
    }
    info(...args) {
        this._console.info(...args);
    }
    log(...args) {
        this._console.log(...args);
    }
    warn(...args) {
        this._console.warn(...args);
    }
    error(...args) {
        this._console.error(...args);
    }
    _registerPrintMethods(nativeConsole) {
        Object.defineProperty(this, '_console', {
            enumerable: false, writable: false, value: {}
        });
        for (const level of ['debug', 'info', 'log', 'warn', 'error']) {
            this._console[level] = (...args) => {
                const message = this._prepareOutput(...args);
                tabris.trigger('log', { level, message });
                nativeConsole.print(level, message);
            };
        }
    }
    _prepareOutput(...args) {
        let output = format(...args);
        if (this._prefixSpaces > 0) {
            output = `${' '.repeat(this._prefixSpaces)}${output}`;
        }
        return output;
    }
}
function createConsole(nativeConsole) {
    return new Console(nativeConsole);
}
const defaultConsole = global.console.print
    ? createConsole(global.console)
    : global.console;
if (!defaultConsole.debug) {
    // The native node console has no "debug" method
    defaultConsole.debug = function (...args) {
        defaultConsole.log(...args);
    };
}
const log = function (...args) { defaultConsole.log(...args); };
const warn = function (...args) { defaultConsole.warn(...args); };
const error = function (...args) { defaultConsole.error(...args); };
let inHint = false;
const toValueString = function (value) {
    try {
        if ((value instanceof Array || (value && value._array instanceof Array))) {
            const array = value instanceof Array ? value : value._array;
            const joined = `[${array.map(toValueString).join(', ')}]`;
            if (joined.length <= 40) {
                return joined;
            }
        }
        if (typeof value === 'string') {
            const escaped = value.slice(0, 40).replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
            return value.length > 40 ? `"${escaped}..."` : `"${escaped}"`;
        }
        if (value && value[toXML$1]) { // Alternative to using instanceof to avoid circular dependency
            return value._disposedToStringValue || value.toString();
        }
        if (value && (value instanceof Function)) {
            return value.name;
        }
        if (value && (value.constructor === Object)) {
            const json = JSON.stringify(value);
            if (json.length <= 40) {
                return json;
            }
        }
        if (value instanceof Object && (value.constructor instanceof Function)) {
            return value.constructor.name;
        }
        return value + '';
    }
    catch (ex) {
        return '[unknown]';
    }
};
const hint = function (source, message) {
    if (inHint) {
        return; // prevent potential stack overflow
    }
    inHint = true;
    let line = '';
    let prefix = '';
    line = getCurrentLine(new Error());
    if (source && typeof source === 'string') {
        prefix = source + ': ';
    }
    else if (source) {
        prefix = toValueString(source) + ': ';
    }
    defaultConsole.warn(prefix + message + (line ? `\nSource: ${line}` : ''));
    inHint = false;
};

function pick(object, keys) {
    const result = {};
    for (const key in object) {
        if (keys.includes(key)) {
            result[key] = object[key];
        }
    }
    return result;
}
function omit(object, keys) {
    const result = {};
    for (const key in object) {
        if (!keys.includes(key)) {
            result[key] = object[key];
        }
    }
    return result;
}
function capitalizeFirstChar(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * @param {string} path
 * @param {'unix' | 'win'} outputStyle
 */
function normalizePath(path, outputStyle = 'unix') {
    if (typeof path !== 'string') {
        throw new Error('must be a string');
    }
    if (path === '') {
        throw new Error('must not be empty');
    }
    // const prefix = path.startsWith('./') ? './' : path[0] === '/' ? '/' : '';
    const prefix = path.startsWith('/') ? '/' : '';
    const segments = [];
    const pathSegments = path.split(/[\\/]/);
    for (let i = 0; i < pathSegments.length; i++) {
        const segment = pathSegments[i];
        if (segment === '..') {
            const removed = segments.pop();
            if (!removed || removed === '.') {
                throw new Error('Path must not start with ".."');
            }
        }
        else if (segment !== '.' && segment !== '') {
            segments.push(segment);
        }
    }
    if (!segments.length) {
        return prefix || '.';
    }
    return prefix + segments.join(outputStyle === 'win' ? '\\' : '/');
}
function normalizePathUrl(url) {
    if (typeof url !== 'string') {
        throw new Error('must be a string');
    }
    const parts = /^([a-z-]+:(\/\/)?)?(.*)/.exec(url);
    const schema = parts[1] || '';
    const content = parts[3] || '';
    if (schema === 'data:') {
        return url;
    }
    return schema + normalizePath(content);
}
/**
 * Returns the directory portion of the given file path.
 * The result is not normalized and relative paths stay relative.
 * @param {string} path
 * @param {'unix' | 'win'} inputStyle
 */
function dirname(path, inputStyle = 'unix') {
    if (!path) {
        return '';
    }
    if ((inputStyle === 'unix') && (path[0] !== '.') && (path[0] !== '/')) {
        return './'; // path was just a file name
    }
    return path.slice(0, path.lastIndexOf(inputStyle === 'win' ? '\\' : '/'));
}
/**
 * Check if a given value is a number and in closed range.
 * @param value Value to check.
 * @param range An array of min and max value of a closed range.
 * @param errorPrefix Prefix to prepend to messages of thrown errors.
 */
function checkNumber(value, range = [-Infinity, Infinity], errorPrefix = undefined) {
    const prefix = errorPrefix ? errorPrefix + ': ' : '';
    if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
        throw new Error(`${prefix}Invalid number ${value}`);
    }
    if (value < range[0] || value > range[1]) {
        throw new Error(`${prefix}Number ${value} out of range`);
    }
}
/**
 * @param {*} value
 * @returns {Array}
 */
function asArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    if (!value) {
        return [];
    }
    if (value.constructor !== Object && value.toArray instanceof Function) {
        return value.toArray();
    }
    return [value];
}
/**
 * Boolean values indicates whether the trap must return true to avoid
 * exceptions if code is executed in strict mode. (Which is never desired.)
 */
const traps = {
    getPrototypeOf: false,
    setPrototypeOf: true,
    isExtensible: false,
    preventExtensions: false,
    getOwnPropertyDescriptor: false,
    defineProperty: true,
    has: false,
    get: false,
    set: true,
    deleteProperty: true,
    ownKeys: false,
    apply: false,
    construct: false
};
/**
 * @param {() => object} getTarget
 */
function proxify(getTarget) {
    const handler = {};
    const fakeTarget = {};
    Object.keys(traps).forEach(trap => handler[trap] = (_, ...args) => {
        const result = Reflect[trap](getTarget(), ...args);
        if (trap === 'getOwnPropertyDescriptor' && result) {
            // The VM throws if a property is configurable or non-existing
            // on fakeTarget, but not reported as such here
            result.configurable = true;
            return result;
        }
        return traps[trap] ? true : result;
    });
    return new Proxy(fakeTarget, handler);
}
function isReadable(value) {
    return value instanceof ArrayBuffer
        || ArrayBuffer.isView(value)
        || !!getBytes(value);
}
/**
 * @param {any} value
 * @return {ArrayBuffer}
 */
function read(value) {
    if (value instanceof ArrayBuffer) {
        return value.slice(0);
    }
    if (ArrayBuffer.isView(value)) {
        return value.buffer.slice(0);
    }
    if (getBytes(value)) {
        return getBytes(value); // no copy needed since blobs are pseudo-immutable
    }
    throw new Error(`${typeof value} is not an ArrayBuffer, Blob or typed`);
}
/**
 * @param {any} blob
 * @returns {ArrayBuffer}
 */
function getBytes(blob) {
    return blob[bytes];
}
/**
 * @param {any} blob
 * @param {ArrayBuffer} bytes
 */
function setBytes(blob, bytes$$1) {
    return blob[bytes] = bytes$$1;
}
/**
 * @template {object} T
 * @template {string} U
 * @param {T} target
 * @param {U[]} keys
 * @returns {Partial<Record<U, unknown>>}
 */
function allowOnlyKeys(target, keys) {
    if (typeof target !== 'object') {
        throw new Error(toValueString(target) + ' is not an object');
    }
    for (const key in target) {
        if (keys.indexOf(/** @type {U} */ (key)) === -1) {
            throw new Error(`${toValueString(target)} contains unexpected entry "${key}"`);
        }
    }
    return target;
}
/**
 * @template {any} T
 * @param {T} value
 * @param {any[]|undefined} allowed
 * @returns T
 */
function allowOnlyValues(value, allowed, valueName = 'Value') {
    if (allowed && allowed.indexOf(value) === -1) {
        const expected = `"${allowed.slice(0, -1).join('", "')}" or "${allowed.slice(-1)}"`;
        throw new Error(`${valueName} must be ${expected}", got ${toValueString(value)}`);
    }
    return value;
}
/**
 * @param {object} object
 * @param {{cid: string}} nativeObject
 */
function setNativeObject(object, nativeObject$$1) {
    object[nativeObject] = nativeObject$$1;
}
/**
 * @param {object} object
 * @returns {{cid: string, isDisposed: () => boolean, dispose: () => void}}
 */
function getNativeObject(object) {
    return object instanceof Object ? object[nativeObject] : null;
}
/**
 * @param {Function} cb
 * @param {object=} target
 * @param {any[]=} args
 */
function createNativeCallback(cb, target, args) {
    const stackTraceStack = [new Error().stack].concat(tabris._stackTraceStack.slice(0, 10));
    return function () {
        const oldStack = tabris._stackTraceStack;
        tabris._stackTraceStack = stackTraceStack;
        try {
            cb.apply(target ? target : global, args ? args : arguments);
        }
        catch (e) {
            console.error('Uncaught ' + e);
        }
        tabris.flush();
        tabris._stackTraceStack = oldStack;
    };
}
function equals$1(a, b) {
    if (a === b) {
        return true;
    }
    if (a instanceof Object
        && b instanceof Object
        && a[equals] instanceof Function
        && b[equals] instanceof Function
        && (a[equals] === b[equals])) {
        return a[equals](b);
    }
    if (a instanceof Object
        && a.constructor === Object
        && b instanceof Object
        && b.constructor === Object) {
        const keysA = Reflect.ownKeys(a).sort();
        const keysB = Reflect.ownKeys(b).sort();
        return (keysA.length === keysB.length) && keysA.every((keyA, index) => {
            const keyB = keysB[index];
            return (keyA === keyB) && (a[keyA] === b[keyB]);
        });
    }
    if (a instanceof Array
        && a.constructor === Array
        && b instanceof Array
        && b.constructor === Array) {
        return (a.length === b.length) && a.every((itemA, index) => itemA === b[index]);
    }
    return false;
}

const androidStackLineRegex = /^ +at +(.+) +\((.*):([0-9]+):([0-9]+)\)/;
const androidStackLineNoNameRegex = /^ +at +(.*):([0-9]+):([0-9]+)/;
const iosStackLineRegex = /^(.+)@(.*):([0-9]+):([0-9]+)/;
const iosStackLineNoNameRegex = /(.*):([0-9]+):([0-9]+)/;
const urlBaseRegEx = /^[a-z]+:\/\/[^/]+\//;
/**
 * @param {Error} error
 * @param {boolean} errorStyleFormatting
 * Prefix trace lines with "at", similarly to how logged errors are formatted in V8.
 */
function getStackTrace(error$$1, errorStyleFormatting = false) {
    try {
        return getStackArray(error$$1.stack).map(line => errorStyleFormatting ? '  at ' + line : line).join('\n');
    }
    catch (ex) {
        const minimalError = (ex && ex.constructor && ex.message) ? ex.constructor.name + ': ' + ex.message : '';
        warn(`Could not process stack trace (${minimalError || ex}), printing original.`);
        return error$$1.stack;
    }
}
function patchError(fn) {
    fn.prototype.toString = function () {
        return formatError(this);
    };
}
function formatError(error$$1) {
    let stack;
    try {
        if (!(error$$1 instanceof Object)) {
            return '' + error$$1;
        }
        if (!(error$$1 instanceof Error)) {
            return error$$1.constructor.name + ': ' + error$$1.toString();
        }
        else {
            stack = getStackArray(error$$1.stack).map(line => '  at ' + line).join('\n');
        }
    }
    catch (ex) {
        stack = error$$1.stack;
    }
    return error$$1.constructor.name + ': ' + error$$1.message + '\n' + stack;
}
function formatPromiseRejectionReason(reason) {
    let result;
    if (reason && typeof reason.toString === 'function') {
        result = reason.toString();
    }
    else {
        result = typeof reason === 'undefined' ? '' : reason + '';
    }
    if (!reason || !reason.stack) {
        result += '\n' + getStackTrace(new Error(), true);
    }
    return result;
}
function getCurrentLine(error$$1) {
    try {
        return getStackArray(error$$1.stack)[0].trim();
    }
    catch (ex) {
        return '';
    }
}
function getStackArray(stack) {
    const formattedStack = limitStack(([stack].concat(tabris._stackTraceStack).join('\n').split('\n')).filter(filterStackLine)).map(normalizeStackLine)
        .filter(line => !!line);
    if (!formattedStack.length) {
        throw new Error('Empty stacktrace');
    }
    return formattedStack;
}
/** @param {string[]} stack */
function limitStack(stack) {
    if (stack.length > 300) {
        const missing = stack.length - 300;
        return stack.slice(0, 150)
            .concat(['[' + missing + ' more lines...]'])
            .concat(stack.slice(-150));
    }
    return stack;
}
function filterStackLine(line) {
    if (tabris.device.platform === 'Android' && !androidStackLineNoNameRegex.test(line)) {
        return false;
    }
    return line.indexOf('tabris/tabris.min.js:') === -1
        && line.indexOf('@[native code]') === -1
        && line.indexOf('<anonymous>:') === -1;
}
/** @param {string} line */
function normalizeStackLine(line) {
    if (line.endsWith('more lines...]')) {
        return line;
    }
    const mapped = applySourceMap(parseLine(line));
    if (!mapped) {
        return null;
    }
    if (!mapped.fn) {
        return `${mapped.url}:${mapped.line}:${mapped.column}`;
    }
    return `${mapped.fn} (${mapped.url}:${mapped.line}:${mapped.column})`;
}
function parseLine(str) {
    const regex = tabris.device.platform === 'Android' ? androidStackLineRegex : iosStackLineRegex;
    const noNameRegex = tabris.device.platform === 'Android' ? androidStackLineNoNameRegex : iosStackLineNoNameRegex;
    const fullMatch = str.match(regex);
    const noNameMatch = str.match(noNameRegex);
    if (fullMatch && fullMatch.length === 5) {
        const [, fn, url, line, column] = fullMatch;
        return {
            fn: normalizeFunctionName(fn),
            url: fixUrl(url),
            line: parseInt(line, 10),
            column: parseInt(column, 10)
        };
    }
    else if (noNameMatch && noNameMatch.length === 4) {
        const [, url, line, column] = noNameMatch;
        return {
            fn: null,
            url: fixUrl(url),
            line: parseInt(line, 10),
            column: parseInt(column, 10)
        };
    }
    return null;
}
function normalizeFunctionName(fn) {
    let result = fn.split('.').pop();
    if (result === 'then' || result === '<anonymous>') {
        result = null;
    }
    return result;
}
function fixUrl(url) {
    const urlBase = url.match(urlBaseRegEx);
    if (urlBase) {
        return './' + url.slice(urlBase[0].length);
    }
    return url;
}
/**
 * @param {{fn: string, url: string, line: number, column: number}} stackLineData
 */
function applySourceMap(stackLineData) {
    if (!stackLineData) {
        return null;
    }
    const { fn } = stackLineData;
    let { url, line, column } = stackLineData;
    const sourceMap = tabris.Module.getSourceMap(url);
    if (sourceMap) {
        if (!sourceMap.decodedMappings) {
            sourceMap.decodedMappings = decodeMappings(sourceMap.mappings);
        }
        const match = findMapping(sourceMap.decodedMappings, line, column);
        if (match && match.length >= 4) {
            // TODO: use name index (match[4] if present) to rename "fn"
            const [generatedColumn, orgFile, orgLine, orgColumn] = match;
            const style = /^[A-Za-z]:/.test(url) ? 'win' : 'unix';
            url = normalizePath(dirname(url, style) + '/' + sourceMap.sources[orgFile], style);
            if (style === 'unix' && !url.startsWith('/') && !url.startsWith('./')) {
                url = './' + url;
            }
            line = orgLine + 1;
            column = column + (orgColumn - generatedColumn);
        }
        else {
            return null;
        }
    }
    return { fn, url, line, column };
}
function findMapping(mappings, line, column) {
    const lineMappings = mappings ? mappings[line - 1] : null;
    if (!lineMappings || !lineMappings.length) {
        return null;
    }
    return lineMappings.find((mapping, index) => {
        if (!mapping) {
            return false;
        }
        const next = lineMappings[index + 1];
        const startColumn = mapping[0] + 1;
        const endColumn = next ? next[0] + 1 : Infinity;
        if (index === 0 && column < startColumn) {
            return true;
        }
        return column >= startColumn && column < endColumn;
    });
}
/**
 * All code below
 * based on https://github.com/Rich-Harris/vlq/blob/b7093c21ec6c9bbfed454d2785909b53cec4bd98/src/vlq.ts
 * Copyright (c) 2017 Rich-Harris and MattiasBuelens
 * MIT licensed: https://github.com/Rich-Harris/vlq/blob/b7093c21ec6c9bbfed454d2785909b53cec4bd98/LICENSE
 */
const charToInteger = {};
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('')
    .forEach((char, i) => {
    charToInteger[char] = i;
});
function decodeMappings(mappings) {
    let sourceFileIndex = 0;
    let sourceCodeLine = 0;
    let sourceCodeColumn = 0;
    let nameIndex = 0;
    return mappings.split(';')
        .map(line => line.split(',').map(decodeVLQ))
        .map(line => {
        let generatedCodeColumn = 0;
        return line.map(segment => {
            if (segment.length === 0) {
                return null;
            }
            generatedCodeColumn += segment[0];
            const result = [generatedCodeColumn];
            if (segment.length === 1) {
                return result; // ???
            }
            sourceFileIndex += segment[1];
            sourceCodeLine += segment[2];
            sourceCodeColumn += segment[3];
            result.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);
            if (segment.length === 5) {
                nameIndex += segment[4];
                result.push(nameIndex);
            }
            return result;
        });
    });
}
function decodeVLQ(string) {
    const result = [];
    let shift = 0;
    let value = 0;
    for (let i = 0; i < string.length; i++) {
        let integer = charToInteger[string[i]];
        if (integer === undefined) {
            throw new Error('Invalid character (' + string[i] + ')');
        }
        const hasContinuationBit = integer & 32;
        integer &= 31;
        value += integer << shift;
        if (hasContinuationBit) {
            shift += 5;
        }
        else {
            const shouldNegate = value & 1;
            value >>= 1;
            result.push(shouldNegate ? -value : value);
            value = shift = 0;
        }
    }
    return result;
}

/* eslint-disable no-shadow */
function asap(fn) {
    setTimeout(fn, 0);
}
// --- core.js ---
function noop() { }
// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable
// to avoid using try/catch inside critical functions, we
// extract them to here.
let LAST_ERROR = null;
const IS_ERROR = {};
function getThen(obj) {
    try {
        return obj.then;
    }
    catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallOne(fn, a) {
    try {
        return fn(a);
    }
    catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallTwo(fn, a, b) {
    try {
        fn(a, b);
    }
    catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
// Promise may be used before tabris is initialized:
function getStackTraceStack() {
    return global.tabris ? global.tabris._stackTraceStack : [];
}
function setStackTraceStack(value) {
    if (global.tabris) {
        global.tabris._stackTraceStack = value;
    }
}
// Rollup may rename the Promise function ("name" property) if it (falsely)
// detects a clash with the presumed native Promise function (which only
// exists in node/test environment). Assigning it resolves this issue.
const Promise$1 = function Promise(fn) {
    const stackTraceStack = [new Error().stack].concat(getStackTraceStack().slice(0, 10));
    if (typeof this !== 'object') {
        throw new TypeError('Promises must be constructed via new');
    }
    if (typeof fn !== 'function') {
        throw new TypeError('not a function');
    }
    Object.defineProperties(this, {
        _deferredState: { value: 0, writable: true },
        _state: { value: 0, writable: true },
        _value: { value: null, writable: true },
        _stackTraceStack: { value: stackTraceStack, writable: false },
        _deferreds: { value: null, writable: true }
    });
    if (fn === noop) {
        return;
    }
    doResolve(fn, this);
};
Promise$1._noop = noop;
Promise$1.prototype.then = function (onFulfilled, onRejected) {
    if (this.constructor !== Promise$1) {
        return safeThen(this, onFulfilled, onRejected);
    }
    const res = new Promise$1(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
};
function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor((resolve, reject) => {
        const res = new Promise$1(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
    });
}
function handle(self, deferred) {
    while (self._state === 3) {
        self = self._value;
    }
    if (Promise$1._onHandle) {
        Promise$1._onHandle(self);
    }
    if (self._state === 0) {
        if (self._deferredState === 0) {
            self._deferredState = 1;
            self._deferreds = deferred;
            return;
        }
        if (self._deferredState === 1) {
            self._deferredState = 2;
            self._deferreds = [self._deferreds, deferred];
            return;
        }
        self._deferreds.push(deferred);
        return;
    }
    handleResolved(self, deferred);
}
function handleResolved(self, deferred) {
    asap(() => {
        const cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
            if (self._state === 1) {
                resolve(deferred.promise, self._value);
            }
            else {
                reject(deferred.promise, self._value);
            }
            return;
        }
        const oldStack = getStackTraceStack();
        setStackTraceStack(self._stackTraceStack);
        const ret = tryCallOne(cb, self._value);
        setStackTraceStack(oldStack);
        if (ret === IS_ERROR) {
            reject(deferred.promise, LAST_ERROR);
        }
        else {
            resolve(deferred.promise, ret);
        }
    });
}
function resolve(self, newValue) {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) {
        return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }
    if (newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')) {
        const then = getThen(newValue);
        if (then === IS_ERROR) {
            return reject(self, LAST_ERROR);
        }
        if (then === self.then &&
            newValue instanceof Promise$1) {
            self._state = 3;
            self._value = newValue;
            finale(self);
            return;
        }
        else if (typeof then === 'function') {
            doResolve(then.bind(newValue), self);
            return;
        }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
}
function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    if (Promise$1._onReject) {
        Promise$1._onReject(self, newValue);
    }
    finale(self);
}
function finale(self) {
    if (self._deferredState === 1) {
        handle(self, self._deferreds);
        self._deferreds = null;
    }
    if (self._deferredState === 2) {
        for (let i = 0; i < self._deferreds.length; i++) {
            handle(self, self._deferreds[i]);
        }
        self._deferreds = null;
    }
}
function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
    let done = false;
    const res = tryCallTwo(fn, (value) => {
        if (done) {
            return;
        }
        done = true;
        resolve(promise, value);
    }, (reason) => {
        if (done) {
            return;
        }
        done = true;
        reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
    }
}
// --- es6-extensions.js ---
// This file contains the ES6 extensions to the core Promises/A+ API
/* Static Functions */
function valuePromise(value) {
    const p = new Promise$1(Promise$1._noop);
    p._state = 1;
    p._value = value;
    return p;
}
Promise$1.resolve = function (value) {
    if (value instanceof Promise$1) {
        return value;
    }
    if (value === null) {
        return valuePromise(null);
    }
    if (typeof value === 'object' || typeof value === 'function') {
        try {
            const then = value.then;
            if (typeof then === 'function') {
                return new Promise$1(then.bind(value));
            }
        }
        catch (ex) {
            return new Promise$1((resolve, reject) => reject(ex));
        }
    }
    return valuePromise(value);
};
Promise$1.all = function (arr) {
    const args = Array.prototype.slice.call(arr);
    return new Promise$1((resolve, reject) => {
        if (args.length === 0) {
            return resolve([]);
        }
        let remaining = args.length;
        function res(i, val) {
            if (val && (typeof val === 'object' || typeof val === 'function')) {
                if (val instanceof Promise$1 && val.then === Promise$1.prototype.then) {
                    while (val._state === 3) {
                        val = val._value;
                    }
                    if (val._state === 1) {
                        return res(i, val._value);
                    }
                    if (val._state === 2) {
                        reject(val._value);
                    }
                    val.then(val => res(i, val), reject);
                    return;
                }
                else {
                    const then = val.then;
                    if (typeof then === 'function') {
                        const p = new Promise$1(then.bind(val));
                        p.then(val => res(i, val), reject);
                        return;
                    }
                }
            }
            args[i] = val;
            if (--remaining === 0) {
                resolve(args);
            }
        }
        for (let i = 0; i < args.length; i++) {
            res(i, args[i]);
        }
    });
};
Promise$1.reject = function (value) {
    return new Promise$1((resolve, reject) => reject(value));
};
Promise$1.race = function (values) {
    return new Promise$1((resolve, reject) => values.forEach(value => Promise$1.resolve(value).then(resolve, reject)));
};
/* Prototype Methods */
Promise$1.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
};
/* Inspection Methods */
function isPending(promise) {
    return promise._state === 0;
}
function isRejected(promise) {
    return promise._state === 2;
}
function getPromiseResult(promise) {
    return promise._value;
}
// --- rejection-tracking.js ---
const rejectionId = Symbol('rejection id');
let lastRejectionId = 0;
let rejectionDisplayId = 0;
const rejections = {};
Promise$1._onHandle = (promise) => {
    if (promise._state === 2 && // IS REJECTED
        rejections[promise[rejectionId]]) {
        if (rejections[promise[rejectionId]].logged) {
            console.warn(`Uncaught promise rejection (id: ${rejections[promise[rejectionId]].displayId}) handled.`);
        }
        else {
            clearTimeout(rejections[promise[rejectionId]].timeout);
        }
        delete rejections[promise[rejectionId]];
    }
};
Promise$1._onReject = (promise, error) => {
    if (promise._deferredState === 0) { // not yet handled
        promise[rejectionId] = lastRejectionId++;
        rejections[promise[rejectionId]] = {
            displayId: null,
            error,
            timeout: setTimeout(() => {
                const id = promise[rejectionId];
                rejections[id].displayId = rejectionDisplayId++;
                rejections[id].logged = true;
                console.error(`Uncaught promise rejection (id: ${rejections[id].displayId}) ${formatPromiseRejectionReason(error)}`);
            }, 0),
            logged: false
        };
    }
};

global.Promise = Promise$1;
if (typeof window === 'undefined') {
    global.window = global;
}
if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
    });
}
/**
 * Original code from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
function assign(target) {
    if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
    }
    const to = Object(target);
    for (let i = 1; i < arguments.length; i++) {
        const source = arguments[i];
        if (source === undefined || source === null) {
            continue;
        }
        const keys = Object.keys(Object(source));
        for (const key of keys) {
            const desc = Object.getOwnPropertyDescriptor(source, key);
            if (desc !== undefined && desc.enumerable) {
                to[key] = source[key];
            }
        }
    }
    return to;
}

function checkVersion(tabrisVersionString, clientVersionString) {
    if (!clientVersionString) {
        return;
    }
    const tabrisVersion = tabrisVersionString.split('.');
    const clientVersion = clientVersionString.split('.');
    if (tabrisVersion[0] !== clientVersion[0] || tabrisVersion[1] !== clientVersion[1]) {
        error(`Version mismatch: JavaScript module "tabris" (version ${tabrisVersionString}) ` +
            `is incompatible with the native tabris platform (version ${clientVersionString}).`);
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class EventObject {
    constructor() {
        Object.defineProperties(this, {
            type: { enumerable: true, get: () => this.$type },
            target: { enumerable: true, get: () => this.$target },
            timeStamp: { enumerable: true, value: Date.now() },
            $type: { enumerable: false, writable: true, value: '' },
            $target: { enumerable: false, writable: true, value: null },
            $defaultPrevented: { enumerable: false, writable: true, value: false }
        });
    }
    get defaultPrevented() {
        return !!this.$defaultPrevented;
    }
    preventDefault() {
        this.$defaultPrevented = true;
    }
    toString() {
        const header = this.constructor.name + ' { ';
        const content = Object.keys(this)
            .map(prop => `${prop}: ${typeof this[prop] === 'string' ? JSON.stringify(this[prop]) : format(this[prop])}`)
            .join(', ');
        const footer = ' }';
        return header + content + footer;
    }
    _initEvent(type, target) {
        if (arguments.length < 2) {
            throw new Error('Not enough arguments to initEvent');
        }
        this.$type = type;
        this.$target = target;
    }
}

class EventsClass {
    on(type, callback, context) {
        if (type instanceof Object) {
            for (const key in type) {
                this.on(key, type[key]);
            }
            return this;
        }
        assertType(type);
        assertCallback(callback);
        assertContext(context);
        if (this._isDisposed) {
            hint(this, `Event registration warning: Can not listen for event "${type}" on disposed object`);
        }
        const wasListening = this._isListening(type);
        if (!this._callbacks) {
            Object.defineProperty(this, '_callbacks', {
                enumerable: false, writable: false, configurable: true, value: []
            });
        }
        this._callbacks[type] = (this._callbacks[type] || []).concat();
        const alreadyAdded = this._callbacks[type].some(entry => ((entry.fn === callback || '_callback' in callback && entry.fn._callback === callback._callback) &&
            (entry.ctx === context)));
        if (!alreadyAdded) {
            this._callbacks[type].push({ fn: callback, ctx: context });
        }
        if (!wasListening) {
            this._listen(type, true);
        }
        return this;
    }
    off(type, callback, context) {
        if (type instanceof Object) {
            for (const key in type) {
                this.off(key, type[key]);
            }
            return this;
        }
        if (!type || !callback) {
            throw new Error('Not enough arguments');
        }
        if (this._callbacks) {
            if (type in this._callbacks) {
                const callbacks = this._callbacks[type].concat();
                for (let i = callbacks.length - 1; i >= 0; i--) {
                    if ((callbacks[i].fn === callback || callbacks[i].fn._callback === callback) &&
                        callbacks[i].ctx === context) {
                        callbacks.splice(i, 1);
                    }
                }
                if (callbacks.length === 0) {
                    delete this._callbacks[type];
                    if (Object.keys(this._callbacks).length === 0) {
                        delete this._callbacks;
                    }
                }
                else {
                    this._callbacks[type] = callbacks;
                }
            }
        }
        if (!this._isListening(type)) {
            this._listen(type, false);
        }
        return this;
    }
    once(type, callback, context) {
        if (type instanceof Object) {
            for (const key in type) {
                this.once(key, type[key]);
            }
            return this;
        }
        assertCallback(callback);
        const self = this;
        const wrappedCallback = function () {
            if (!self._isDisposed) {
                self.off(type, wrappedCallback, context);
            }
            callback.apply(this, arguments);
        };
        wrappedCallback._callback = callback;
        return this.on(type, wrappedCallback, context);
    }
    trigger(type, eventData = {}) {
        return this[notify](type, eventData, false);
    }
    triggerAsync(type, eventData = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this[notify](type, eventData, true);
        });
    }
    [notify](type, eventData, async) {
        const returnValues = [];
        if (!this._isDisposed) {
            if (this._callbacks && type in this._callbacks) {
                const uninitialized = (eventData instanceof EventObject) && !eventData.type;
                const dispatchObject = uninitialized ? eventData : new EventObject();
                const target = this.$eventTarget || this;
                if (eventData && (eventData !== dispatchObject)) {
                    const copyData = omit(eventData, ['type', 'target', 'timeStamp']);
                    Object.assign(dispatchObject, copyData);
                }
                if (dispatchObject._initEvent instanceof Function) {
                    dispatchObject._initEvent(type, target);
                }
                for (const callback of this._callbacks[type]) {
                    const value = callback.fn.call(callback.ctx || this, dispatchObject);
                    if (value instanceof Promise$1) {
                        value.catch(err => {
                            console.error(`Listener for ${target.constructor.name} event "${type}" rejected: ${formatPromiseRejectionReason(err)}`);
                        });
                    }
                    returnValues.push(value);
                }
            }
            if (this._callbacks && '*' in this._callbacks) {
                for (const callback of this._callbacks['*']) {
                    callback.fn.call(callback.ctx || this, { target: this, type, eventData });
                }
            }
        }
        else {
            hint(this, `Trigger warning: Can not dispatch event "${type}" on disposed object`);
        }
        return async ? Promise$1.all(returnValues).then(() => this) : this;
    }
    _isListening(type) {
        return !!this._callbacks && (!type || type in this._callbacks);
    }
    // eslint-disable-next-line
    _listen(type, isListening) { }
}
const EventsMixin = {};
Reflect.ownKeys(EventsClass.prototype).forEach(member => {
    if (member !== 'constructor') {
        EventsMixin[member] = EventsClass.prototype[member];
    }
});
function assertCallback(callback) {
    if (!(callback instanceof Function)) {
        throw new Error(toValueString(callback) + ' is not a function');
    }
}
function assertType(type) {
    if (typeof type !== 'string') {
        throw new Error(toValueString(type) + ' is not a string');
    }
}
function assertContext(context) {
    if (context && !(context instanceof Object)) {
        throw new Error(toValueString(context) + ' is not an object');
    }
}

/**
 * @template {any} T
 * @param {any} value
 * @param {Function} type
 * @param {any=} optionsOrCallback
 * @returns {T}
 */
function checkType(value, type, optionsOrCallback) {
    if (!type) {
        throw new TypeError('No type given');
    }
    if (isBoxedValue(value)) {
        throw new TypeError('Boxed values are forbidden');
    }
    const cb = optionsOrCallback instanceof Function ? optionsOrCallback : null;
    /** @type {{nullable?: boolean, name?: string}} */
    const options = (!optionsOrCallback || cb) ? {} : optionsOrCallback;
    const name = options.name || toValueString(value);
    const typeName = options.typeName || getTypeName(type);
    if (!isType(value, type, options.nullable)) {
        throw new TypeError(`Expected ${name} to be ${typeName}, got ${getValueTypeName(value)}.`);
    }
    if (typeof value === 'number') {
        checkNumber$1(value, name);
    }
    if (cb) {
        cb(value);
        return;
    }
    return value;
}
/**
 * @template {any} T
 * @template {any} U
 * @param {U} value
 * @param {Function & {prototype: T}} type
 * @param {boolean} nullable
 * @returns {U is T}
 */
function isType(value, type, nullable) {
    if (nullable && (value === null || value === undefined)) {
        return true;
    }
    if (value instanceof type || isPrimitiveOfType(value, type)) {
        return true;
    }
    return false;
}
/**
 * @param {Function} type
 * @returns {string}
 **/
function getTypeName(type) {
    const name = type.name;
    if (name === 'Function') {
        return 'a function';
    }
    if (name === 'Object') {
        return 'an object';
    }
    if (name === 'Array') {
        return 'an array';
    }
    if (isPrimitiveType(type)) {
        return 'a ' + name.toLowerCase();
    }
    return 'of type ' + name;
}
/**
 * @param {any} value
 * @returns {string}
 **/
function getValueTypeName(value) {
    if (value != null && isPrimitiveType(value.constructor)) {
        return value.constructor.name.toLowerCase();
    }
    if (value && value.constructor) {
        return value.constructor.name;
    }
    if (value === null) {
        return 'null';
    }
    return typeof value;
}
/**
 * @param {any} value
 * @param {Function} type
 * @returns {boolean}
 **/
function isPrimitiveOfType(value, type) {
    if (!isPrimitiveType(type)) {
        return false;
    }
    return typeof value === type.name.toLowerCase();
}
/**
 * @param {number} value
 * @param {string|undefined} name
 */
function checkNumber$1(value, name) {
    if (isNaN(value)) {
        throw new TypeError(`Expected ${name} to be a valid number, got ${toValueString(value)}.`);
    }
    if (!isFinite(value)) {
        throw new TypeError(`Expected ${name} to be a finite number, got ${toValueString(value)}.`);
    }
}
function isBoxedValue(value) {
    return value instanceof Boolean || value instanceof Number || value instanceof String;
}
/** @param {Function} type */
function isPrimitiveType(type) {
    return type === Boolean || type === Number || type === String;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const noop$1 = (...args) => undefined;
if (!Symbol.observable) {
    Object.defineProperty(Symbol, 'observable', { value: observable });
}
class Observable {
    constructor(subscribe = noop$1) {
        if (!(subscribe instanceof Function)) {
            throw new TypeError(`Expected subscribe to be a function, got ${getValueTypeName(subscribe)}.`);
        }
        this._subscribe = subscribe;
        this.subscribe = this.subscribe.bind(this);
    }
    static mutations(object) {
        return new Observable(observer => {
            const store = Listeners.getListenerStore(object);
            const native = object[nativeObservables];
            const dummyListener = () => null;
            const next = () => observer.next(object);
            const handleAny = (ev) => ev.type.endsWith('Changed') ? this.defer(next) : null;
            store.on({ '*': handleAny, 'dispose': observer.complete });
            native === null || native === void 0 ? void 0 : native.forEach(event => store.on(event, dummyListener));
            next();
            return () => {
                store.off({ '*': handleAny, 'dispose': observer.complete });
                native === null || native === void 0 ? void 0 : native.forEach(event => store.off(event, dummyListener));
            };
        });
    }
    subscribe(arg1, error, complete) {
        const observer = typeof arg1 === 'function' || arguments.length !== 1
            ? { next: arg1, error, complete }
            : arg1;
        let closed = false;
        let unsubscribe = noop$1;
        const subscription = {
            unsubscribe: () => {
                unsubscribe();
                closed = true;
            },
            get closed() {
                return closed;
            }
        };
        const teardown = this._subscribe(createSubscriber(observer, subscription));
        unsubscribe = getUnsubscribe(teardown);
        if (subscription.closed) {
            unsubscribe();
        }
        return subscription;
    }
    [Symbol.observable]() {
        return this;
    }
    static defer(fn) {
        if (this.deferred.indexOf(fn) === -1) {
            this.deferred.push(fn);
        }
        if (!this.inFlush) {
            tabris.once('tick', this.flush);
        }
    }
    static flush() {
        let limit = Observable.deferred.length + 100;
        while (Observable.deferred.length) {
            try {
                limit--;
                if (limit === 0) {
                    Observable.deferred = [];
                    throw new Error('Mutations observer recursion');
                }
                Observable.deferred.shift()();
            }
            catch (ex) {
                console.error(ex.message);
            }
        }
    }
}
Observable.deferred = [];
Observable.inFlush = false;
function createSubscriber(observer, subscription) {
    const next = observer.next || noop$1;
    const error = observer.error || noop$1;
    const complete = observer.complete || noop$1;
    return {
        next: (value) => {
            if (!subscription.closed) {
                next === null || next === void 0 ? void 0 : next.call(observer, value);
            }
        },
        error: (ex) => {
            if (!subscription.closed) {
                subscription.unsubscribe();
                error === null || error === void 0 ? void 0 : error.call(observer, ex);
            }
        },
        complete: () => {
            if (!subscription.closed) {
                subscription.unsubscribe();
                complete === null || complete === void 0 ? void 0 : complete.call(observer);
            }
        },
        get closed() {
            return subscription.closed;
        }
    };
}
function getUnsubscribe(teardown) {
    let called = false;
    return () => {
        if (!called) {
            called = true;
            if (teardown instanceof Function) {
                teardown();
            }
            else if (teardown && teardown.unsubscribe instanceof Function) {
                teardown.unsubscribe();
            }
        }
    };
}

const DELEGATE_FIELDS = [
    'promise', 'addListener', 'removeListener', 'once', 'trigger', 'triggerAsync',
    'subscribe', observable
];
class Listeners extends Observable {
    constructor(target, type) {
        super(observer => this._handleSubscription(observer));
        this.target = target;
        this.type = type;
        if (arguments.length < 1) {
            throw new Error('Missing target instance');
        }
        if (!(target instanceof Object)) {
            throw new Error(`Target ${toValueString(target)} is not an object`);
        }
        if (arguments.length < 2 || !type) {
            throw new Error('Missing event type string');
        }
        if (typeof type !== 'string') {
            throw new Error(`Event type ${toValueString(type)} is not a string`);
        }
        if (/^on[A-Z]/.test(type)) {
            throw new Error(`Invalid event type string, did you mean "${type[2].toLowerCase() + type.slice(3)}"?`);
        }
        this.store = Listeners.getListenerStore(target);
        const original = this;
        const delegate = Object.assign(this.addListener.bind(this), { original, target, type });
        for (const key of DELEGATE_FIELDS) {
            delegate[key] = original[key] = original[key].bind(this);
        }
        return delegate;
    }
    static getListenerStore(target) {
        if (target.on instanceof Function) {
            return target;
        }
        if (!target[listenersStore]) {
            target[listenersStore] = Object.assign({ $eventTarget: target }, EventsMixin);
        }
        return target[listenersStore];
    }
    get original() {
        return this;
    }
    trigger(eventData) {
        this.store.trigger(this.type, eventData);
        return this.target;
    }
    triggerAsync(eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.store.triggerAsync(this.type, eventData).then(() => this.target);
        });
    }
    promise() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise$1(resolve => this.once(resolve));
        });
    }
    once(listener) {
        this.store.once(this.type, listener);
        return this.target;
    }
    addListener(listener) {
        this.store.on(this.type, listener);
        return this.target;
    }
    removeListener(listener) {
        this.store.off(this.type, listener);
        return this.target;
    }
    _handleSubscription(observer) {
        this.addListener(observer.next);
        this.store.on('dispose', observer.complete);
        return () => {
            this.removeListener(observer.next);
            this.store.off('dispose', observer.complete);
        };
    }
}
function attributesWithoutListener(attributes) {
    return omit(attributes, Object.keys(attributes).filter(isListenerAttribute));
}
function registerListenerAttributes(obj, attributes, attached) {
    if (!obj.jsxAttributes) {
        obj.jsxAttributes = {};
    }
    const attachedListeners = attached || obj.jsxAttributes;
    const newListeners = getEventListeners(attributes);
    const store = Listeners.getListenerStore(obj);
    Object.keys(newListeners).forEach(type => {
        const oldListener = attachedListeners[type];
        if (oldListener) {
            if (newListeners[type] === oldListener) {
                return;
            }
            store.off(type, oldListener);
        }
        if (newListeners[type]) {
            store.on(type, attachedListeners[type] = newListeners[type]);
        }
    });
}
function isListenerAttribute(attribute) {
    return attribute.startsWith('on') && attribute.charCodeAt(2) <= 90;
}
function getEventListeners(attributes) {
    const listeners = {};
    for (const attribute in attributes) {
        if (isListenerAttribute(attribute)) {
            const event = attribute[2].toLocaleLowerCase() + attribute.slice(3);
            listeners[event] = attributes[attribute];
        }
    }
    return listeners;
}

function colorArrayToString(array) {
    const r = array[0];
    const g = array[1];
    const b = array[2];
    const a = array.length === 3 ? 1 : Math.round(array[3] * 100 / 255) / 100;
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
}
function colorStringToArray(str) {
    if (str === 'transparent') {
        return [0, 0, 0, 0];
    }
    // #xxxxxx and #xxxxxxxx
    if (/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?$/.test(str)) {
        return [
            parseInt(RegExp.$1, 16),
            parseInt(RegExp.$2, 16),
            parseInt(RegExp.$3, 16),
            RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16)
        ];
    }
    // #xxx and #xxxx
    if (/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?$/.test(str)) {
        return [
            parseInt(RegExp.$1, 16) * 17,
            parseInt(RegExp.$2, 16) * 17,
            parseInt(RegExp.$3, 16) * 17,
            RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16) * 17
        ];
    }
    // #rgb(r, g, b)
    if (/^rgb\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*\)$/.test(str)) {
        return [
            Math.max(0, Math.min(255, parseInt(RegExp.$1))),
            Math.max(0, Math.min(255, parseInt(RegExp.$2))),
            Math.max(0, Math.min(255, parseInt(RegExp.$3))),
            255
        ];
    }
    // rgba(r, g, b, a)
    if (/^rgba\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?([0-9]*\.)?[0-9]+)\s*\)$/.test(str)) {
        return [
            Math.max(0, Math.min(255, parseInt(RegExp.$1))),
            Math.max(0, Math.min(255, parseInt(RegExp.$2))),
            Math.max(0, Math.min(255, parseInt(RegExp.$3))),
            Math.round(Math.max(0, Math.min(1, parseFloat(RegExp.$4))) * 255)
        ];
    }
    // named colors
    if (str in NAMES) {
        const rgb = NAMES[str];
        return [rgb[0], rgb[1], rgb[2], 255];
    }
    throw new Error(`${toValueString(str)} is not a valid color`);
}
/*
 * Basic color keywords as defined in CSS 3
 * See http://www.w3.org/TR/css3-color/#html4
 */
const NAMES = {
    black: [0, 0, 0],
    silver: [192, 192, 192],
    gray: [128, 128, 128],
    white: [255, 255, 255],
    maroon: [128, 0, 0],
    red: [255, 0, 0],
    purple: [128, 0, 128],
    fuchsia: [255, 0, 255],
    green: [0, 128, 0],
    lime: [0, 255, 0],
    olive: [128, 128, 0],
    yellow: [255, 255, 0],
    navy: [0, 0, 128],
    blue: [0, 0, 255],
    teal: [0, 128, 128],
    aqua: [0, 255, 255],
    transparent: [0, 0, 0, 0]
};

class Color {
    static isColorValue(value) {
        return value == null || value === 'initial' || Color.isValidColorValue(value);
    }
    static isValidColorValue(value) {
        try {
            Color.from(value);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    static from(value) {
        if (value instanceof Color) {
            return value;
        }
        if (value instanceof Array) {
            return arrayToColorInstance(value);
        }
        if (value instanceof Object) {
            return colorLikeObjectToColorInstance(value);
        }
        if (typeof value === 'string') {
            return arrayToColorInstance(colorStringToArray(value));
        }
        throw new Error(`Not a valid ColorValue: ${toValueString(value)}`);
    }
    constructor(red, green, blue, alpha = 255) {
        if (arguments.length > 4) {
            throw new Error('Too many arguments');
        }
        if (arguments.length < 3) {
            throw new Error('Not enough arguments');
        }
        setChannel(this, 'red', red);
        setChannel(this, 'green', green);
        setChannel(this, 'blue', blue);
        setChannel(this, 'alpha', alpha);
    }
    toString() {
        if (this.alpha === 255) {
            return `rgb(${this.red}, ${this.green}, ${this.blue})`;
        }
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${Math.round(this.alpha * 100 / 255) / 100})`;
    }
    toArray() {
        return [this.red, this.green, this.blue, this.alpha];
    }
    equals(value) {
        if (!(value instanceof Color)) {
            return false;
        }
        return value.red === this.red
            && value.green === this.green
            && value.blue === this.blue
            && value.alpha === this.alpha;
    }
}
Color.prototype[equals] = Color.prototype.equals;
Object.keys(NAMES).forEach(name => {
    let value; // create lazy to avoid circular dependency issues
    Object.defineProperty(Color, name, { get() {
            if (!value) {
                value = Color.from(NAMES[name]);
            }
            return value;
        } });
});
function setChannel(color, channel, value) {
    checkNumber(value, [0, 255], `Invalid color value ${toValueString(channel)}`);
    Object.defineProperty(color, channel, { enumerable: true, value: Math.round(value) });
}
function colorLikeObjectToColorInstance(value) {
    checkProperty(value, 'red');
    checkProperty(value, 'green');
    checkProperty(value, 'blue');
    if ('alpha' in value) {
        return new Color(value.red, value.green, value.blue, value.alpha);
    }
    return new Color(value.red, value.green, value.blue);
}
function arrayToColorInstance(value) {
    if (value.length < 3) {
        throw new Error('Color array too short');
    }
    if (value.length > 4) {
        throw new Error('Color array too long');
    }
    return new Color(value[0], value[1], value[2], value.length === 4 ? value[3] : 255);
}
function checkProperty(object, prop) {
    if (!(prop in object)) {
        throw new Error(`Color-like object missing ${prop} value`);
    }
}

const FONT_STYLES = ['italic', 'normal'];
const FONT_WEIGHTS = ['black', 'bold', 'medium', 'thin', 'light', 'normal'];
function fontStringToObject(str) {
    const result = { family: [], size: 0, style: 'normal', weight: 'normal' };
    const parts = str.split(/(?:\s|^)\d+px(?:\s|$)/);
    checkTruthy(parts.length === 2, 'Invalid font syntax');
    const [sizePrefix, sizeSuffix] = parts;
    result.size = parseInt(/(?:\s|^)(\d+)px(?:\s|$)/.exec(str)[1], 10);
    parseSizePrefix(result, sizePrefix);
    parseFamily(result, sizeSuffix);
    return result;
}
function fontObjectToString(font) {
    return [
        font.style === 'normal' ? '' : font.style,
        font.weight === 'normal' ? '' : font.weight,
        font.size + 'px',
        font.family.join(', ')
    ].filter(str => !!str).join(' ').trim();
}
function validateFamily(name) {
    const valid = /(?:^\s*[^"']+\s*$)|(?:^\s*"[^"']+"\s*$)|(?:^\s*'[^"']+'\s*$)/.exec(name);
    checkTruthy(valid, 'Invalid font family: ' + name);
}
function validateStyle(style) {
    checkTruthy(isStyle(style), `Invalid font style ${style}`);
}
function validateWeight(weight) {
    checkTruthy(isWeight(weight), `Invalid font weight ${weight}`);
}
function normalizeFamily(value) {
    return /^\s*["']?([^"']*)/.exec(value)[1].trim();
}
function normalizeWeight(value) {
    return value.trim();
}
function normalizeStyle(value) {
    return value.trim();
}
function parseSizePrefix(fontObj, prefix) {
    const prefixes = prefix.trim().split(/\s+/);
    checkTruthy(prefixes.length <= 2, 'Too many font size prefixes');
    const { style, weight } = parseSizePrefixes(prefixes);
    fontObj.style = style;
    fontObj.weight = weight;
}
function parseSizePrefixes(prefixes) {
    // [styleOrWeight]
    // [style, weight]
    if (prefixes.length === 1) {
        const prefix = prefixes[0];
        if (isStyle(prefix)) {
            return { weight: 'normal', style: normalizeStyle(prefix) };
        }
        else if (isWeight(prefix)) {
            return { weight: normalizeWeight(prefix), style: 'normal' };
        }
        else if (prefix === 'normal' || prefix === '') {
            return { style: 'normal', weight: 'normal' };
        }
        throw new Error(`Invalid font style or weight ${prefix}`);
    }
    else if (prefixes.length === 2) {
        validateStyle(prefixes[0]);
        validateWeight(prefixes[1]);
        return { style: normalizeStyle(prefixes[0]), weight: normalizeWeight(prefixes[1]) };
    }
}
function isStyle(value) {
    return typeof value === 'string' && FONT_STYLES.includes(value.trim());
}
function isWeight(value) {
    return typeof value === 'string' && FONT_WEIGHTS.includes(value.trim());
}
function parseFamily(fontArr, family) {
    // NOTE: Currently family is optional to allow for default fonts, but this is
    //       not CSS font syntax. See https://github.com/eclipsesource/tabris-js/issues/24
    (family ? family.split(',') : []).forEach((name) => {
        validateFamily(name);
        fontArr.family.push(normalizeFamily(name));
    });
}
function checkTruthy(value, message) {
    if (!value) {
        throw new Error(message);
    }
}

class Font {
    static isFontValue(value) {
        return value == null || value === 'initial' || Font.isValidFontValue(value);
    }
    static isValidFontValue(value) {
        try {
            Font.from(value);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    static from(value) {
        if (value instanceof Font) {
            return value;
        }
        if (value instanceof Object) {
            return fontLikeObjectToFontInstance(value);
        }
        if (typeof value === 'string') {
            return fontLikeObjectToFontInstance(fontStringToObject(value));
        }
        throw new Error(`${toValueString(value)} is not a valid FontValue`);
    }
    static get sansSerif() {
        return 'sans-serif';
    }
    static get serif() {
        return 'serif';
    }
    static get monospace() {
        return 'monospace';
    }
    static get condensed() {
        return 'condensed';
    }
    constructor(size, family = [], weight = 'normal', style = 'normal') {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments');
        }
        setSize(this, size);
        setFamily(this, family);
        setWeight(this, weight);
        setStyle(this, style);
    }
    toString() {
        return fontObjectToString(this);
    }
    equals(value) {
        if (!(value instanceof Font)) {
            return false;
        }
        return value.size === this.size
            && value.weight === this.weight
            && value.style === this.style
            && value.family.length === this.family.length
            && value.family.every((family, index) => this.family[index] === family);
    }
}
Font.prototype[equals] = Font.prototype.equals;
function setFamily(font, family) {
    if (!(family instanceof Array)) {
        throw new Error('family is not an array');
    }
    family.forEach(validateFamily);
    const value = Object.freeze(family.map(normalizeFamily));
    Object.defineProperty(font, 'family', { enumerable: true, value });
}
function setSize(font, value) {
    checkNumber(value, [0, Infinity], 'Invalid font size');
    Object.defineProperty(font, 'size', { enumerable: true, value });
}
function setWeight(font, value) {
    validateWeight(value);
    Object.defineProperty(font, 'weight', { enumerable: true, value: normalizeWeight(value) });
}
function setStyle(font, value) {
    validateStyle(value);
    Object.defineProperty(font, 'style', { enumerable: true, value: normalizeStyle(value) });
}
function fontLikeObjectToFontInstance(value) {
    checkProperty$1(value, 'size');
    return new Font(value.size, value.family || [], value.weight || 'normal', value.style || 'normal');
}
function checkProperty$1(object, prop) {
    if (!(prop in object)) {
        throw new Error(`Font-like object missing ${prop} value`);
    }
}

const COMMON_ATTR = Object.freeze({
    textColor: (value) => Color.from(value).toString(),
    font: (value) => Font.from(value).toString(),
    children: (value) => {
        if (!(value instanceof Array)) {
            throw new Error('Not an array: ' + toValueString(value));
        }
        return value;
    }
});
const MARKUP = Object.freeze({
    br: {},
    b: COMMON_ATTR,
    span: COMMON_ATTR,
    big: COMMON_ATTR,
    i: COMMON_ATTR,
    small: COMMON_ATTR,
    strong: COMMON_ATTR,
    ins: COMMON_ATTR,
    del: COMMON_ATTR,
    a: Object.assign({
        href: (value) => {
            if (typeof value !== 'string') {
                throw new Error('Not a string: ' + toValueString(value));
            }
            return value;
        }
    }, COMMON_ATTR)
});
function createJsxProcessor() {
    return new JsxProcessor();
}
class JsxProcessor {
    createElement(Type, attributes, ...children) {
        if (!(Type instanceof Function) && typeof Type !== 'string') {
            throw new Error(`JSX: Unsupported type ${toValueString(Type)}`);
        }
        const typeName = Type instanceof Function ? Type.name : Type;
        if ((attributes === null || attributes === void 0 ? void 0 : attributes.children) && children && children.length) {
            throw new Error(`JSX: Children for type ${typeName} given twice.`);
        }
        // Children may be part of attributes or given as varargs or both.
        // For JSX factories/functional components they should always be part of attributes
        const rawChildren = children.length ? children : (attributes === null || attributes === void 0 ? void 0 : attributes.children) || [];
        const { finalChildren, additionalAttributes } = parseChildren(rawChildren, Type);
        const finalAttributes = Object.assign({}, attributes);
        joinAttributes(finalAttributes, additionalAttributes, Type);
        if (finalChildren) {
            finalAttributes.children = finalChildren;
        }
        if (typeof Type === 'string') {
            return this.createIntrinsicElement(Type, finalAttributes);
        }
        else if (Type.prototype && Type.prototype[JSX.jsxFactory]) {
            return this.createCustomComponent(Type, finalAttributes);
        }
        else {
            return this.createFunctionalComponent(Type, finalAttributes);
        }
    }
    createCustomComponent(Type, attributes) {
        return Type.prototype[JSX.jsxFactory].call(this, Type, attributes);
    }
    createFunctionalComponent(Type, attributes) {
        try {
            const result = Type.call(this, attributes);
            Type[jsxType] = true;
            if (result instanceof Object) {
                result[jsxType] = Type;
            }
            return result;
        }
        catch (ex) {
            throw new Error(`JSX: "${ex.message}" ${getCurrentLine(ex)}`);
        }
    }
    createIntrinsicElement(el, attributes) {
        if (el in MARKUP) {
            const encoded = {};
            Object.keys(attributes || {}).forEach(attribute => {
                const encoder = MARKUP[el][attribute];
                if (!encoder) {
                    if (attribute === 'children') {
                        throw new Error(`Element "${el}" can not have children`);
                    }
                    else {
                        throw new Error(`Element "${el}" does not support attribute "${attribute}"`);
                    }
                }
                try {
                    encoded[attribute] = encoder(attributes[attribute]);
                }
                catch (ex) {
                    throw new Error(`Element "${el}" attribute "${attribute}" can not bet set: ${ex.message}`);
                }
            });
            const text = joinTextContent(encoded.children, true);
            const tagOpen = [el].concat(Object.keys(encoded || {}).filter(attr => attr !== 'children').map(attribute => `${attribute}='${encoded[attribute]}'`)).join(' ');
            if (text) {
                return `<${tagOpen}>${text}</${el}>`;
            }
            return `<${tagOpen}/>`;
        }
        throw new Error(`JSX: Unsupported type ${el}`);
    }
    createNativeObject(Type, attributes) {
        if (attributes && 'children' in attributes) {
            throw new Error(`JSX: ${Type.name} can not have children`);
        }
        const result = new Type(attributesWithoutListener(attributes || {}));
        registerListenerAttributes(result, attributes);
        return result;
    }
    getChildren(attributes) {
        if (!attributes || !('children' in attributes)) {
            return null;
        }
        return flattenChildren(attributes.children);
    }
    withoutChildren(attributes) {
        return omit(attributes, ['children']);
    }
    withContentText(attributes, content, property, markupEnabled) {
        if (attributes && attributes[property] && content && content.length) {
            throw new Error(`JSX: ${property} given twice`);
        }
        const text = attributes && attributes[property]
            ? attributes[property].toString()
            : joinTextContent(content || [], markupEnabled);
        return Object.assign(attributes || {}, text ? { [property]: text } : {});
    }
    withContentChildren(attributes, content, property) {
        if (attributes && attributes[property] && content && content.length) {
            throw new Error(`JSX: ${property} given twice`);
        }
        const children = attributes && attributes[property] ? attributes[property] : (content || []);
        return Object.assign(attributes || {}, children ? { [property]: children } : {});
    }
    withShorthands(attributes, shorthandsMapping, merge) {
        const shorthandsKeys = Object.keys(shorthandsMapping);
        const shorthands = shorthandsKeys.filter(value => value in attributes);
        if (!shorthands.length) {
            return attributes;
        }
        const attrCopy = omit(attributes, shorthandsKeys);
        shorthands.forEach(shorthand => {
            const prop = shorthandsMapping[shorthand];
            if (prop in attrCopy) {
                attrCopy[prop] = merge(attrCopy[prop], shorthand);
            }
            else {
                attrCopy[prop] = shorthand;
            }
        });
        return attrCopy;
    }
    makeFactories(dic) {
        const result = {};
        Object.keys(dic).forEach(key => {
            result[key] = this.makeFactory(dic[key]);
        });
        return result;
    }
    makeFactory(constructor) {
        if (arguments.length !== 1) {
            throw new Error(`Expected exactly one argument, got ${arguments.length}`);
        }
        checkType(constructor, Function, 'first parameter');
        if (!constructor.prototype || !constructor.prototype[JSX.jsxFactory]) {
            throw new Error(`Function ${constructor.name} is not a valid constructor`);
        }
        if (constructor[originalComponent]) {
            return this.makeFactory(constructor[originalComponent]);
        }
        return createFactoryProxy(this, constructor);
    }
}
function createFactoryProxy(processor, constructor) {
    const handler = {
        apply(target, _thisArg, args) {
            const [attributes, functionalComponent] = args;
            const result = processor.createElement(proxy, attributes);
            if (functionalComponent instanceof Function && result instanceof Object) {
                functionalComponent[JSX.jsxType] = true;
                result[JSX.jsxType] = functionalComponent;
            }
            return result;
        },
        get(target, property, receiver) {
            if (receiver === proxy) {
                if (property === originalComponent) {
                    return constructor;
                }
                if (property === proxyHandler) {
                    return handler;
                }
            }
            return Reflect.get(target, property, receiver);
        }
    };
    /** @type {Factory} */
    const proxy = new Proxy(constructor, handler);
    return proxy;
}
/**
 * Converts any value to a flat array.
 */
function flattenChildren(children) {
    if (children instanceof Array) {
        let result = [];
        for (const child of children) {
            if (child && child.toArray) {
                result = result.concat(flattenChildren(child.toArray()));
            }
            else if (child instanceof Array) {
                result = result.concat(flattenChildren(child));
            }
            else {
                result.push(child);
            }
        }
        return result;
    }
    return [children];
}
function joinTextContent(textArray, markupEnabled) {
    if (!textArray) {
        return null;
    }
    if (markupEnabled) {
        return textArray
            .map(str => str + '')
            .join('')
            .replace(/\s+/g, ' ')
            .replace(/\s*<br\s*\/>\s*/g, '<br/>');
    }
    return textArray.join('');
}
const JSX = {
    processor: null,
    jsxFactory: jsxFactory,
    jsxType: jsxType,
    install(jsxProcessor) {
        this.processor = jsxProcessor;
    },
    createElement() {
        return this.processor.createElement.apply(this.processor, arguments);
    }
};
function parseChildren(rawChildren, type) {
    const children = rawChildren === null || rawChildren === void 0 ? void 0 : rawChildren.filter(value => !isAttributesObject(value));
    const attributes = rawChildren === null || rawChildren === void 0 ? void 0 : rawChildren.filter(isAttributesObject).reduce((prev, current) => joinAttributes(prev, current, type), {});
    return {
        finalChildren: children.length ? children : null,
        additionalAttributes: omit(attributes, [jsxType, setterTargetType])
    };
}
function isAttributesObject(value) {
    return value instanceof Object && value[setterTargetType] instanceof Function;
}
function joinAttributes(target, source, actualTargetType) {
    const expectedTargetType = source[setterTargetType];
    const actualTargetTypeFn = typeof actualTargetType === 'string' ? String : actualTargetType;
    if (expectedTargetType
        && actualTargetTypeFn.prototype[JSX.jsxFactory] // for SFC we can't know the future instance type
        && (actualTargetTypeFn.prototype !== expectedTargetType.prototype)
        && !(actualTargetTypeFn.prototype instanceof expectedTargetType)) {
        const firstKey = Object.keys(source)[0];
        const typeName = actualTargetType instanceof Function
            ? actualTargetType.name
            : actualTargetType;
        throw new TypeError(`Attribute "${firstKey}" is targeting ${expectedTargetType.name}, but is set on ${typeName}`);
    }
    Object.keys(source).forEach(key => {
        if (key in target) {
            if (Array.isArray(target[key]) && Array.isArray(source[key])) {
                target[key] = target[key].concat(source[key]);
            }
            else {
                throw new Error(`Attribute "${key}" is set multiple times`);
            }
        }
        else {
            target[key] = source[key];
        }
    });
    return target;
}

const MSG_FILTER_ERR = 'This may be a functional component that was not configured correctly.'
    + ' Please consult documentation on declarative UI.';
function select(array, selector, deep, widgetCollection) {
    if (!array || array.length === 0) {
        return [];
    }
    if (selector === '*' && !deep) {
        return array.concat();
    }
    const filter = getFilter(selector, widgetCollection);
    if (deep) {
        return deepSelect([], array, filter);
    }
    return array.filter(filter);
}
function createSelectorArray(selector, host) {
    if (!selector) {
        return ['*'];
    }
    if (selector instanceof Function) {
        return [selector];
    }
    const result = selector.split('>').map(str => str.trim());
    const rootIndex = result.indexOf(':host');
    if (rootIndex !== -1) {
        result[rootIndex] = host;
    }
    return result;
}
function getSelectorSpecificity(selectorArray) {
    return selectorArray.filter(isIdSelector).length * 100
        + selectorArray.filter(isClassSelector).length * 10
        + selectorArray.filter(isTypeSelector).length;
}
function isTypeSelector(selector) {
    if (selector instanceof Function) {
        return true;
    }
    return selector !== '*' && !isIdSelector(selector) && !isClassSelector(selector);
}
function isClassSelector(selector) {
    return selector[0] === '.' || selector[0] === ':';
}
function isIdSelector(selector) {
    return selector[0] === '#';
}
function deepSelect(result, iterable, filter) {
    for (const widget of iterable) {
        if (filter(widget)) {
            result.push(widget);
        }
        const children = widget.children ? widget.children() : null;
        if (children instanceof WidgetCollection && children.length) {
            deepSelect(result, children, filter);
        }
    }
    return result;
}
function getFilter(selector, widgetCollection) {
    const matches = {};
    const filter = isFilter(selector) ? selector : createMatcher(selector, widgetCollection);
    return (widget, index) => {
        if (matches[widget.cid]) {
            return false;
        }
        let isMatch = false;
        try {
            isMatch = filter(widget, index, widgetCollection);
        }
        catch (ex) {
            let msg = `Selector function ${filter.name} caused exception "${ex.message}".\n`;
            if (/^[A-Z]/.test(filter.name)) {
                msg += MSG_FILTER_ERR;
            }
            throw new Error(msg);
        }
        if (isMatch instanceof NativeObject) {
            throw new Error(`Selector function ${filter.name} returned ${toValueString(isMatch)}.\n${MSG_FILTER_ERR}`);
        }
        if (isMatch) {
            matches[widget.cid] = true;
            return true;
        }
        return false;
    };
}
function createMatcher(selectorArg, widgetCollection) {
    let selector = selectorArg;
    if (selector instanceof Array) {
        if (selector.length === 1) {
            selector = selector[0];
        }
        else {
            return createChildMatcher(selector, widgetCollection);
        }
    }
    if (selector instanceof Function && selector[JSX.jsxType]) {
        return widget => widget[JSX.jsxType] === selector;
    }
    if (selector instanceof Function) {
        return widget => widget instanceof selector;
    }
    if (selector instanceof NativeObject) {
        return widget => widget === selector;
    }
    if (selector.indexOf('>') !== -1) {
        return createChildMatcher(createSelectorArray(selector, widgetCollection.host), widgetCollection);
    }
    if (selector.charAt(0) === '#') {
        const expectedId = selector.slice(1);
        return widget => expectedId === widget.id;
    }
    if (selector.charAt(0) === '.') {
        const expectedClass = selector.slice(1);
        return widget => widget.classList.indexOf(expectedClass) !== -1;
    }
    if (selector === '*') {
        return () => true;
    }
    return widget => selector === widget.constructor.name
        || selector === (widget[JSX.jsxType] ? widget[JSX.jsxType].name : false);
}
function createChildMatcher(selectors, widgetCollection) {
    const matchers = selectors
        .map(selector => createMatcher(selector, widgetCollection)).reverse();
    return widget => {
        let current = widget;
        for (let i = 0; i < matchers.length; i++) {
            if (!current || !matchers[i](current)) {
                return false;
            }
            current = current.parent();
        }
        return true;
    };
}
function isFilter(selector) {
    return selector instanceof Function && !isWidgetConstructor(selector) && !selector[JSX.jsxType];
}
function isWidgetConstructor(fn) {
    let proto = fn.prototype;
    while (proto) {
        // Use NativeObject since importing Widget would causes circulary module dependency issues
        if (proto === NativeObject.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}

/** @typedef {import('./Widget').default} Widget */
/** @typedef {Widget[]|WidgetCollection} Widgets */
/** @typedef {string|Function} Selector */
class WidgetCollection {
    /**
     * @param {Widgets=} collection
     * @param {{selector?: Selector, deep?: boolean, origin?: Widget|WidgetCollection}} internals
     */
    constructor(collection, { selector, deep, origin } = {}) {
        if (selector && !origin) {
            throw new Error('WidgetCollection can not be constructed with an selector but no origin');
        }
        const arr = collection instanceof WidgetCollection ? collection.toArray() : collection;
        Object.defineProperty(this, '_host', { enumerable: false, writable: false, value: getHost(origin) });
        /** @type {Widget[]} */
        const _array = select(arr, selector || '*', deep, origin instanceof WidgetCollection ? origin : this);
        Object.defineProperty(this, '_array', { enumerable: false, writable: false, value: _array });
        for (let i = 0; i < _array.length; i++) {
            this[i] = _array[i];
        }
    }
    get length() {
        return this._array.length;
    }
    get host() {
        return this._host;
    }
    first(selector) {
        if (selector) {
            return this.filter(selector).first();
        }
        return this._array[0];
    }
    last(selector) {
        if (selector) {
            return this.filter(selector).last();
        }
        return this._array[this._array.length - 1];
    }
    /** @param {any=} selector */
    only(selector) {
        if (selector) {
            return this.filter(selector).only();
        }
        if (this._array.length !== 1) {
            throw new Error('Expected exactly one match, but found ' + this.length);
        }
        return this._array[0];
    }
    toArray() {
        return this._array.concat();
    }
    forEach(callback) {
        this._array.forEach((value, index) => callback(value, index, this));
    }
    map(callback) {
        return this._array.map((value, index) => callback(value, index, this));
    }
    indexOf(needle) {
        return this._array.indexOf(needle);
    }
    slice() {
        return new WidgetCollection(this._array.slice.apply(this._array, arguments), { origin: this });
    }
    concat() {
        const added = Array.prototype.map.call(arguments, part => part instanceof WidgetCollection ? part.toArray() : part);
        return new WidgetCollection(this._array.concat.apply(this._array, added), { origin: this });
    }
    includes(needle) {
        return this._array.indexOf(needle) !== -1;
    }
    filter(selector) {
        return new WidgetCollection(this._array, { selector, origin: this });
    }
    parent() {
        const result = [];
        for (const widget of this._array) {
            const parent = widget.parent();
            if (parent && result.indexOf(parent) === -1) {
                result.push(parent);
            }
        }
        if (result.length) {
            return new WidgetCollection(result, { origin: this });
        }
    }
    children(selector) {
        const result = [];
        for (const widget of this._array) {
            if (widget.children instanceof Function) {
                result.push.apply(result, widget.children());
            }
        }
        return new WidgetCollection(result, { selector, origin: this });
    }
    appendTo(parent) {
        parent.append(this);
    }
    set(...args) {
        this._array.forEach(widget => widget.set(...args));
        return this;
    }
    on(...args) {
        this._array.forEach(widget => widget.on(...args));
        return this;
    }
    off(...args) {
        this._array.forEach(widget => widget.off(...args));
        return this;
    }
    once(...args) {
        this._array.forEach(widget => widget.once(...args));
        return this;
    }
    trigger(...args) {
        this._array.forEach(widget => widget.trigger(...args));
        return this;
    }
    animate(...args) {
        this._array.forEach(widget => widget.animate(...args));
    }
    dispose() {
        this._array.forEach(widget => widget.dispose());
    }
    detach() {
        this._array.forEach(widget => widget.detach());
    }
    toString() {
        if (this._array.length < 4) {
            return 'WidgetCollection { ' + this._array.join(', ') + ' }';
        }
        return 'WidgetCollection {\n'
            + this._array.map(entry => '  ' + entry).join(',\n')
            + '\n}';
    }
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => index < this.length
                ? { value: this[index++], done: false }
                : { done: true }
        };
    }
}
WidgetCollection.prototype[JSX.jsxFactory] = createElement;
/** @this {import("./JsxProcessor").default} */
function createElement(Type, attributes) {
    if (Object.keys(this.withoutChildren(attributes)).length) {
        throw new Error('JSX: WidgetCollection can not have attributes');
    }
    return new Type(this.getChildren(attributes) || []);
}
function getHost(origin) {
    if (origin instanceof WidgetCollection) {
        return origin.host;
    }
    return origin || null;
}

class Image {
    /**
     * @param {any} value
     */
    static isImageValue(value) {
        return value == null || value === 'initial' || Image.isValidImageValue(value);
    }
    /**
     * @param {any} value
     */
    static isValidImageValue(value) {
        try {
            Image.from(value);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    /**
     * @param {any} value
     */
    static from(value) {
        if (value instanceof Image) {
            if (getNativeObject(value.src) && getNativeObject(value.src).isDisposed()) {
                throw new Error('ImageBitmap is closed');
            }
            return value;
        }
        if (typeof value === 'string' || getNativeObject(value) || getBytes(value)) {
            return new Image({ src: value });
        }
        if (value instanceof Object) {
            if (hasInconsistentDimensions(value)) {
                hint(this === Image ? 'Image.from' : this, 'image "scale" is ignored when "width" and/or "height" are set to a number');
                return new Image(Object.assign({}, value, { scale: 'auto' }));
            }
            return new Image(value);
        }
        throw new Error(`${toValueString(value)} is not a valid ImageValue`);
    }
    /**
     * @param {ImageLikeObject} imageLike
     */
    constructor(imageLike) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments');
        }
        checkConsistentDimensions(imageLike);
        setSrc(this, imageLike);
        setDimension(this, 'width', hasExplicit(imageLike, 'width') ? imageLike.width : 'auto');
        setDimension(this, 'height', hasExplicit(imageLike, 'height') ? imageLike.height : 'auto');
        setScale(this, imageLike);
    }
    equals(value) {
        if (!(value instanceof Image)) {
            return false;
        }
        return value.src === this.src
            && value.scale === this.scale
            && value.width === this.width
            && value.height === this.height;
    }
}
Image.prototype[equals] = Image.prototype.equals;
/** @type {number|Auto} */
const initDimension = 0;
/** @type {string|object} */
const initSrc = '';
Object.defineProperty(Image.prototype, 'src', { value: initSrc });
Object.defineProperty(Image.prototype, 'width', { value: initDimension });
Object.defineProperty(Image.prototype, 'height', { value: initDimension });
Object.defineProperty(Image.prototype, 'scale', { value: initDimension });
/**
 * @param {Image} image
 * @param {ImageLikeObject} imageLike
 */
function setScale(image, imageLike) {
    let scale = hasExplicit(imageLike, 'scale') ? imageLike.scale : 'auto';
    if (imageLike.scale == null
        && !hasExplicit(imageLike, 'width')
        && !hasExplicit(imageLike, 'height')
        && typeof imageLike.src === 'string') {
        const autoScaleMatch = /@([0-9]\.?[0-9]*)x/.exec(imageLike.src.split('/').pop());
        if (autoScaleMatch && autoScaleMatch[1]) {
            scale = parseFloat(autoScaleMatch[1]);
        }
    }
    setDimension(image, 'scale', scale);
}
/**
 * @param {ImageLikeObject} imageLike
 * @param {keyof ImageLikeObject} property
 */
function hasExplicit(imageLike, property) {
    return property in imageLike && imageLike[property] !== 'auto' && imageLike[property] != null;
}
/**
 * @param {Image} image
 * @param {ImageLikeObject} imageLike
 */
function setSrc(image, imageLike) {
    checkSrc(imageLike);
    if (getNativeObject(imageLike.src) || getBytes(imageLike.src)) {
        Object.defineProperty(image, 'src', { enumerable: true, value: imageLike.src });
    }
    else {
        let path;
        try {
            path = normalizePathUrl(imageLike.src);
        }
        catch (err) {
            throw new Error('Invalid image "src": ' + err.message);
        }
        Object.defineProperty(image, 'src', { enumerable: true, value: path });
    }
}
/**
 * @param {ImageLikeObject} imageLike
 */
function checkSrc(imageLike) {
    if (!('src' in imageLike)) {
        throw new Error('Image "src" missing');
    }
    if (getNativeObject(imageLike.src)) {
        if (getNativeObject(imageLike.src).isDisposed()) {
            throw new Error('ImageBitmap is closed');
        }
    }
    else if (typeof imageLike.src === 'string') {
        if (!imageLike.src.length) {
            throw new Error('Image "src" must not be empty');
        }
    }
    else if (getBytes(imageLike.src)) {
        if (!imageLike.src.size) {
            throw new Error('Image "src" must not be empty');
        }
    }
    else {
        throw new Error(`Image "src" ${toValueString(imageLike.src)} must be a string, ImageBitmap or Blob`);
    }
}
/**
 * @param {ImageLikeObject} imageLike
 */
function checkConsistentDimensions(imageLike) {
    if (hasInconsistentDimensions(imageLike)) {
        throw new Error('Image "scale" cannot be used with "width" and "height"');
    }
}
/**
 * @param {ImageLikeObject} imageLike
 */
function hasInconsistentDimensions(imageLike) {
    return hasExplicit(imageLike, 'scale') && (hasExplicit(imageLike, 'width') || hasExplicit(imageLike, 'height'));
}
/**
 * @param {Image} image
 * @param {keyof Image} property
 * @param {number|'auto'} value
 */
function setDimension(image, property, value) {
    if (value !== 'auto') {
        checkNumber(value, [0, Infinity], `Image "${property}" is not a dimension`);
    }
    Object.defineProperty(image, property, { enumerable: true, value });
}

class Percent {
    static isValidPercentValue(value) {
        try {
            Percent.from(value);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    static from(value) {
        if (value instanceof Percent) {
            return value;
        }
        if (value instanceof Object) {
            return percentLikeObjectToPercentInstance(value);
        }
        if (typeof value === 'string') {
            checkPercentString(value);
            return new Percent(percentNumberFromString(value));
        }
        throw new Error(`${toValueString(value)} is not a valid PercentValue`);
    }
    constructor(percent) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments');
        }
        checkNumber(percent, [-Infinity, Infinity], 'Invalid Percent');
        Object.defineProperty(this, 'percent', { enumerable: true, value: percent });
    }
    toString() {
        return `${this.percent}%`;
    }
    valueOf() {
        return this.percent;
    }
}
function percentLikeObjectToPercentInstance(value) {
    checkProperty$2(value, 'percent');
    return new Percent(value.percent);
}
function checkPercentString(value) {
    if (!/%$/.test(value) || isNaN(percentNumberFromString(value))) {
        throw new Error('Invalid percent string ' + value + ': It must be a number followed by "%".');
    }
    checkNumber(percentNumberFromString(value), [-Infinity, Infinity], `Invalid percent string ${value}`);
}
function percentNumberFromString(value) {
    return parseInt(value.replace(/%$/, ''));
}
function checkProperty$2(object, prop) {
    if (!(prop in object)) {
        throw new Error(`Percent-like object missing ${prop} value`);
    }
}

const SIDES = ['left', 'top', 'right', 'bottom'];
class LinearGradient {
    /**
     * @param {any} value
     * @returns {boolean}
     */
    static isLinearGradientValue(value) {
        return value == null || value === 'initial' || LinearGradient.isValidLinearGradientValue(value);
    }
    /**
     * @param {any} value
     * @returns {boolean}
     */
    static isValidLinearGradientValue(value) {
        try {
            LinearGradient.from(value);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    /**
     * @param {any} value
     * @returns {LinearGradient}
     */
    static from(value) {
        if (value instanceof LinearGradient) {
            return value;
        }
        if (value instanceof Object) {
            return gradientLikeObjectToGradientInstance(value);
        }
        if (typeof value === 'string') {
            return gradientLikeObjectToGradientInstance(gradientStringToObject(value));
        }
        throw new Error(`${toValueString(value)} is not a valid LinearGradient`);
    }
    /**
     * @param {Array<Color|[Color, Percent]>} colorStops
     * @param {number=} direction
     */
    constructor(colorStops, direction) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments');
        }
        let directionDegrees = 180;
        if (arguments.length > 1) {
            checkNumber(direction, [-Infinity, Infinity], 'Invalid direction angle');
            directionDegrees = direction;
        }
        checkColorStops(colorStops);
        Object.defineProperty(this, 'colorStops', { enumerable: true, value: Object.freeze(colorStops) });
        Object.defineProperty(this, 'direction', { enumerable: true, value: directionDegrees });
    }
    toString() {
        const directionPart = this.direction ? this.direction + 'deg, ' : '';
        const colorStopsPart = this.colorStops.join(', ');
        return `linear-gradient(${directionPart}${colorStopsPart})`;
    }
    equals(value) {
        if (!(value instanceof LinearGradient)) {
            return false;
        }
        return value.direction === this.direction
            && value.colorStops.length === this.colorStops.length
            && value.colorStops.every((stop, index) => equalColorStops(stop, this.colorStops[index]));
    }
}
Object.defineProperty(LinearGradient.prototype, 'direction', { value: 0 });
Object.defineProperty(LinearGradient.prototype, 'colorStops', { value: ( /** @type {Array<Color|[Color, Percent]>} */([])) });
function equalColorStops(a, b) {
    if (a instanceof Color && b instanceof Color) {
        return a.equals(b);
    }
    if (a instanceof Array && b instanceof Array) {
        return a[0].equals(b[0]) && a[1].percent === b[1].percent;
    }
    return false;
}
function gradientStringToObject(css) {
    let gradient = css.trim();
    const result = { colorStops: [] };
    if (gradient.indexOf('linear-gradient') !== 0) {
        throw new Error(`Argument ${toValueString(css)} is not a valid linear gradient definition`);
    }
    gradient = gradient.substring(15).trim();
    if (gradient.indexOf('(') !== 0 && gradient.lastIndexOf(')') !== gradient.length - 1) {
        throw new Error(`Argument ${toValueString(css)} is not a valid linear gradient definition`);
    }
    gradient = gradient.substring(1, gradient.length - 1).trim();
    gradient = encodeRGBColors(gradient);
    const gradientParts = gradient.split(',');
    // starting point
    let startingPoint = gradientParts[0].trim();
    let colorStopPartIndex = 1;
    if (startingPoint.indexOf('to') === 0) {
        startingPoint = startingPoint.substring(3).trim();
        checkSide(startingPoint);
        result.direction = directionToDegrees(startingPoint);
    }
    else if (startingPoint.indexOf('deg') === startingPoint.length - 3) {
        result.direction = parseInt(startingPoint.substring(0, startingPoint.length - 3), 10);
    }
    else {
        colorStopPartIndex = 0;
    }
    // color stop
    for (let i = colorStopPartIndex; i < gradientParts.length; i++) {
        const colorStopParts = gradientParts[i].trim().split(' ');
        if (colorStopParts.length === 1 && colorStopParts[0] !== '') {
            const color = decodeRGBColor(colorStopParts[0]);
            result.colorStops.push(color);
        }
        else if (colorStopParts.length === 2) {
            const color = decodeRGBColor(colorStopParts[0]);
            const offset = colorStopParts[1];
            result.colorStops.push([color, offset]);
        }
        else {
            throw new Error(`Invalid color stop value ${toValueString(colorStopParts)}`);
        }
    }
    return result;
}
function encodeRGBColors(gradient) {
    let result = '';
    let escaping = false;
    for (let i = 0; i < gradient.length; i++) {
        if (result.endsWith('rgb')) {
            escaping = true;
        }
        if (escaping && result.endsWith(')')) {
            escaping = false;
        }
        const currentChar = gradient.charAt(i);
        if (escaping) {
            if (currentChar === ',') {
                result += '&#44';
            }
            else if (currentChar !== ' ') {
                result += currentChar;
            }
        }
        else {
            result += currentChar;
        }
    }
    return result;
}
function decodeRGBColor(color) {
    return color.replace(/&#44/g, ',');
}
function gradientLikeObjectToGradientInstance(value) {
    checkProperty$3(value, 'colorStops');
    if ('direction' in value) {
        let { direction } = value;
        if (typeof direction === 'string') {
            checkSide(direction);
            direction = directionToDegrees(direction);
        }
        return new LinearGradient(value.colorStops.map(translateGradientLikeColorStop), direction);
    }
    return new LinearGradient(value.colorStops.map(translateGradientLikeColorStop));
}
function translateGradientLikeColorStop(stop) {
    if (Color.isValidColorValue(stop)) {
        return Color.from(stop);
    }
    if (stop instanceof Array) {
        if (stop.length !== 2) {
            throwInvalidGradientLikeColorStop(stop);
        }
        return [Color.from(stop[0]), Percent.from(stop[1])];
    }
    throwInvalidGradientLikeColorStop(stop);
}
function checkProperty$3(object, prop) {
    if (!(prop in object)) {
        throw new Error(`LinearGradient-like object missing ${prop} value`);
    }
}
function directionToDegrees(direction) {
    return { left: 270, top: 0, right: 90, bottom: 180 }[direction];
}
function checkColorStops(colorStops) {
    if (!(colorStops instanceof Array)) {
        throw new Error('colorStops must be an array');
    }
    if (colorStops.length <= 0) {
        throw new Error('colorStops must not be empty');
    }
    colorStops.forEach(checkColorStop);
}
function checkColorStop(colorStop) {
    if (!(colorStop instanceof Array) && !(colorStop instanceof Color)) {
        throwInvalidColorStop(colorStop);
    }
    if (colorStop instanceof Array) {
        if (colorStop.length !== 2 ||
            !(colorStop[0] instanceof Color) ||
            !(colorStop[1] instanceof Percent)) {
            throwInvalidColorStop(colorStop);
        }
    }
}
function throwInvalidColorStop(colorStop) {
    throw new Error(`${toValueString(colorStop)} is not a valid color stop. It must be either [Color, Percent] or Color.`);
}
function throwInvalidGradientLikeColorStop(colorStop) {
    throw new Error(`${toValueString(colorStop)} is not a valid color stop. It must be either [ColorValue, Percent] or ColorValue.`);
}
function checkSide(value) {
    if (value.indexOf(' ') > -1) {
        throw new Error(`Invalid direction "${value}". Corners are not supported.`);
    }
    if (!SIDES.includes(value)) {
        throw new Error(`Invalid direction side "${value}". Must be a side (e.g. "left") or a corner (e.g. "left top").`);
    }
}

const numberRegex = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
const transformDefaults = {
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    translationX: 0,
    translationY: 0,
    translationZ: 0
};
/**
 * @template T
 * @typedef {{
  *   convert?: (value: unknown, context?: NativeObject) => T,
  *   encode?: (value: T, context?: NativeObject) => any,
  *   decode?: (value: any, context?: NativeObject) => T
  * }} PropertyType
  */
/**
 * Note: Primitive types and aliases thereof start lower vase,
 * object types other upper case.
 */
class PropertyTypes {
    constructor() {
        const self = this;
        /** @type {PropertyType<any>} */
        this.any = {};
        /** @type {PropertyType<boolean>} */
        this.boolean = {
            convert: bool => !!bool,
            decode: value => value === undefined ? false : value
        };
        /** @type {PropertyType<string>} */
        this.string = {
            convert: str => str == null ? '' : '' + str,
            decode: value => value === undefined ? '' : value
        };
        /** @type {PropertyType<number>} */
        this.number = {
            convert: convertToNumber,
            decode: value => value === undefined ? 0 : value
        };
        /** @type {PropertyType<number>} */
        this.natural = {
            convert: value => Math.max(0, Math.round(convertToNumber(value))),
            decode: value => value === undefined ? 0 : value
        };
        /** @type {PropertyType<number>} */
        this.integer = {
            convert: value => Math.round(convertToNumber(value)),
            decode: value => value === undefined ? 0 : value
        };
        /** @type {PropertyType<number>} */
        this.fraction = {
            convert: value => Math.max(0, Math.min(1, convertToNumber(value)))
        };
        /** @type {PropertyType<number>} */
        this.dimension = {
            convert: value => Math.max(0, convertToNumber(value)),
            decode: value => value === undefined ? 0 : value
        };
        /** @type {PropertyType<LinearGradient|Color|Image|'initial'>} */
        this.Shader = {
            convert(value) {
                if (!value || value === 'initial') {
                    return 'initial';
                }
                if (isIntendedLinearGradientValue(value)) {
                    return LinearGradient.from(value);
                }
                else if (Color.isValidColorValue(value)) {
                    return Color.from(value);
                }
                else if (Image.isValidImageValue(value)) {
                    return Image.from.call(this, value);
                }
                throw new Error(`${toValueString(value)} must be a valid ImageValue, LinearGradientValue or ColorValue.`);
            },
            encode(value) {
                if (value === 'initial') {
                    return null;
                }
                if (value instanceof LinearGradient) {
                    const { colorStops, direction } = value;
                    return {
                        type: 'linearGradient',
                        colors: colorStops.map(stop => stop instanceof Color ? [stop.toArray(), null] :
                            [stop[0].toArray(), stop[1].valueOf() / 100]),
                        angle: direction
                    };
                }
                else if (value instanceof Color) {
                    return { type: 'color', color: value.toArray() };
                }
                else if (value instanceof Image) {
                    return { type: 'image', image: self.ImageValue.encode(value) };
                }
                throw new Error(`${toValueString(value)} must be a LinearGradient or Color instance.`);
            }
        };
        /** @type {PropertyType<Color|'initial'>} */
        this.ColorValue = {
            convert: value => !value || value === 'initial' ? 'initial' : Color.from(value),
            encode: value => value === 'initial' ? undefined : value.toArray(),
            decode: value => !value ? 'initial' : Color.from(value)
        };
        /** @type {PropertyType<Font|'initial'>} */
        this.FontValue = {
            convert: value => (!value || value === 'initial') ? 'initial' : Font.from(value),
            encode: value => value === 'initial' ? undefined : value
        };
        /** @type {PropertyType<Image|null>} */
        this.ImageValue = {
            convert: value => (!value || value === 'initial') ? null : Image.from(value),
            encode(value) {
                if (!value) {
                    return null;
                }
                const image = Image.from.call(this, value);
                const width = image.width === 'auto' ? null : image.width;
                const height = image.height === 'auto' ? null : image.height;
                const scale = image.scale === 'auto' ? null : image.scale;
                const src = image.src;
                if (typeof src === 'string') {
                    return {
                        type: 'uri',
                        src, width, height, scale
                    };
                }
                if (getBytes(src)) {
                    return {
                        type: 'encodedImage',
                        src: getBytes(src),
                        width, height, scale
                    };
                }
                return {
                    type: 'imageBitmap',
                    src: getNativeObject(src).cid,
                    width, height, scale
                };
            }
        };
        /** @type {PropertyType<Partial<BoxDimensionsObject>|'initial'>} */
        this.BoxDimensions = {
            convert(value) {
                try {
                    if (!value) {
                        return Object.freeze({ left: 0, right: 0, top: 0, bottom: 0 });
                    }
                    if (typeof value === 'number') {
                        const normal = self.dimension.convert(value);
                        return { left: normal, right: normal, top: normal, bottom: normal };
                    }
                    if (value instanceof Array || typeof value === 'string') {
                        const arr = (typeof value === 'string' ? value.trim().split(/\s+/) : value).map(convertToNumber);
                        if (arr.length === 0 || arr.length > 4) {
                            throw new Error('Array must have between 1 and 4 entries');
                        }
                        return Object.freeze({
                            top: arr[0],
                            right: arr.length > 1 ? arr[1] : arr[0],
                            bottom: arr.length > 2 ? arr[2] : arr[0],
                            left: arr.length > 3 ? arr[3] : arr.length > 1 ? arr[1] : arr[0]
                        });
                    }
                    if (typeof value === 'object') {
                        const partial = allowOnlyKeys(value, ['left', 'top', 'right', 'bottom']);
                        return Object.freeze({
                            left: 'left' in partial ? convertToNumber(partial.left) : 0,
                            top: 'top' in partial ? convertToNumber(partial.top) : 0,
                            right: 'right' in partial ? convertToNumber(partial.right) : 0,
                            bottom: 'bottom' in partial ? convertToNumber(partial.bottom) : 0
                        });
                    }
                    throw new Error('Expected number, string or object');
                }
                catch (ex) {
                    throw new Error(`${toValueString(value)} is not a valid BoxDimensions value: ${ex.message}`);
                }
            }
        };
        /** @type {PropertyType<{left: number, top: number, width: number, height: number}>} */
        this.Bounds = {
            decode: /** @param {any} value*/ /** @param {any} value*/ value => value === undefined
                ? { left: 0, top: 0, width: 0, height: 0 }
                : { left: value[0], top: value[1], width: value[2], height: value[3] }
        };
        /** @type {PropertyType<NativeObject|WidgetCollection>} */
        this.Widget = {
            convert(value) {
                if (!value) {
                    return null;
                }
                if (value instanceof WidgetCollection) {
                    return value.first() || null;
                }
                // Can't import Widget due to circular dependency, check animate method instead
                if (value instanceof NativeObject && Object.getPrototypeOf(value).animate instanceof Function) {
                    return value;
                }
                throw new Error('Not a valid widget: ' + toValueString(value));
            },
            encode: value => value instanceof NativeObject ? value.cid : null,
            decode: value => tabris._nativeObjectRegistry.find(value)
        };
        /** @type {PropertyType<Partial<typeof transformDefaults>>} */
        this.Transformation = {
            convert(value) {
                const partial = allowOnlyKeys(value, Object.keys(transformDefaults));
                return Object.freeze({
                    rotation: 'rotation' in partial ? convertToNumber(partial.rotation) : 0,
                    scaleX: 'scaleX' in partial ? convertToNumber(partial.scaleX) : 1,
                    scaleY: 'scaleY' in partial ? convertToNumber(partial.scaleY) : 1,
                    translationX: 'translationX' in partial ? convertToNumber(partial.translationX) : 0,
                    translationY: 'translationY' in partial ? convertToNumber(partial.translationY) : 0,
                    translationZ: 'translationZ' in partial ? convertToNumber(partial.translationZ) : 0
                });
            }
        };
        /** @type {PropertyType<Date>} */
        this.Date = {
            convert(value) {
                if (!(value instanceof Date)) {
                    throw new Error(`${toValueString(value)} is not of type Date`);
                }
                return value;
            },
            encode(value) {
                return value.getTime();
            }
        };
        /**
         * @param {any} value
         */
        function convertToNumber(value) {
            if (value === false || value == null || value === '') {
                return 0;
            }
            if (typeof value === 'string') {
                const fixedString = value.trim().replace('px', '');
                if (numberRegex.test(fixedString)) {
                    return parseFloat(fixedString);
                }
            }
            if (typeof value !== 'number') {
                throw new Error(`${toValueString(value)} is not a number`);
            }
            if (!isFinite(value)) {
                throw new Error(`${toValueString(value)} is not a valid number`);
            }
            return value;
        }
        /**
         * @param {any} value
         */
        function isIntendedLinearGradientValue(value) {
            if (value instanceof LinearGradient) {
                return true;
            }
            if (value instanceof Object) {
                return 'colorStops' in value;
            }
            if (typeof value === 'string') {
                return /^linear-gradient/.test(value);
            }
        }
    }
}
const types = Object.freeze(new PropertyTypes());

class ChangeListeners extends Listeners {
    constructor(target, property) {
        propertyCheck(target, property);
        super(target, property + 'Changed');
        this.$current = () => target[property];
        Object.defineProperty(this, 'values', {
            get: () => Reflect.get(ChangeListeners.prototype, 'values', this)
        });
    }
    trigger(eventData) {
        if (!eventData || !('value' in eventData)) {
            throw new Error('Can not trigger change event without "value" property in event data');
        }
        return super.trigger(eventData);
    }
    get values() {
        if (!this.$values) {
            this.$values = new Observable(observer => {
                observer.next(this.$current());
                const subscription = this.subscribe({
                    next: event => observer.next(event.value),
                    error: observer.error,
                    complete: observer.complete
                });
                return () => subscription.unsubscribe();
            });
        }
        return this.$values;
    }
}
function propertyCheck(target, property) {
    if (!(property in target)) {
        throw new Error(`Target has no property "${property}"`);
    }
}

class NativeObject extends EventsClass {
    constructor(param) {
        super();
        this.cid = '';
        // TODO: Use decorators to make non-enumerable properties
        Object.defineProperty(this, '$props', {
            enumerable: false,
            writable: true,
            value: {}
        });
        this._nativeCreate(param);
    }
    static defineProperties(target, definitions) {
        for (const name in definitions) {
            NativeObject.defineProperty(target, name, definitions[name]);
        }
    }
    static defineProperty(target, name, property) {
        const def = normalizeProperty(property);
        Object.defineProperty(target, '$prop_' + name, {
            enumerable: false,
            writable: false,
            value: def
        });
        Object.defineProperty(target, name, {
            set(value) {
                this.$setProperty(name, value);
            },
            get() {
                return this.$getProperty(name);
            }
        });
        if (!def.const) {
            this.defineChangeEvent(target, name);
        }
    }
    static defineEvents(target, definitions) {
        for (const name in definitions) {
            NativeObject.defineEvent(target, name, definitions[name]);
        }
    }
    static defineEvent(target, name, definition) {
        const property = 'on' + name.charAt(0).toUpperCase() + name.slice(1);
        const $property = '$' + property;
        const $eventProperty = '$event_' + name;
        if (target[$eventProperty]) {
            throw new Error('Event already defined');
        }
        const def = target[$eventProperty] = normalizeEvent.call(this.prototype, name, definition);
        if (def.changes) {
            this.synthesizeChangeEvents(target, name, def);
        }
        Object.defineProperty(target, property, {
            get() {
                if (!this[$property]) {
                    this[$property] = new Listeners(this, name);
                }
                return this[$property];
            }
        });
    }
    static defineChangeEvents(target, properties) {
        properties.forEach(property => this.defineChangeEvent(target, property));
    }
    static defineChangeEvent(target, property) {
        const listenersProperty = 'on' + property.charAt(0).toUpperCase() + property.slice(1) + 'Changed';
        const $listenersProperty = '$' + property + 'Changed';
        Object.defineProperty(target, listenersProperty, {
            get() {
                if (!this[$listenersProperty]) {
                    this[$listenersProperty] = new ChangeListeners(this, property);
                }
                return this[$listenersProperty];
            }
        });
    }
    static synthesizeChangeEvents(target, sourceEvent, sourceDef) {
        var _a;
        const name = sourceDef.changes + 'Changed';
        const changeListener = function (ev) {
            const changeValue = sourceDef.changeValue;
            this.$trigger(name, { value: changeValue(ev) });
        };
        const $changeEventProperty = '$event_' + name;
        const changeEventDef = target[$changeEventProperty]
            = target[$changeEventProperty] || { listen: [] };
        (_a = changeEventDef.listen) === null || _a === void 0 ? void 0 : _a.push((instance, listening) => {
            instance._onoff(sourceEvent, listening, changeListener);
        });
        if (sourceDef.nativeObservable !== false) {
            target[nativeObservables] = (target[nativeObservables] || []).concat();
            target[nativeObservables].push(name);
        }
    }
    static extend(nativeType, superType = NativeObject) {
        return class extends superType {
            get _nativeType() { return nativeType; }
        };
    }
    set(properties) {
        if (arguments.length === 0) {
            throw new Error('Not enough arguments');
        }
        if (arguments.length > 1) {
            throw new Error('Too many arguments');
        }
        this._reorderProperties(Object.keys(properties || {}))
            .forEach(name => setExistingProperty.call(this, name, properties[name]));
        return this;
    }
    dispose() {
        this._dispose();
    }
    isDisposed() {
        return !!this._isDisposed;
    }
    toString() {
        return this.constructor.name;
    }
    // TODO: make unique symbol
    [(toXML$1)]() {
        if (this._isDisposed) {
            return `<${this._getXMLElementName()} cid='${this.cid}' disposed='true'/>`;
        }
        const content = this._getXMLContent();
        if (!content.length) {
            return this._getXMLHeader(false);
        }
        return `${this._getXMLHeader(true)}\n${content.join('\n')}\n${this._getXMLFooter(true)}`;
    }
    $getProperty(name) {
        var _a, _b;
        if (this._isDisposed) {
            hint(this, 'Cannot get property "' + name + '" on disposed object');
            return;
        }
        const def = this._getPropertyDefinition(name);
        if (def.nocache) {
            const nativeValue = this._nativeGet(name);
            return ((_a = def.type) === null || _a === void 0 ? void 0 : _a.decode) ? def.type.decode.call(null, nativeValue, this) : nativeValue;
        }
        const storedValue = this._getStoredProperty(name);
        if (storedValue !== undefined) {
            return storedValue;
        }
        if (def.default !== undefined) {
            return def.default;
        }
        const value = this._nativeGet(name);
        const decodedValue = ((_b = def.type) === null || _b === void 0 ? void 0 : _b.decode) ? def.type.decode.call(this, value, this) : value;
        this._storeProperty(name, decodedValue);
        return decodedValue;
    }
    $setProperty(name, value) {
        var _a, _b;
        if (this._isDisposed) {
            hint(this, 'Cannot set property "' + name + '" on disposed object');
            return;
        }
        const def = this._getPropertyDefinition(name);
        if (def.readonly) {
            hint(this, `Can not set read-only property "${name}"`);
            return;
        }
        else if (def.const && this._wasSet(name)) {
            hint(this, `Can not set const property "${name}"`);
            return;
        }
        let convertedValue;
        try {
            convertedValue = this._convertValue(def, value, value);
        }
        catch (ex) {
            this._printPropertyWarning(name, ex);
            return;
        }
        const encodedValue = (_b = (_a = def.type) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.call(null, convertedValue, this);
        if (def.nocache) {
            this._beforePropertyChange(name, convertedValue);
            this._nativeSet(name, encodedValue);
            if (!def.const) {
                this._triggerChangeEvent(name, convertedValue);
            }
        }
        else if (!equals$1(this._getStoredProperty(name), convertedValue) || !this._wasSet(name)) {
            this._beforePropertyChange(name, convertedValue);
            this._nativeSet(name, encodedValue); // TODO should not happen if changing from unset to default
            this._storeProperty(name, convertedValue, def.const);
        }
    }
    _convertValue(def, value, convertedValue) {
        var _a, _b;
        if (!def.nullable || value !== null) {
            // TODO: ensure convert has no write-access to the NativeObject instance via proxy
            convertedValue = allowOnlyValues((_b = (_a = def.type) === null || _a === void 0 ? void 0 : _a.convert) === null || _b === void 0 ? void 0 : _b.call(null, value, this), def.choice);
        }
        return convertedValue;
    }
    _printPropertyWarning(name, ex) {
        hint(this, 'Ignored unsupported value for property "' + name + '": ' + ex.message);
    }
    _storeProperty(name, newValue, noChangeEvent = false) {
        if (newValue === this._getStoredProperty(name) && this._wasSet(name)) {
            return false;
        }
        if (newValue === undefined) {
            return false;
        }
        else {
            this.$props[name] = newValue;
        }
        if (!noChangeEvent) {
            this._triggerChangeEvent(name, newValue);
        }
        return true;
    }
    _getStoredProperty(name) {
        let result = (this.$props ? this.$props[name] : undefined);
        if (result === undefined) {
            result = this._getPropertyDefinition(name).default;
        }
        return result;
    }
    _wasSet(name) {
        return name in (this.$props || {});
    }
    _getPropertyDefinition(propertyName) {
        const defKey = '$prop_' + propertyName;
        return this[defKey] || {};
    }
    _decodeProperty(typeDef, value) {
        return (typeDef && typeDef.decode) ? typeDef.decode.call(null, value, this) : value;
    }
    _triggerChangeEvent(propertyName, value) {
        this.$trigger(propertyName + 'Changed', { value });
    }
    get _nativeType() {
        throw new Error('Can not create instance of abstract class ' + this.constructor.name);
    }
    _nativeCreate(param) {
        this._register();
        tabris._nativeBridge.create(this.cid, this._nativeType);
        if (param instanceof Object) {
            this.set(param);
        }
    }
    _register() {
        if (typeof tabris === 'undefined' || !tabris._nativeBridge) {
            throw new Error('tabris.js not started');
        }
        const cid = tabris._nativeObjectRegistry.register(this);
        Object.defineProperty(this, 'cid', { value: cid });
    }
    _reorderProperties(properties) {
        return properties;
    }
    _dispose(skipNative) {
        if (!this._isDisposed && !this._inDispose) {
            Object.defineProperties(this, {
                _inDispose: { enumerable: false, writable: false, value: true },
                _disposedToStringValue: { enumerable: false, writable: false, value: this.toString() }
            });
            this.toString = () => this._disposedToStringValue + ' (disposed)';
            this._trigger('dispose');
            this._release();
            if (!skipNative) {
                tabris._nativeBridge.destroy(this.cid);
            }
            tabris._nativeObjectRegistry.remove(this.cid);
            this.$props = null;
            Object.defineProperty(this, '_isDisposed', { enumerable: false, writable: false, value: true });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _release() { }
    /**
     * Called when a property is about to be changed, past conversion and all
     * other pre-checks. May have side-effects. Exceptions will not be catched.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
    _beforePropertyChange(name, value) { }
    _listen(name, listening) {
        var _a;
        const defKey = '$event_' + name;
        const eventDef = this[defKey];
        if (eventDef) {
            (_a = eventDef.listen) === null || _a === void 0 ? void 0 : _a.forEach(listen => listen(this, listening));
        }
    }
    _nativeListen(event, state) {
        this._checkDisposed();
        tabris._nativeBridge.listen(this.cid, event, state);
    }
    _trigger(name, eventData = {}) {
        return this.$trigger(name, eventData);
    }
    $trigger(name, eventData = {}) {
        const event = new EventObject();
        for (const key in eventData) {
            if (!(key in event)) {
                Object.defineProperty(event, key, { enumerable: true, value: eventData[key] });
            }
        }
        this.trigger(name, event);
        return !!event.defaultPrevented;
    }
    _onoff(name, listening, listener) {
        if (listening) {
            this.on(name, listener);
        }
        else {
            this.off(name, listener);
        }
    }
    _checkDisposed() {
        if (this._isDisposed) {
            throw new Error('Object is disposed');
        }
    }
    _nativeSet(name, value) {
        this._checkDisposed();
        tabris._nativeBridge.set(this.cid, name, value === undefined ? null : value);
    }
    _nativeGet(name) {
        this._checkDisposed();
        return tabris._nativeBridge.get(this.cid, name);
    }
    _nativeCall(method, parameters) {
        this._checkDisposed();
        return tabris._nativeBridge.call(this.cid, method, parameters);
    }
    _getXMLHeader(hasChild) {
        const attributes = this._getXMLAttributes()
            .map(entry => `${entry[0]}='${('' + entry[1]).replace(/'/g, '\\\'').replace(/\n/g, '\\n')}'`)
            .join(' ');
        return `<${this._getXMLElementName()} ${attributes}${!hasChild ? '/' : ''}>`;
    }
    _getXMLFooter(hasChild) {
        return hasChild ? `</${this._getXMLElementName()}>` : '';
    }
    _getXMLElementName() {
        return this.constructor.name;
    }
    _getXMLAttributes() {
        return [['cid', this.cid]];
    }
    _getXMLContent() {
        return [];
    }
}
NativeObject.defineEvents(NativeObject.prototype, {
    dispose: true
});
function setExistingProperty(name, value) {
    if (!(name in this)) {
        hint(this, 'There is no setter for property "' + name + '"');
    }
    this[name] = value;
}
function normalizeProperty(config) {
    const def = {
        type: normalizeType(config.type || {}),
        default: config.default,
        nullable: !!config.nullable,
        const: !!config.const,
        nocache: !!config.nocache,
        readonly: !!config.readonly,
        choice: config.choice
    };
    if (def.readonly && (def.default !== undefined)) {
        throw new Error('Can not combine "nocache" with "readonly"');
    }
    if (def.readonly && def.nullable) {
        throw new Error('Can not combine "nullable" with "readonly"');
    }
    if (def.readonly && def.choice) {
        throw new Error('Can not combine "choice" with "readonly"');
    }
    if (def.choice && def.choice.length < 2) {
        throw new Error('"choice" needs at least two entries');
    }
    if ((def.default === undefined) && !def.nocache && !def.readonly) {
        throw new Error('"default" must be given unless "nocache" or "readonly" is true.');
    }
    allowOnlyKeys(config, Object.keys(def));
    return def;
}
function normalizeEvent(name, definition) {
    var _a;
    const result = { listen: [] };
    if (definition === true) {
        return result;
    }
    Object.assign(result, definition);
    if (definition.native) {
        (_a = result.listen) === null || _a === void 0 ? void 0 : _a.push((target, listening) => {
            target._nativeListen(name, listening);
        });
    }
    const changes = result.changes;
    if (changes) {
        const changeValue = result.changeValue;
        if (typeof changeValue === 'string') {
            result.changeValue = (ev) => ev[changeValue];
        }
        else if (!changeValue) {
            result.changeValue = (ev) => ev[changes];
        }
    }
    return result;
}
function normalizeType(config) {
    if (config instanceof Function) {
        if (!(config.prototype instanceof NativeObject)) {
            throw new Error('not a constructor of NativeObject');
        }
        return {
            convert(value) {
                if (!(value instanceof config)) {
                    throw new Error('Not an instance of ' + config.name);
                }
                return value;
            },
            encode(value) {
                return value ? value.cid : null;
            },
            decode(value) {
                return value ? tabris._nativeObjectRegistry.find(value) : null;
            }
        };
    }
    const def = typeof config === 'string' ? types[config] : config;
    allowOnlyKeys(def, ['convert', 'encode', 'decode']);
    return {
        convert: def.convert || (v => v),
        encode: def.encode || (v => v),
        decode: def.decode || (v => v)
    };
}

class NativeBridge {
    constructor(bridge) {
        Object.defineProperties(this, {
            $bridge: { enumerable: false, writable: false, value: bridge },
            $operations: { enumerable: false, writable: true, value: [] },
            $currentOperation: { enumerable: false, writable: true, value: { id: null } },
            $propertyCache: { enumerable: false, writable: true, value: {} }
        });
    }
    create(id, type) {
        const properties = {};
        this.$operations.push(['create', id, type, properties]);
        this.$currentOperation = { id, properties };
    }
    set(id, name, value) {
        if (this.$currentOperation.id === id) {
            this.$currentOperation.properties[name] = value;
        }
        else {
            const properties = {};
            properties[name] = value;
            this.$operations.push(['set', id, properties]);
            this.$currentOperation = { id, properties };
        }
        this.cacheValue(id, name, value);
    }
    listen(id, event, listen) {
        this.$operations.push(['listen', id, event, listen]);
        this.$currentOperation = { id: null };
    }
    destroy(id) {
        this.$operations.push(['destroy', id]);
        this.$currentOperation = { id: null };
    }
    get(id, name) {
        if (this.$propertyCache[id] && name in this.$propertyCache[id]) {
            return this.$propertyCache[id][name];
        }
        this.flush();
        const result = this.$bridge.get(id, name);
        this.cacheValue(id, name, result);
        return result;
    }
    call(id, method, parameters) {
        this.flush();
        return this.$bridge.call(id, method, parameters);
    }
    flush() {
        tabris.trigger('layout');
        const operations = this.$operations;
        this.$operations = [];
        this.$currentOperation = { id: null };
        const length = operations.length;
        // Using apply() on the native bridge does not work with Rhino. It seems that the parameter
        // count must be known in order to find the associated native method.
        for (let i = 0; i < length; i++) {
            const op = operations[i];
            switch (op[0]) {
                case 'create':
                    this.$bridge.create(op[1], op[2], op[3]);
                    break;
                case 'set':
                    this.$bridge.set(op[1], op[2]);
                    break;
                case 'listen':
                    this.$bridge.listen(op[1], op[2], op[3]);
                    break;
                case 'destroy':
                    this.$bridge.destroy(op[1]);
            }
        }
    }
    clearCache() {
        this.$propertyCache = {};
    }
    cacheValue(id, property, value) {
        if (!this.$propertyCache[id]) {
            this.$propertyCache[id] = {};
        }
        this.$propertyCache[id][property] = value;
    }
}

class NativeObjectRegistry {
    constructor() {
        Object.defineProperties(this, {
            $idSequence: { enumerable: false, writable: true, value: 1 },
            $objects: { enumerable: false, writable: false, value: {} }
        });
    }
    register(nativeObject) {
        const cid = this.$generateId();
        if (cid in this.$objects) {
            throw new Error('cid already in use: ' + cid);
        }
        this.$objects[cid] = nativeObject;
        return cid;
    }
    remove(cid) {
        delete this.$objects[cid];
    }
    find(cid) {
        return this.$objects[cid] || null;
    }
    $generateId() {
        return '$' + (this.$idSequence++);
    }
}

class Tabris extends NativeObject {
    constructor() {
        super();
        Object.defineProperties(this, {
            _started: { enumerable: false, writable: true, value: false },
            _init: { enumerable: false, writable: true, value: this._init.bind(this) },
            _notify: { enumerable: false, writable: true, value: this._notify.bind(this) },
            _stackTraceStack: { enumerable: false, writable: true, value: [] },
            _nativeObjectRegistry: { enumerable: false, writable: true, value: null },
            _client: { enumerable: false, writable: true, value: null },
            _nativeBridge: { enumerable: false, writable: true, value: null },
            _entryPoint: { enumerable: false, writable: true, value: null }
        });
        this.$publishProxies();
    }
    get version() {
        return '3.7.1';
    }
    get started() {
        return !!this._started;
    }
    flush() {
        this.trigger('tick');
        this.trigger('flush');
        this._nativeBridge.clearCache();
        this._nativeBridge.flush();
    }
    get _nativeType() {
        return 'tabris.Tabris';
    }
    /** @override */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _nativeCreate() { }
    _register() {
        this._nativeObjectRegistry = new NativeObjectRegistry();
        const cid = this._nativeObjectRegistry.register(this);
        Object.defineProperty(this, 'cid', { value: cid });
    }
    _init(client, options) {
        this._client = client;
        this._nativeBridge = new NativeBridge(client);
        this._register();
        this._nativeBridge.create(this.cid, this._nativeType);
        this.trigger('start', options || { headless: false });
        this._started = true;
    }
    _setEntryPoint(entryPoint) {
        this._entryPoint = entryPoint;
    }
    _notify(cid, event, param) {
        let returnValue;
        try {
            const nativeObject = this._nativeObjectRegistry.find(cid);
            if (nativeObject) {
                try {
                    const eventDef = nativeObject['$event_' + event];
                    if (eventDef && eventDef.changes) {
                        this._nativeBridge.cacheValue(cid, eventDef.changes, eventDef.changeValue(param));
                    }
                    returnValue = nativeObject._trigger(event, param);
                }
                catch (err) {
                    error(err);
                }
            }
            this.flush();
        }
        catch (err) {
            error(err);
        }
        return returnValue;
    }
    $publishProxies() {
        [
            'contentView', 'drawer', 'navigationBar', 'statusBar', 'permission', 'printer', 'device', 'app', 'localStorage',
            'secureStorage', 'crypto', 'fs', 'pkcs5', 'sizeMeasurement', 'devTools', 'process', 'authentication'
        ].forEach(name => {
            const value = proxify(() => this['$' + name]);
            Object.defineProperty(this, name, { value });
        });
    }
}
NativeObject.defineEvents(Tabris.prototype, {
    start: {},
    flush: {},
    layout: {},
    log: {}
});

const SUPPORTED_ENCODINGS = ['ascii', 'utf-8'];
class TextEncoder extends NativeObject {
    encode(text, encoding) {
        this._nativeListen('result', true);
        this._nativeListen('error', true);
        this._nativeCall('encode', { text, encoding });
    }
    encodeSync(text, encoding) {
        return this._nativeCall('encodeSync', { text, encoding });
    }
    get _nativeType() {
        return 'tabris.TextEncoder';
    }
    /**
     * @return {TextEncoder}
     */
    static getInstance() {
        if (!this._instance) {
            Object.defineProperty(this, '_instance', {
                enumerable: false,
                writable: false,
                value: new TextEncoder()
            });
        }
        return this._instance;
    }
    static encode(text, encoding) {
        return new Promise$1((resolve, reject) => {
            encoding = encoding || 'utf-8';
            paramCheck(text, encoding);
            new TextEncoder()
                .on('result', ({ target, data }) => {
                resolve(data);
                target.dispose();
            })
                .on('error', ({ target }) => {
                reject(new Error('Could not encode ' + encoding));
                target.dispose();
            })
                .encode(text, encoding);
        });
    }
    static encodeSync(text, encoding) {
        encoding = encoding || 'utf-8';
        paramCheck(text, encoding);
        return TextEncoder.getInstance().encodeSync(text, encoding);
    }
}
TextEncoder._instance = null;
function paramCheck(text, encoding) {
    if (typeof text !== 'string') {
        throw new Error('Invalid text, must be a string');
    }
    if (!SUPPORTED_ENCODINGS.includes(encoding)) {
        throw new Error(`Unsupported encoding: ${toValueString(encoding)}`);
    }
}

const SUPPORTED_ENCODINGS$1 = ['ascii', 'utf-8'];
class TextDecoder extends NativeObject {
    constructor() {
        super();
        this._nativeListen('result', true);
        this._nativeListen('error', true);
    }
    decode(buffer, encoding) {
        this._nativeCall('decode', { data: buffer, encoding });
    }
    static decode(buffer, encoding) {
        return new Promise$1((resolve, reject) => {
            if (ArrayBuffer.isView(buffer)) {
                buffer = buffer.buffer;
            }
            if (!(buffer instanceof ArrayBuffer)) {
                throw new Error('Invalid buffer type');
            }
            encoding = encoding || 'utf-8';
            if (!SUPPORTED_ENCODINGS$1.includes(encoding)) {
                throw new Error(`Unsupported encoding: ${toValueString(encoding)}`);
            }
            new TextDecoder()
                .on('result', ({ target, string }) => {
                resolve(string);
                target.dispose();
            })
                .on('error', ({ target }) => {
                reject(new Error('Could not decode ' + encoding));
                target.dispose();
            })
                .decode(buffer, encoding);
        });
    }
    get _nativeType() {
        return 'tabris.TextDecoder';
    }
}

class Blob {
    /**
     * @param {Array=} blobParts
     * @param {Object=} options
     */
    constructor(blobParts = [], options = {}) {
        if (Object.getPrototypeOf(blobParts) !== Array.prototype) {
            throw new TypeError('Argument 1 of Blob.constructor can\'t be converted to a sequence.');
        }
        if (Object.getPrototypeOf(options) !== Object.prototype) {
            throw new TypeError('Argument 2 of Blob.constructor can\'t be converted to a dictionary.');
        }
        setBytes(this, join(blobParts));
        Object.defineProperty(this, 'type', { value: 'type' in options ? options.type + '' : '' });
    }
    get size() {
        return getBytes(this).byteLength;
    }
    arrayBuffer() {
        return Promise$1.resolve(getBytes(this).slice(0));
    }
    text() {
        return TextDecoder.decode(getBytes(this));
    }
}
Object.defineProperty(Blob.prototype, 'type', { value: '' });
/** @param {Array} parts*/
function join(parts) {
    let size = 0;
    /** @type {Uint8Array[]} */
    const chunks = [];
    for (let i = 0; i < parts.length; i++) {
        chunks[i] = partToChunk(parts[i]);
        size += chunks[i].byteLength;
    }
    const result = new Uint8Array(size);
    let offset = 0;
    for (let i = 0; i < chunks.length; i++) {
        result.set(chunks[i], offset);
        offset += chunks[i].byteLength;
    }
    return result.buffer;
}
/**
 * @param {any} part
 * @return {Uint8Array}
*/
function partToChunk(part) {
    if (part instanceof ArrayBuffer) {
        return new Uint8Array(part);
    }
    if (ArrayBuffer.isView(part)) {
        return new Uint8Array(part.buffer);
    }
    if (part instanceof Blob) {
        return new Uint8Array(getBytes(part));
    }
    return new Uint8Array(TextEncoder.encodeSync(part + ''));
}
Blob.prototype[Symbol.toStringTag] = 'Blob';

class Camera extends NativeObject {
    constructor(properties) {
        if (!properties || !properties.cameraId) {
            throw new Error('Camera requires cameraId');
        }
        super(properties);
    }
    get _nativeType() {
        return 'tabris.Camera';
    }
    captureImage(options = {}) {
        return new Promise$1((resolve, reject) => {
            if (!this.active) {
                reject(new Error('Camera has to be active to capture an image'));
            }
            else {
                this._nativeCall('captureImage', {
                    options,
                    onResult: (result) => {
                        const blob = new Blob([], { type: 'image/jpg' });
                        setBytes(blob, result.image);
                        return resolve({
                            image: blob,
                            width: result.width,
                            height: result.height
                        });
                    },
                    onError: (error) => reject(new Error(error))
                });
            }
        });
    }
}
NativeObject.defineProperties(Camera.prototype, {
    cameraId: { type: types.string, const: true, default: '' },
    active: { type: types.boolean, default: false },
    captureResolution: {
        type: {
            convert(value) {
                return Object.freeze(allowOnlyKeys(( /** @type {{width: number, height: number}} */(value)), ['width', 'height']));
            }
        },
        default: null,
        nullable: true
    },
    position: { type: types.string, const: true, readonly: true },
    availableCaptureResolutions: {
        type: {
            decode(value) {
                return value.sort((a, b) => a.width * a.height - b.width * b.height);
            }
        },
        const: true,
        readonly: true
    }
});

class Device extends NativeObject {
    get _nativeType() {
        return 'tabris.Device';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('Device can not be created');
        }
        super._nativeCreate();
    }
    _listen(name, listening) {
        if (name === 'orientationChanged') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _trigger(name, event) {
        if (name === 'orientationChanged') {
            this._triggerChangeEvent('orientation', event.orientation);
        }
        else {
            super._trigger(name, event);
        }
    }
    dispose() {
        throw new Error('Cannot dispose device object');
    }
}
NativeObject.defineProperties(Device.prototype, {
    model: { readonly: true, const: true },
    vendor: { readonly: true, const: true },
    platform: { readonly: true, const: true },
    version: { readonly: true, const: true },
    name: { readonly: true, const: true },
    language: { readonly: true, const: true },
    orientation: { readonly: true, nocache: true },
    screenWidth: { readonly: true, const: true },
    screenHeight: { readonly: true, const: true },
    scaleFactor: { readonly: true, const: true },
    cameras: {
        type: {
            decode(value) {
                return Object.freeze(value.map((cameraId) => new Camera({ cameraId })));
            }
        },
        readonly: true,
        const: true
    }
});
function create() {
    return new Device(true);
}
function publishDeviceProperties(device, target) {
    target.devicePixelRatio = device.scaleFactor;
    target.device = createDevice(device);
    target.screen = createScreen(device);
    target.navigator = createNavigator(device);
}
function createDevice(device) {
    const dev = {};
    ['model', 'vendor', 'platform', 'version', 'name'].forEach((name) => {
        defineReadOnlyProperty(dev, name, () => device[name]);
    });
    return dev;
}
function createScreen(device) {
    const screen = {};
    defineReadOnlyProperty(screen, 'width', () => device.screenWidth);
    defineReadOnlyProperty(screen, 'height', () => device.screenHeight);
    return screen;
}
function createNavigator(device) {
    const navigator = {};
    defineReadOnlyProperty(navigator, 'userAgent', () => 'tabris-js');
    defineReadOnlyProperty(navigator, 'language', () => device.language);
    return navigator;
}
function defineReadOnlyProperty(target, name, getter) {
    Object.defineProperty(target, name, {
        get: getter,
        set() { }
    });
}

class ImageData {
    constructor() {
        if (arguments.length < 2) {
            throw new TypeError('Not enough arguments to ImageData');
        }
        let array, width, height;
        if (arguments[0] instanceof Uint8ClampedArray) {
            array = checkArray(arguments[0]);
            width = checkSize(arguments[1]);
            height = arguments.length > 2 ? checkSize(arguments[2]) : array.byteLength / 4 / width;
            if (array.byteLength !== width * height * 4) {
                throw new Error('Wrong array size');
            }
        }
        else {
            width = checkSize(arguments[0]);
            height = checkSize(arguments[1]);
            array = new Uint8ClampedArray(width * height * 4);
        }
        Object.defineProperties(this, {
            data: { value: array },
            width: { value: width },
            height: { value: height }
        });
    }
}
Object.defineProperty(ImageData.prototype, 'data', { value: /** @type {Uint8ClampedArray} */ (null) });
Object.defineProperty(ImageData.prototype, 'width', { value: 0 });
Object.defineProperty(ImageData.prototype, 'height', { value: 0 });
function checkArray(array) {
    if (array.byteLength % 4 !== 0) {
        throw new Error('Illegal array length');
    }
    return array;
}
function checkSize(input) {
    const size = Math.floor(input);
    if (size <= 0 || !isFinite(size)) {
        throw new Error('Illegal size for ImageData');
    }
    return size;
}

const OPCODES = {
    arc: 1,
    arcTo: 2,
    beginPath: 3,
    bezierCurveTo: 4,
    clearRect: 5,
    closePath: 6,
    fill: 7,
    fillRect: 8,
    fillStyle: 9,
    fillText: 10,
    lineCap: 11,
    lineJoin: 12,
    lineTo: 13,
    lineWidth: 14,
    moveTo: 15,
    quadraticCurveTo: 16,
    rect: 17,
    restore: 18,
    rotate: 19,
    save: 20,
    scale: 21,
    setTransform: 22,
    stroke: 23,
    strokeRect: 24,
    strokeStyle: 25,
    strokeText: 26,
    textAlign: 27,
    textBaseline: 28,
    transform: 29,
    translate: 30,
    font: 31,
    drawImage: 32
};
class GC extends NativeObject {
    constructor(properties) {
        super(properties);
        Object.defineProperties(this, {
            _operations: { enumerable: false, writable: true, value: [] },
            _doubles: { enumerable: false, writable: true, value: [] },
            _booleans: { enumerable: false, writable: true, value: [] },
            _strings: { enumerable: false, writable: true, value: [] },
            _ints: { enumerable: false, writable: true, value: [] }
        });
        const listener = () => this.flush();
        tabris.on('flush', listener);
        this.on('dispose', () => tabris.off('flush', listener));
    }
    init(properties) {
        this._nativeCall('init', properties);
    }
    getImageData(x, y, width, height) {
        const array = this._nativeCall('getImageData', { x, y, width, height });
        // TODO: remove when iOS returns a typed array
        return array instanceof Uint8ClampedArray ? array : new Uint8ClampedArray(array);
    }
    putImageData(imageData, x, y) {
        this._nativeCall('putImageData', {
            data: imageData.data,
            width: imageData.width,
            height: imageData.height,
            x,
            y
        });
    }
    addOperation(operation) {
        const opCode = OPCODES[operation];
        if (!opCode) {
            throw new Error('Invalid operation');
        }
        this._operations.push(opCode);
    }
    addBoolean() {
        Array.prototype.push.apply(this._booleans, arguments);
    }
    addDouble() {
        Array.prototype.push.apply(this._doubles, arguments);
    }
    addInt() {
        Array.prototype.push.apply(this._ints, arguments);
    }
    addString() {
        Array.prototype.push.apply(this._strings, arguments);
    }
    flush() {
        if (this._operations.length > 0) {
            this._nativeCall('draw', { packedOperations: [
                    this._operations,
                    this._doubles,
                    this._booleans,
                    this._strings,
                    this._ints
                ] });
            this._operations = [];
            this._doubles = [];
            this._booleans = [];
            this._strings = [];
            this._ints = [];
        }
    }
    get _nativeType() {
        return 'tabris.GC';
    }
}
NativeObject.defineProperties(GC.prototype, { parent: { type: types.Widget, default: null } });

class GestureRecognizer extends NativeObject {
    get _nativeType() {
        return 'tabris.GestureRecognizer';
    }
    _listen(name, listening) {
        if (name === 'gesture') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
}
NativeObject.defineProperties(GestureRecognizer.prototype, {
    type: { type: types.string, default: null },
    target: { type: types.Widget, default: null },
    fingers: { type: types.natural, default: null },
    touches: { type: types.natural, default: null },
    duration: { type: types.natural, default: null },
    direction: { type: types.string, default: null }
});

const ANIMATABLE_PROPERTIES = ['opacity', 'transform'];
/** @type {PropertyDefinitions} */
const PROPERTIES = {
    properties: { default: Object.freeze({}) },
    delay: { type: types.natural, default: 0 },
    duration: { type: types.natural, default: null },
    repeat: {
        type: {
            convert(value) {
                if (typeof value !== 'number') {
                    throw new Error(`${toValueString(value)} is not a number`);
                }
                if (!(isFinite(value) || isNaN(value) || value === Infinity)) {
                    throw new Error(`${toValueString(value)} is not a valid number`);
                }
                return value;
            },
            encode(value) {
                return value === Infinity ? -1 : value;
            }
        },
        default: 1
    },
    reverse: { type: types.boolean, default: false },
    easing: {
        type: types.string,
        choice: ['linear', 'ease-in', 'ease-out', 'ease-in-out'],
        default: 'liniear'
    },
    target: { type: types.Widget, default: null }
};
class Animation extends NativeObject {
    constructor(properties) {
        super(properties);
        this._nativeListen('completed', true);
    }
    get _nativeType() {
        return 'tabris.Animation';
    }
    _trigger(name, event) {
        if (name === 'completed') {
            this.target.off('dispose', this.abort, this);
            if (this._resolve) {
                this._resolve();
            }
            this.dispose();
        }
        else {
            super._trigger(name, event);
        }
    }
    start(resolve, reject) {
        this.target.on('dispose', this.abort, this);
        Object.defineProperties(this, {
            _resolve: { enumerable: false, writable: false, value: resolve },
            _reject: { enumerable: false, writable: false, value: reject }
        });
        this._nativeCall('start');
    }
    abort() {
        if (this._reject) {
            this._reject();
        }
        this.dispose();
    }
}
NativeObject.defineProperties(Animation.prototype, PROPERTIES);
/**
 * @this {import('./Widget').default}
 * @param {{opacity?: number, transform?: Transformation}} properties
 * @param {AnimationOptions} options
 * @returns {Promise}
 */
function animate(properties, options) {
    const animatedProps = {};
    for (const property in properties) {
        if (ANIMATABLE_PROPERTIES.indexOf(property) !== -1) {
            try {
                const def = this._getPropertyDefinition(property);
                animatedProps[property] = this._convertValue(def, properties[property]);
                this._storeProperty(property, animatedProps[property]);
            }
            catch (ex) {
                hint(this, 'Ignored invalid animation property value for "' + property + '"');
            }
        }
        else {
            hint(this, 'Ignored invalid animation property "' + property + '"');
        }
    }
    for (const option in options) {
        if (!(option in PROPERTIES) && option !== 'name') {
            hint(this, 'Ignored invalid animation option "' + option + '"');
        }
    }
    return new Promise$1((resolve, reject) => {
        new Animation(Object.assign({}, options, {
            target: this,
            properties: animatedProps
        })).start(resolve, reject);
    });
}

const selectorRegex = /^(\*|([#.A-Z][A-Za-z0-9_-]+))$/;
const numberRegex$1 = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
const zeroPercent = new Percent(0);
class Constraint {
    static from(constraintValue) {
        if (constraintValue === true) {
            return zero;
        }
        if (typeof constraintValue === 'string') {
            const str = constraintValue.trim();
            if (str.indexOf(' ') !== -1) {
                return fromArray(str.split(/\s+/));
            }
            if (numberRegex$1.test(str)) {
                return new Constraint(zeroPercent, parseFloat(str));
            }
            return new Constraint(normalizeReference(str), 0);
        }
        if (Array.isArray(constraintValue)) {
            return fromArray(constraintValue);
        }
        if (typeof constraintValue === 'number') {
            if (constraintValue === 0) {
                return zero;
            }
            return new Constraint(zeroPercent, normalizeNumber(constraintValue));
        }
        if (constraintValue instanceof Widget
            || typeof constraintValue === 'symbol'
            || Percent.isValidPercentValue(constraintValue)) {
            return new Constraint(normalizeReference(constraintValue), 0);
        }
        if ('reference' in constraintValue || 'offset' in constraintValue) {
            return fromArray([constraintValue.reference || zeroPercent, constraintValue.offset || 0]);
        }
        throw new Error(`Invalid constraint ${toValueString(constraintValue)}`);
    }
    constructor(reference, offset) {
        if (typeof reference === 'string' && !selectorRegex.test(reference)) {
            throw new Error(`Invalid sibling selector ${toValueString(reference)}`);
        }
        if (!(reference instanceof Percent)) {
            checkIsValidSiblingReference(reference);
        }
        checkNumber(offset);
        Object.defineProperty(this, 'reference', { enumerable: true, value: reference });
        Object.defineProperty(this, 'offset', { enumerable: true, value: offset });
    }
    toString() {
        return `${referenceToString(this.reference)} ${this.offset}`;
    }
    toArray() {
        return [this.reference, this.offset];
    }
    equals(value) {
        if (!(value instanceof Constraint)) {
            return false;
        }
        if (value.offset !== this.offset) {
            return false;
        }
        if (value.reference instanceof Percent && this.reference instanceof Percent) {
            return value.reference.percent === this.reference.percent;
        }
        return value.reference === this.reference;
    }
}
Constraint.next = Symbol('next()');
Constraint.prev = Symbol('prev()');
function checkIsValidSiblingReference(reference) {
    if (typeof reference === 'string' && !selectorRegex.test(reference)) {
        throw new Error(`Invalid sibling selector ${toValueString(reference)}`);
    }
    if (typeof reference !== 'string'
        && !(reference instanceof Widget)
        && reference !== Constraint.next
        && reference !== Constraint.prev) {
        throw new Error(`Invalid constraint reference ${toValueString(reference)}`);
    }
}
function referenceToString(reference) {
    if (reference instanceof Percent) {
        return reference + '%';
    }
    if (reference instanceof Widget) {
        return `${reference.constructor.name}[cid="${reference.cid}"]`;
    }
    if (reference === Constraint.next) {
        return 'next()';
    }
    if (reference === Constraint.prev) {
        return 'prev()';
    }
    return reference;
}
function normalizeReference(reference, shorthand) {
    if (reference === true && shorthand !== undefined) {
        return shorthand;
    }
    if (Percent.isValidPercentValue(reference)) {
        return Percent.from(reference);
    }
    if (reference instanceof Widget || reference === Constraint.next || reference === Constraint.prev) {
        return reference;
    }
    if (typeof reference === 'string') {
        const str = reference.trim();
        if (str === 'prev()') {
            return Constraint.prev;
        }
        if (str === 'next()') {
            return Constraint.next;
        }
        if (selectorRegex.test(str)) {
            return str;
        }
    }
    throw new Error(`${toValueString(reference)} is not a percentage or widget reference`);
}
function normalizeNumber(value, shorthand) {
    if (value === true && shorthand !== undefined) {
        return shorthand;
    }
    if (typeof value === 'string' && numberRegex$1.test(value)) {
        return parseFloat(value);
    }
    return value;
}
const zero = new Constraint(new Percent(0), 0);
function fromArray(array) {
    if (array.length !== 2) {
        throw new Error(`Constraint array requires exactly 2 elements but has ${array.length}`);
    }
    return new Constraint(normalizeReference(array[0]), normalizeNumber(array[1]));
}

class LayoutData {
    static get next() {
        return Constraint.next;
    }
    static get prev() {
        return Constraint.prev;
    }
    static get stretch() {
        if (!this._stretch) {
            Object.defineProperty(this, '_stretch', {
                enumerable: false,
                writable: false,
                value: new LayoutData({
                    left: zero,
                    top: zero,
                    right: zero,
                    bottom: zero
                })
            });
        }
        return this._stretch;
    }
    static get stretchX() {
        if (!this._stretchX) {
            Object.defineProperty(this, '_stretchX', {
                enumerable: false,
                writable: false,
                value: new LayoutData({
                    left: zero,
                    right: zero
                })
            });
        }
        return this._stretchX;
    }
    static get stretchY() {
        if (!this._stretchY) {
            Object.defineProperty(this, '_stretchY', {
                enumerable: false,
                writable: false,
                value: new LayoutData({
                    top: zero,
                    bottom: zero
                })
            });
        }
        return this._stretchY;
    }
    static get center() {
        if (!this._center) {
            Object.defineProperty(this, '_center', {
                enumerable: false,
                writable: false,
                value: new LayoutData({ centerX: 0, centerY: 0 })
            });
        }
        return this._center;
    }
    static from(value) {
        if (value === 'stretch') {
            return LayoutData.stretch;
        }
        if (value === 'stretchX') {
            return LayoutData.stretchX;
        }
        if (value === 'stretchY') {
            return LayoutData.stretchY;
        }
        if (value === 'center') {
            return LayoutData.center;
        }
        if (!(value instanceof Object)) {
            throw new Error(`${toValueString(value)} is not an object`);
        }
        if (value instanceof LayoutData) {
            return value;
        }
        if (value.constructor !== Object) {
            throw new Error(`${toValueString(value)} is not a parameter object`);
        }
        return new LayoutData({
            left: has(value, 'left') ? Constraint.from(value.left) : 'auto',
            right: has(value, 'right') ? Constraint.from(value.right) : 'auto',
            top: has(value, 'top') ? Constraint.from(value.top) : 'auto',
            bottom: has(value, 'bottom') ? Constraint.from(value.bottom) : 'auto',
            centerX: has(value, 'centerX') ? normalizeNumber(value.centerX, 0) : 'auto',
            centerY: has(value, 'centerY') ? normalizeNumber(value.centerY, 0) : 'auto',
            baseline: has(value, 'baseline') ? normalizeReference(value.baseline, LayoutData.prev) : 'auto',
            width: has(value, 'width') ? normalizeNumber(value.width) : 'auto',
            height: has(value, 'height') ? normalizeNumber(value.height) : 'auto'
        });
    }
    constructor(parameters) {
        if (!(parameters instanceof Object) || parameters.constructor !== Object) {
            throw new Error(`${toValueString(parameters)} is not a parameter object`);
        }
        setConstraintValue(this, parameters, 'left');
        setConstraintValue(this, parameters, 'top');
        setConstraintValue(this, parameters, 'right');
        setConstraintValue(this, parameters, 'bottom');
        setDimension$1(this, parameters, 'width');
        setDimension$1(this, parameters, 'height');
        setOffset(this, parameters, 'centerX');
        setOffset(this, parameters, 'centerY');
        setSiblingReference(this, parameters, 'baseline');
    }
    toString() {
        return JSON.stringify({
            left: this.left.toString(),
            right: this.right.toString(),
            top: this.top.toString(),
            bottom: this.bottom.toString(),
            width: this.width,
            height: this.height,
            centerX: this.centerX,
            centerY: this.centerY,
            baseline: referenceToString(this.baseline)
        });
    }
    equals(value) {
        if (!(value instanceof LayoutData)) {
            return false;
        }
        return equals$2(value.left, this.left)
            && equals$2(value.right, this.right)
            && equals$2(value.top, this.top)
            && equals$2(value.bottom, this.bottom)
            && equals$2(value.centerX, this.centerX)
            && equals$2(value.centerY, this.centerY)
            && equals$2(value.baseline, this.baseline)
            && equals$2(value.width, this.width)
            && equals$2(value.height, this.height);
    }
}
function mergeLayoutData(targetValue, sourceValue) {
    const target = LayoutData.from(targetValue);
    const source = LayoutData.from(sourceValue);
    return LayoutData.from({
        left: has(source, 'left') ? source.left : target.left,
        right: has(source, 'right') ? source.right : target.right,
        top: has(source, 'top') ? source.top : target.top,
        bottom: has(source, 'bottom') ? source.bottom : target.bottom,
        centerX: has(source, 'centerX') ? source.centerX : target.centerX,
        centerY: has(source, 'centerY') ? source.centerY : target.centerY,
        baseline: has(source, 'baseline') ? source.baseline : target.baseline,
        width: has(source, 'width') ? source.width : target.width,
        height: has(source, 'height') ? source.height : target.height
    });
}
function has(layoutDataValue, prop) {
    return layoutDataValue[prop] != null && layoutDataValue[prop] !== 'auto';
}
function setConstraintValue(layoutData, parameters, property) {
    const value = (property in parameters) ? parameters[property] : 'auto';
    if (value === 'auto' || value instanceof Constraint) {
        return Object.defineProperty(layoutData, property, { enumerable: true, value });
    }
    throw new Error(`Invalid ${property} constraint ${toValueString(value)}`);
}
function setDimension$1(layoutData, parameters, property) {
    const value = (property in parameters) ? parameters[property] : 'auto';
    if (value !== 'auto') {
        checkNumber(value, [0, Infinity]);
    }
    Object.defineProperty(layoutData, property, { enumerable: true, value });
}
function setOffset(layoutData, parameters, property) {
    const value = (property in parameters) ? parameters[property] : 'auto';
    if (value !== 'auto') {
        checkNumber(value, [-Infinity, Infinity], `Invalid ${property}`);
    }
    Object.defineProperty(layoutData, property, { enumerable: true, value });
}
function setSiblingReference(layoutData, parameters, property) {
    const value = (property in parameters) ? parameters[property] : 'auto';
    if (value !== 'auto') {
        checkIsValidSiblingReference(value);
    }
    return Object.defineProperty(layoutData, property, { enumerable: true, value });
}
function equals$2(a, b) {
    if (a === b) {
        return true;
    }
    if ((a instanceof Constraint) && (b instanceof Constraint)) {
        return a.equals(b);
    }
    return false;
}

/** @type {Array<keyof LayoutData>} */
const layoutDataProps = ['left', 'right', 'top', 'bottom', 'width', 'height', 'centerX', 'centerY', 'baseline'];
const jsxShorthands = {
    center: 'layoutData',
    stretch: 'layoutData',
    stretchX: 'layoutData',
    stretchY: 'layoutData'
};
const defaultGestures = {
    tap: { type: 'tap' },
    longPress: { type: 'longPress' },
    pan: { type: 'pan' },
    panLeft: { type: 'pan', direction: 'left' },
    panRight: { type: 'pan', direction: 'right' },
    panUp: { type: 'pan', direction: 'up' },
    panDown: { type: 'pan', direction: 'down' },
    panHorizontal: { type: 'pan', direction: 'horizontal' },
    panVertical: { type: 'pan', direction: 'vertical' },
    swipeLeft: { type: 'swipe', direction: 'left' },
    swipeRight: { type: 'swipe', direction: 'right' },
    swipeUp: { type: 'swipe', direction: 'up' },
    swipeDown: { type: 'swipe', direction: 'down' }
};
/**
 * @abstract
 */
class Widget extends NativeObject {
    /**
     * @param {import('./widgets/Composite').default} widget
     */
    appendTo(widget) {
        this._checkDisposed();
        widget = widget instanceof WidgetCollection ? widget.first() : widget;
        if (!(widget instanceof NativeObject)) {
            throw new Error(`Cannot append to non-widget ${toValueString(widget)}`);
        }
        this._setParent(widget);
        return this;
    }
    /**
     * @param {import('./widgets/Composite').default} widget
     */
    insertBefore(widget) {
        this._checkDisposed();
        widget = widget instanceof WidgetCollection ? widget.first() : widget;
        if (!(widget instanceof NativeObject)) {
            throw new Error(`Cannot insert before non-widget ${toValueString(widget)}`);
        }
        const parent = widget.parent();
        if (!parent) {
            throw new Error(`Cannot insert before orphan ${toValueString(widget)}`);
        }
        const index = parent.$children.indexOf(widget);
        this._setParent(parent, index);
        return this;
    }
    /**
     * @param {import('./widgets/Composite').default} widget
     */
    insertAfter(widget) {
        this._checkDisposed();
        widget = widget instanceof WidgetCollection ? widget.first() : widget;
        if (!(widget instanceof NativeObject)) {
            throw new Error(`Cannot insert after non-widget ${toValueString(widget)}`);
        }
        const parent = widget.parent();
        if (!parent) {
            throw new Error(`Cannot insert after orphan ${toValueString(widget)}`);
        }
        this.detach();
        const index = parent.$children.indexOf(widget);
        this._setParent(parent, index + 1);
        return this;
    }
    detach() {
        this._checkDisposed();
        this._setParent(null);
        return this;
    }
    /**
     * @param {Selector} selector
     */
    parent(selector) {
        if (!selector || !this._parent) {
            return this._parent || null;
        }
        let candidate = this._parent;
        const filter = getFilter(selector);
        while (candidate && !filter(candidate)) {
            candidate = candidate.parent();
        }
        return candidate;
    }
    /**
     * @param {Selector} selector
     * @returns {WidgetCollection}
     */
    siblings(selector) {
        if (!this._parent) {
            return new WidgetCollection([]);
        }
        return this._parent._children(widget => widget !== this).filter(selector);
    }
    /**
     * @param {string} value
     */
    set class(value) {
        if (this._isDisposed) {
            hint(this, 'Cannot set property "class" on disposed object');
            return;
        }
        Object.defineProperty(this, '_classList', {
            enumerable: true,
            writable: true,
            value: types.string.convert(value).trim().split(/\s+/)
        });
        this._triggerChangeEvent('class', this.class);
    }
    get class() {
        if (this._isDisposed) {
            return undefined;
        }
        return this.classList.join(' ');
    }
    set layoutData(value) {
        if (this._isDisposed) {
            hint(this, 'Cannot set property "layoutData" on disposed object');
            return;
        }
        const oldLayoutData = this._layoutData;
        if (oldLayoutData && oldLayoutData.equals(value)) {
            return;
        }
        Object.defineProperty(this, '_layoutData', {
            enumerable: false,
            writable: true,
            value: ( /** @type {LayoutData} */(value ? LayoutData.from(value) : new LayoutData({})))
        });
        this._triggerChangeEvent('layoutData', this._layoutData);
        layoutDataProps.forEach(prop => {
            const oldValue = oldLayoutData ? oldLayoutData[prop] : 'auto';
            if (oldValue !== this._layoutData[prop]) {
                this._triggerChangeEvent(prop, this._layoutData[prop]);
            }
        });
    }
    get layoutData() {
        if (this._isDisposed) {
            return undefined;
        }
        if (!this._layoutData) {
            Object.defineProperty(this, '_layoutData', {
                enumerable: false,
                writable: true,
                value: ( /** @type {LayoutData} */(new LayoutData({})))
            });
        }
        return this._layoutData;
    }
    get classList() {
        if (this._isDisposed) {
            return undefined;
        }
        if (!this._classList) {
            Object.defineProperty(this, '_classList', {
                enumerable: true,
                writable: true,
                value: []
            });
        }
        return this._classList;
    }
    set data(value) {
        if (this._isDisposed || this.$data === value) {
            return;
        }
        checkType(value, Object, { name: 'data', nullable: true });
        Object.defineProperty(this, '$data', {
            enumerable: false, writable: true, value
        });
        this._triggerChangeEvent('data', this.$data);
    }
    get data() {
        if (this._isDisposed) {
            return undefined;
        }
        if (!('$data' in this)) {
            Object.defineProperty(this, '$data', { enumerable: false, writable: true, value: {} });
        }
        return this.$data;
    }
    get absoluteBounds() {
        if (this._isDisposed) {
            return undefined;
        }
        return types.Bounds.decode(this._nativeGet('absoluteBounds'));
    }
    set id(value) {
        /** @type {string} */
        const id = types.string.convert(value);
        if (id === this._id) {
            return;
        }
        Object.defineProperty(this, '_id', { enumerable: false, writable: true, value: id });
    }
    get id() {
        if (this._isDisposed) {
            return undefined;
        }
        return this._id || '';
    }
    set gestures(gestures) {
        /** @type {typeof defaultGestures} */
        const value = Object.assign({}, defaultGestures, gestures);
        Object.defineProperty(this, '_gestures', { enumerable: false, writable: true, value });
    }
    get gestures() {
        if (!this._gestures) {
            /** @type {typeof defaultGestures} */
            const value = Object.assign({}, defaultGestures);
            Object.defineProperty(this, '_gestures', { enumerable: false, writable: true, value });
        }
        return this._gestures;
    }
    set excludeFromLayout(value) {
        if (this._excludeFromLayout !== !!value) {
            Object.defineProperty(this, '_excludeFromLayout', { enumerable: false, writable: true, value: !!value });
        }
        if (this._parent) {
            this._parent._scheduleRenderChildren();
        }
        this._triggerChangeEvent('excludeFromLayout', this._excludeFromLayout);
    }
    get excludeFromLayout() {
        return !!this._excludeFromLayout;
    }
    toString() {
        const type = this.constructor.name;
        const cidAttr = `[cid="${this.cid}"]`;
        const id = this.id ? '#' + this.id : '';
        const classes = this.classList.length ? '.' + this.classList.join('.') : '';
        return type + cidAttr + id + classes;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (this.id) {
            result.push(['id', this.id]);
        }
        if (this.class) {
            result.push(['class', this.class]);
        }
        const bounds = this.bounds;
        result.push([
            'bounds',
            `{left: ${Math.round(bounds.left)}, top: ${Math.round(bounds.top)}, ` +
                `width: ${Math.round(bounds.width)}, height: ${Math.round(bounds.height)}}`
        ]);
        if (!this.enabled) {
            result.push(['enabled', 'false']);
        }
        if (!this.visible) {
            result.push(['visible', 'false']);
        }
        return result;
    }
    /**
     * @param {import('./widgets/Composite').default} parent
     * @param {number} index
     */
    _setParent(parent, index) {
        if (this._parent) {
            this._parent._removeChild(this);
        }
        Object.defineProperty(this, '_parent', { enumerable: false, writable: true, value: parent });
        if (this._parent) {
            this._parent._addChild(this, index);
        }
    }
    /**
     * @param {string} name
     * @param {boolean} listening
     */
    _listen(name, listening) {
        if (this._isDisposed) {
            return;
        }
        if (this.gestures[name]) {
            if (listening) {
                const properties = Object.assign({ target: this }, this.gestures[name]);
                const recognizer = new GestureRecognizer(properties).on('gesture', event => {
                    if (event.translation) {
                        event.translationX = event.translation.x;
                        event.translationY = event.translation.y;
                    }
                    if (event.velocity) {
                        event.velocityX = event.velocity.x;
                        event.velocityY = event.velocity.y;
                    }
                    super._trigger(name, event);
                });
                if (!this._recognizers) {
                    Object.defineProperty(this, '_recognizers', { enumerable: false, writable: false, value: {} });
                }
                this._recognizers[name] = recognizer;
                this.on('dispose', recognizer.dispose, recognizer);
            }
            else if (this._recognizers && name in this._recognizers) {
                this._recognizers[name].dispose();
                delete this._recognizers[name];
            }
        }
        else {
            super._listen(name, listening);
        }
    }
    /**
     * @param {string} name
     * @param {object} event
     */
    _trigger(name, event) {
        if (name === 'resize') {
            return super._trigger(name, types.Bounds.decode(event.bounds));
        }
        return super._trigger(name, event);
    }
    _release() {
        if (this._parent) {
            this._parent._removeChild(this);
            this._parent = null;
        }
    }
    /**
     * @param {string[]} properties
     */
    _reorderProperties(properties) {
        const layoutDataIndex = properties.indexOf('layoutData');
        if (layoutDataIndex !== -1) {
            const removed = properties.splice(layoutDataIndex, 1);
            return removed.concat(properties);
        }
        return properties;
    }
}
NativeObject.defineProperties(Widget.prototype, {
    enabled: {
        type: types.boolean,
        default: true
    },
    visible: {
        type: types.boolean,
        default: true
    },
    elevation: {
        type: types.natural,
        default: 0
    },
    bounds: {
        type: types.Bounds,
        readonly: true,
        nocache: true
    },
    background: {
        type: types.Shader,
        default: 'initial'
    },
    opacity: {
        type: types.fraction,
        default: 1
    },
    transform: {
        type: types.Transformation,
        default: Object.freeze({
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            translationX: 0,
            translationY: 0,
            translationZ: 0
        })
    },
    highlightOnTouch: {
        type: types.boolean,
        default: false
    },
    cornerRadius: {
        type: types.number,
        default: 0
    },
    padding: {
        type: types.BoxDimensions,
        default: Object.freeze({ left: 0, right: 0, top: 0, bottom: 0 })
    }
});
layoutDataProps.forEach(prop => {
    Object.defineProperty(Widget.prototype, prop, {
        set(value) {
            this.layoutData = LayoutData.from(Object.assign({}, this.layoutData, { [prop]: value }));
        },
        get() {
            return this.layoutData[prop];
        }
    });
    NativeObject.defineEvent(Widget.prototype, prop + 'Changed', true);
});
NativeObject.defineChangeEvents(Widget.prototype, [
    'layoutData',
    'class',
    'data'
]);
NativeObject.defineEvents(Widget.prototype, {
    tap: true,
    longPress: true,
    pan: true,
    panLeft: true,
    panRight: true,
    panUp: true,
    panDown: true,
    panHorizontal: true,
    panVertical: true,
    swipeLeft: true,
    swipeRight: true,
    swipeUp: true,
    swipeDown: true,
    touchStart: { native: true },
    touchMove: { native: true },
    touchEnd: { native: true },
    touchCancel: { native: true },
    resize: {
        native: true,
        nativeObservable: false,
        changes: 'bounds',
        changeValue: ({ left, top, width, height, bounds }) => bounds || ({ left, top, width, height })
    },
    addChild: true,
    removeChild: true
});
Widget.prototype.animate = animate;
Widget.prototype[JSX.jsxFactory] = createElement$1;
/** @this {import("./JsxProcessor").default} */
function createElement$1(Type, attributes) {
    const finalAttributes = this.withShorthands(attributes, jsxShorthands, mergeLayoutData);
    return this.createNativeObject(Type, finalAttributes);
}

const layoutDataProps$1 = ['left', 'right', 'top', 'bottom', 'width', 'height', 'centerX', 'centerY', 'baseline'];
class Layout {
    // eslint-disable-next-line no-unused-vars
    constructor(properties = {}, queue) {
        if (this.constructor === Layout) {
            throw new Error('Can not create instance of abstract class "Layout"');
        }
        Object.defineProperty(this, '_layoutQueue', {
            enumerable: false, writable: false, value: queue || LayoutQueue.instance
        });
        if (!(this._layoutQueue instanceof LayoutQueue)) {
            throw new Error('Not a LayoutQueue: ' + this._layoutQueue);
        }
        Object.defineProperties(this, {
            _handleAddChildEvent: {
                enumerable: false,
                writable: false,
                value: this._handleAddChildEvent.bind(this)
            },
            _handleRemoveChildEvent: {
                enumerable: false,
                writable: false,
                value: this._handleRemoveChildEvent.bind(this)
            },
            _handleChildPropertyChangedEvent: {
                enumerable: false,
                writable: false,
                value: this._handleChildPropertyChangedEvent.bind(this)
            },
            _getLayoutData: {
                enumerable: false,
                writable: false,
                value: this._getLayoutData.bind(this)
            },
            _renderLayoutData: {
                enumerable: false,
                writable: false,
                value: this._renderLayoutData.bind(this)
            },
            _addChild: {
                enumerable: false,
                writable: false,
                value: this._addChild.bind(this)
            },
            _removeChild: {
                enumerable: false,
                writable: false,
                value: this._removeChild.bind(this)
            }
        });
    }
    add(composite) {
        if (!composite || composite.layout !== this) {
            throw new Error(`Invalid layout target ${toValueString(composite)}. Do not call layout.add directly.`);
        }
        composite.on({
            addChild: this._handleAddChildEvent,
            removeChild: this._handleRemoveChildEvent
        });
        if (composite.$children) {
            composite.$children.forEach(this._addChild);
        }
        this._layoutQueue.add(composite);
    }
    remove(composite) {
        composite.off({
            addChild: this._handleAddChildEvent,
            removeChild: this._handleRemoveChildEvent
        });
        if (composite.$children) {
            composite.$children.forEach(this._removeChild);
        }
    }
    render(composite) {
        const children = getChildrenInLayout(composite);
        if (!children.length) {
            return;
        }
        const allLayoutData = children.map(this._getLayoutData);
        this._renderLayoutData(children, allLayoutData);
    }
    _handleAddChildEvent({ child }) {
        this._addChild(child);
        this._layoutQueue.add(child._parent);
    }
    _handleRemoveChildEvent({ child }) {
        this._removeChild(child);
        this._layoutQueue.add(child._parent);
    }
    _addChild(child) {
        child.on({
            layoutDataChanged: this._handleChildPropertyChangedEvent,
            excludeFromLayoutChanged: this._handleChildPropertyChangedEvent
        });
    }
    _removeChild(child) {
        child.off({
            layoutDataChanged: this._handleChildPropertyChangedEvent,
            excludeFromLayoutChanged: this._handleChildPropertyChangedEvent
        });
    }
    _handleChildPropertyChangedEvent({ target }) {
        this._layoutQueue.add(target._parent);
    }
    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */
    _renderLayoutData(children, allLayoutData) {
        for (let i = 0; i < children.length; i++) {
            const rawLayoutData = this._resolveAttributes(allLayoutData[i], children[i]);
            children[i]._nativeSet('layoutData', rawLayoutData);
        }
    }
    /**
     * @param {import('./Widget').default} child
     * @param {number} index
     */
    // eslint-disable-next-line no-unused-vars
    _getLayoutData(child, index) {
        let result = child.layoutData;
        if (result.centerX !== 'auto') {
            if (result.left !== 'auto' || result.right !== 'auto') {
                warn('Inconsistent layoutData: centerX overrides left and right.\nTarget: ' + getPath(child));
                result = makeAuto(result, 'left', 'right');
            }
        }
        if (result.baseline !== 'auto') {
            if (result.top !== 'auto' || result.bottom !== 'auto' || result.centerY !== 'auto') {
                warn('Inconsistent layoutData: baseline overrides top, bottom, and centerY.\nTarget: ' + getPath(child));
                result = makeAuto(result, 'top', 'bottom', 'centerY');
            }
        }
        else if (result.centerY !== 'auto') {
            if (result.top !== 'auto' || result.bottom !== 'auto') {
                warn('Inconsistent layoutData: centerY overrides top and bottom.\nTarget: ' + getPath(child));
                result = makeAuto(result, 'top', 'bottom');
            }
        }
        if (result.left !== 'auto' && result.right !== 'auto' && result.width !== 'auto') {
            warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
            result = makeAuto(result, 'width');
        }
        if (result.top !== 'auto' && result.bottom !== 'auto' && result.height !== 'auto') {
            warn('Inconsistent layoutData: top and bottom are set, ignore height.\nTarget: ' + getPath(child));
            result = makeAuto(result, 'height');
        }
        const property = ['left', 'top', 'right', 'bottom'].find(prop => result[prop].offset && result[prop].offset < 0);
        if (property) {
            warn('Negative edge offsets are not supported. Setting ' + property + ' to 0.\nTarget: ' + getPath(child));
            const normalizedPropertyValue = Object.assign({}, result[property], { offset: 0 });
            result = LayoutData.from(Object.assign({}, result, { [property]: normalizedPropertyValue }));
        }
        return result;
    }
    /**
     * @param {LayoutData} layoutData
     * @param {import('./Widget').default} targetWidget
     */
    _resolveAttributes(layoutData, targetWidget) {
        const result = {};
        for (let i = 0; i < layoutDataProps$1.length; i++) {
            const prop = layoutDataProps$1[i];
            if (prop in layoutData && layoutData[prop] !== 'auto') {
                result[prop] = resolveAttribute(layoutData[prop], targetWidget);
            }
        }
        return result;
    }
}
class ConstraintLayout extends Layout {
    static get default() {
        if (!this._default) {
            Object.defineProperty(this, '_default', {
                enumerable: false,
                writable: true,
                configurable: true,
                value: new ConstraintLayout()
            });
        }
        return this._default;
    }
}
class LayoutQueue {
    static get instance() {
        if (!this._instance) {
            Object.defineProperty(this, '_instance', {
                enumerable: false,
                writable: true,
                configurable: true,
                value: new LayoutQueue()
            });
            tabris.on('layout', () => this._instance.flush());
        }
        return this._instance;
    }
    constructor() {
        Object.defineProperties(this, {
            _map: { enumerable: false, writable: true, value: {} },
            _inFlush: { enumerable: false, writable: true, value: false }
        });
    }
    add(composite) {
        if (this._inFlush) {
            hint(this, 'WARNING: Widget layout manipulation during layout flush may cause inconsistent state');
            return;
        }
        this._map[composite.cid] = composite;
    }
    flush() {
        if (this._inFlush) {
            return;
        }
        this._inFlush = true;
        for (const cid in this._map) {
            if (!this._map[cid]._isDisposed && this._map[cid].layout) {
                this._map[cid].layout.render(this._map[cid]);
            }
        }
        this._map = {};
        this._inFlush = false;
    }
}
function isValidConstraint(constraint) {
    if (constraint === 'auto') {
        return true;
    }
    if (constraint.reference instanceof Percent && constraint.reference.percent === 0) {
        return true;
    }
    return false;
}
function layoutWarn(child, prop, message) {
    warn(`Unsupported value for "${prop}": ${message}\nTarget: ${getPath(child)}`);
}
function getPath(widget) {
    const path = [widget];
    let parent = widget.parent();
    while (parent) {
        path.unshift(parent);
        parent = parent.parent();
    }
    return path.join(' > ');
}
/**
 * @param {number} value1
 * @param {number} value2
 * @return {number}
 */
function maxPositive(value1, value2) {
    if (value1 < 0 || value2 < 0) {
        return 0;
    }
    return Math.max(0, Math.max(value1, value2));
}
function resolveAttribute(value, widget) {
    if (value instanceof Constraint) {
        return resolveConstraint(value, widget);
    }
    if (isNumber(value)) {
        return value;
    }
    return toCid(value, widget);
}
function resolveConstraint(constraint, widget) {
    if (constraint.reference instanceof Percent) {
        if (constraint.reference.percent === 0) {
            return constraint.offset;
        }
        return [constraint.reference.percent, constraint.offset];
    }
    return [toCid(constraint.reference, widget), constraint.offset];
}
function toCid(ref, widget) {
    if (ref === LayoutData.prev) {
        const children = getChildrenInLayout(getParent(widget));
        const index = children.indexOf(widget);
        if (index > 0) {
            return types.Widget.encode(children[index - 1]) || 0;
        }
        return 0;
    }
    if (ref === LayoutData.next) {
        const children = getChildrenInLayout(getParent(widget));
        const index = children.indexOf(widget);
        if (index + 1 < children.length) {
            return types.Widget.encode(children[index + 1]) || 0;
        }
        return 0;
    }
    if (typeof ref === 'string') {
        const sibling = widget.siblings(ref)[0];
        return types.Widget.encode(sibling) || 0;
    }
    if (widget.siblings().toArray().includes(ref)) {
        return types.Widget.encode(ref) || 0;
    }
    return 0;
}
function isNumber(value) {
    return typeof value === 'number' && isFinite(value);
}
function getParent(widget) {
    return widget.parent() || emptyParent;
}
function makeAuto(layoutData, ...props) {
    const override = {};
    for (let i = 0; i < props.length; i++) {
        override[props[i]] = 'auto';
    }
    return LayoutData.from(Object.assign({}, layoutData, override));
}
function getChildrenInLayout(parent) {
    return parent.$children ? parent.$children.filter(notExcluded) : [];
}
function notExcluded(widget) {
    return !widget.excludeFromLayout;
}
const emptyParent = {
    children() {
        return [];
    }
};

function apply(config) {
    const host = config.host;
    if (config.args.length === 1
        && (typeof config.args[0] === 'string' || typeof config.args[0] === 'symbol')) {
        triggerUpdate(config.args[0], host);
        return host;
    }
    const applyArgs = parseApplyArgs(config.args);
    const children = config.protected ? host._children() : host.children();
    const scope = new WidgetCollection(
    // @ts-ignore TODO: migrate Widget and Composite to TypeScript to fix these
    asArray(children).concat(host), { selector: '*', origin: host, deep: true });
    if (applyArgs.trigger !== '*') {
        // @ts-ignore
        applyRules(applyArgs, host, scope);
    }
    setupTrigger(applyArgs, host, scope);
    return host;
}
function applyRules(applyArgs, host, scope, internal) {
    const rulesSets = applyArgs.rules instanceof Function
        ? checkType(applyArgs.rules(host), Object, 'returned rules')
        : applyArgs.rules;
    if (!rulesSets) {
        return;
    }
    asArray(rulesSets).forEach(rules => {
        if (rules[setterTargetType]) {
            return applyRule(applyArgs.mode, scope, [[rules[setterTargetType]], rules], host, !!internal);
        }
        Object.keys(rules)
            .map(key => [createSelectorArray(key, host), rules[key]])
            .sort((rule1, rule2) => getSelectorSpecificity(rule1[0]) - getSelectorSpecificity(rule2[0]))
            .forEach(rule => {
            applyRule(applyArgs.mode, scope, rule, host, !!internal);
        });
    });
}
function setupTrigger(applyArgs, host, scope) {
    var _a;
    const trigger = applyArgs.trigger;
    if (trigger === 'rules') {
        return;
    }
    const attached = getApplyAttributeObject(host);
    // @ts-ignore
    const updater = applyArgs.rules ? () => applyRules(applyArgs, host, scope) : null;
    if (typeof trigger === 'string' && isListenerAttribute(trigger)) {
        registerListenerAttributes(host, { [trigger]: updater }, attached);
    }
    else if (trigger === '*') {
        (_a = attached[trigger]) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (updater) {
            attached[trigger] = Observable.mutations(host).subscribe(updater);
        }
    }
    else {
        attached[trigger] = updater;
    }
}
function triggerUpdate(trigger, host) {
    const attached = getApplyAttributeObject(host);
    if (!attached[trigger]) {
        throw new Error(`No ruleset is associated with trigger "${String(trigger)}"`);
    }
    attached[trigger]();
}
function parseApplyArgs(args) {
    if (args.length === 0 || args.length > 2) {
        throw new Error(`Expected 1-2 arguments, got ${args.length}`);
    }
    const withOptions = args.length === 2;
    const { mode, trigger } = normalizeApplyOptions(withOptions ? args[0] : {});
    const rules = withOptions ? args[1] : args[0];
    if (typeof trigger !== 'symbol') {
        checkType(trigger, String, 'trigger');
    }
    checkType(rules, Object, { nullable: trigger !== 'rules' });
    if (mode !== 'default' && mode !== 'strict') {
        throw new Error(`Value "${mode}" is not a valid mode.`);
    }
    return { rules, mode, trigger };
}
function normalizeApplyOptions(value) {
    const mode = typeof value === 'string' ? value : value.mode || 'default';
    const options = value instanceof Object ? value : {};
    const trigger = options.trigger || 'rules';
    return { mode, trigger };
}
function applyRule(mode, scope, rule, host, internal) {
    const [selector, attributes] = rule;
    checkType(attributes, Object, { name: 'rule attributes' });
    const targetType = attributes[setterTargetType];
    const matches = scope.filter(selector);
    if (mode === 'strict') {
        checkApplyMatches(selector, matches, host);
    }
    scope.filter(selector).forEach((widget) => {
        if (targetType && !(widget instanceof targetType)) {
            throw new TypeError(`Can not set properties of ${targetType.name} on ${widget}`);
        }
        widget.set(attributesWithoutListener(attributes));
        registerListenerAttributes(widget, attributes, internal ? {} : widget.jsxAttributes);
    });
}
function checkApplyMatches(selector, matches, host) {
    const selectorStr = selector.map(part => part === host ? ':host' : part).join(' > ');
    if (matches.length === 0) {
        throw new Error(`No widget matches the given selector "${selectorStr}"`);
    }
    const last = selector[selector.length - 1];
    if (typeof last === 'string' && last[0] === '#' && matches.length > 1) {
        throw new Error(`More than one widget matches the given selector "${selectorStr}"`);
    }
    const isHostSelector = selector.length === 1 && selector[0] === host;
    // @ts-ignore TODO: migrate WidgetCollection to fix this
    if (!isHostSelector && matches.length === 1 && matches[0] === host) {
        throw new Error(`The only widget that matches the given selector "${selectorStr}" is the host widget`);
    }
}
function getApplyAttributeObject(host) {
    if (!host.jsxAttributes) {
        host.jsxAttributes = {};
    }
    if (!host.jsxAttributes.apply) {
        host.jsxAttributes.apply = {};
    }
    return host.jsxAttributes.apply;
}

class Composite extends Widget {
    get layout() {
        return this._layout;
    }
    set layout(value) {
        hint(this, 'Can not set read-only property "layout"');
    }
    append() {
        this._checkDisposed();
        const accept = (/** @type {Widget} */ widget) => {
            if (!(widget instanceof NativeObject)) {
                throw new Error(`Cannot append non-widget ${toValueString(widget)} to ${this}`);
            }
            if (widget === this) {
                throw new Error(`Cannot append widget ${this} to itself`);
            }
            widget._setParent(this);
        };
        if (arguments[0] instanceof WidgetCollection) {
            arguments[0].toArray().forEach(accept);
        }
        else if (Array.isArray(arguments[0])) {
            arguments[0].forEach(accept);
        }
        else {
            Array.prototype.forEach.call(arguments, accept);
        }
        return this;
    }
    find(selector) {
        return new WidgetCollection(this.children(), { selector, origin: this, deep: true });
    }
    /**
     * @param {object|string} arg1
     * @param {object=} arg2
     */
    apply(arg1, arg2) {
        return apply({ host: this, args: arguments, protected: false });
    }
    /** @param {any=} selector */
    children(selector) {
        return this._children(selector);
    }
    set(props) {
        if (props && ('children' in props) && !(props.children instanceof Function)) {
            throw new Error('You may not override children with a non-function');
        }
        return super.set(props);
    }
    _nativeCreate(properties) {
        super._nativeCreate(omit(properties || {}, ['layout']));
        this._initLayout(properties);
    }
    /**
     * @param {any} props
     */
    _initLayout(props = {}) {
        if (!('layout' in props)) {
            Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: ConstraintLayout.default });
        }
        else if (props.layout) {
            Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: props.layout });
        }
        else {
            Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
        }
        if (this._layout) {
            this._checkLayout(this._layout);
            this._layout.add(this);
        }
    }
    /**
     * @param {any=} selector
     */
    _children(selector) {
        return new WidgetCollection(this.$children, { selector, origin: this });
    }
    _find(selector) {
        return new WidgetCollection(this._children(), { selector, origin: this, deep: true });
    }
    /**
     * @param {object|string} arg1
     * @param {object=} arg2
     */
    _apply(arg1, arg2, arg3) {
        return apply({ host: this, args: arguments, protected: true });
    }
    get _nativeType() {
        return 'tabris.Composite';
    }
    // eslint-disable-next-line no-unused-vars
    _acceptChild(child) {
        return true;
    }
    _checkLayout(value) {
        if (value && !(value instanceof Layout)) {
            throw new Error(`${toValueString(value)} is not an instance of Layout`);
        }
    }
    _addChild(child, index) {
        if (!this._acceptChild(child)) {
            throw new Error(`${toValueString(child)} could not be appended to ${this}`);
        }
        if (!this.$children) {
            Object.defineProperties(this, {
                $children: { enumerable: false, writable: true, value: [] }
            });
        }
        if (typeof index === 'number') {
            this.$children.splice(index, 0, child);
        }
        else {
            index = this.$children.push(child) - 1;
        }
        this._scheduleRenderChildren();
        super._trigger('addChild', { child, index });
    }
    _removeChild(child) {
        if (this.$children) {
            const index = this.$children.indexOf(child);
            if (index !== -1) {
                this.$children.splice(index, 1);
                this._scheduleRenderChildren();
                super._trigger('removeChild', { child, index });
            }
        }
    }
    _release() {
        if (this.$children) {
            const children = this.$children.concat();
            for (let i = 0; i < children.length; i++) {
                const skipNative = !children[i].excludeFromLayout;
                children[i]._dispose(skipNative);
            }
            this.$children = undefined;
        }
        if (this._layout) {
            this._layout.remove(this);
        }
        super._release();
    }
    _getXMLContent() {
        const content = super._getXMLContent();
        for (let i = 0; i < (this.$children || []).length; ++i) {
            content.push(this.$children[i][toXML$1]().split('\n').map(line => '  ' + line).join('\n'));
        }
        return content;
    }
    _scheduleRenderChildren() {
        tabris.once('layout', this.$flushChildren, this);
    }
    $flushChildren() {
        if (this.$children) {
            this._nativeSet('children', this.$children.filter(notExcluded$1).map(toCid$1));
        }
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const _a = this.withoutChildren(attributes), { apply: ruleSets } = _a, normalAttributes = __rest(_a, ["apply"]);
        const result = super[JSX.jsxFactory](Type, normalAttributes);
        if (children && children.length) {
            result.append(children);
        }
        if (ruleSets) {
            asArray(ruleSets).forEach(rules => result.apply({
                mode: 'strict',
                trigger: rules instanceof Function ? '*' : 'rules'
            }, rules));
        }
        return result;
    }
}
function toCid$1(widget) {
    return widget.cid;
}
function notExcluded$1(widget) {
    return !widget.excludeFromLayout;
}

const MIME_TYPES = Object.freeze({
    'image/png': 'image/png',
    'image/jpeg': 'image/jpeg',
    'image/webp': 'image/webp'
});
const TYPE_QUALITY = Object.freeze({
    'image/png': 1,
    'image/jpeg': 0.92,
    'image/webp': 0.8
});
class Canvas extends Composite {
    get _nativeType() {
        return 'tabris.Canvas';
    }
    /**
     * @param {string} type
     * @param {number} width
     * @param {number} height
     * @returns {CanvasContext}
     */
    getContext(type, width, height) {
        if (type === '2d') {
            return CanvasContext.getContext(this, width, height);
        }
        return null;
    }
    /**
     * @param {unknown=} callback
     * @param {unknown=} mimeType
     * @param {unknown=} quality
     */
    toBlob(callback, mimeType, quality) {
        if (arguments.length === 0) {
            throw new TypeError('Canvas.toBlob requires at least 1 argument, but only 0 were passed');
        }
        if (!(callback instanceof Function)) {
            throw new TypeError('Argument 1 of Canvas.toBlob is not a function');
        }
        if (this._ctx) {
            this._ctx._gc.flush();
        }
        const isValidQuality = typeof quality === 'number' && !isNaN(quality) && quality >= 0 && quality <= 1;
        const validType = MIME_TYPES[typeof mimeType === 'string' ? mimeType : ''] || MIME_TYPES['image/png'];
        this._nativeCall('toBlob', {
            onSuccess: createNativeCallback((buffer, resultType) => {
                if (!buffer) {
                    callback(null);
                }
                else {
                    const blob = new Blob([], { type: resultType });
                    setBytes(blob, buffer);
                    callback(blob);
                }
            }),
            mimeType: validType,
            quality: isValidQuality ? quality : TYPE_QUALITY[validType]
        });
    }
}

class ImageBitmap {
    /**
     * @param {Blob|ImageData|ImageBitmap|Canvas} imageSource
     */
    static createImageBitmap(imageSource) {
        const options = getOptions(arguments);
        if (imageSource instanceof Blob) {
            return load(options, _image => _image.loadEncodedImage(getBytes(imageSource)));
        }
        else if (imageSource instanceof ImageData) {
            return load(options, _image => _image.loadImageData(imageSource.data, imageSource.width, imageSource.height));
        }
        else if (imageSource instanceof ImageBitmap) {
            if (getNativeObject(imageSource).isDisposed()) {
                return Promise$1.reject(new TypeError('Can not create ImageBitmap from another closed ImageBitmap'));
            }
            return load(options, _image => _image.loadImageBitmap(getNativeObject(imageSource).cid));
        }
        else if (imageSource instanceof Canvas) {
            if (imageSource.isDisposed()) {
                return Promise$1.reject(new TypeError('Can not create ImageBitmap from a disposed Canvas'));
            }
            return load(options, _image => _image.loadCanvas(imageSource));
        }
        throw new TypeError('Argument 1 of createImageBitmap could not be converted to any of: Blob, ImageData, ImageBitmap, Canvas.');
    }
    /**
     * @param {_ImageBitmap} nativeObject
     * @param {any} resolution
     */
    constructor(nativeObject, resolution) {
        if (!(nativeObject instanceof _ImageBitmap)) {
            throw new TypeError('Illegal constructor');
        }
        setNativeObject(this, nativeObject);
        Object.defineProperty(this, 'width', { value: resolution.width });
        Object.defineProperty(this, 'height', { value: resolution.height });
    }
    close() {
        if (!getNativeObject(this).isDisposed()) {
            getNativeObject(this).dispose();
        }
    }
}
Object.defineProperty(ImageBitmap.prototype, 'width', { value: 0 });
Object.defineProperty(ImageBitmap.prototype, 'height', { value: 0 });
class _ImageBitmap extends NativeObject {
    get _nativeType() {
        return 'tabris.ImageBitmap';
    }
    /** @param {ArrayBuffer} image */
    loadEncodedImage(image) {
        return new Promise$1((onSuccess, onError) => this._nativeCall('loadEncodedImage', { image, onSuccess, onError }));
    }
    /**
     *  @param {Uint8ClampedArray} imageData
     *  @param {number} width
     *  @param {number} height
     **/
    loadImageData(imageData, width, height) {
        return new Promise$1((onSuccess, onError) => this._nativeCall('loadImageData', { image: imageData, width, height, onSuccess, onError }));
    }
    /** @param {string} imageBitmap */
    loadImageBitmap(imageBitmap) {
        return new Promise$1((onSuccess, onError) => this._nativeCall('loadImageBitmap', { image: imageBitmap, onSuccess, onError }));
    }
    /** @param {Canvas} canvas */
    loadCanvas(canvas) {
        return new Promise$1((onSuccess, onError) => {
            if (canvas._ctx) {
                canvas._ctx._gc.flush();
            }
            this._nativeCall('loadCanvas', { image: canvas.cid, onSuccess, onError });
        });
    }
}
NativeObject.defineProperties(_ImageBitmap.prototype, {
    rect: { type: 'any', default: null },
    resizeWidth: { type: 'natural', default: null },
    resizeHeight: { type: 'natural', default: null },
    resizeQuality: {
        type: 'string',
        default: 'low',
        choice: ['pixelated', 'low', 'medium', 'high']
    }
});
/**
 * @param {IArguments} args
 */
function getOptions(args) {
    if ([1, 2, 5, 6].indexOf(args.length) === -1) {
        throw new TypeError(`${args.length} is not a valid argument count for any overload of createImageBitmap.`);
    }
    const options = {};
    if (args.length === 2 && args[1] != null) {
        if (!(args[1] instanceof Object)) {
            throw new TypeError('Argument 2 of createImageBitmap is not an object.');
        }
        Object.assign(options, args[1]);
    }
    else if (args.length >= 5) {
        if (args.length === 6) {
            if (args[5] != null && !(args[5] instanceof Object)) {
                throw new TypeError('Argument 6 of createImageBitmap is not an object.');
            }
        }
        options.rect = {
            sx: types.natural.convert(args[1]),
            sy: types.natural.convert(args[2]),
            sw: types.natural.convert(args[3]),
            sh: types.natural.convert(args[4])
        };
        Object.assign(options, args[5] || {});
    }
    return options;
}
/**
 * @param {object} options
 * @param {(nativeObject: _ImageBitmap) => Promise<any>} cb
 * @returns {Promise<ImageBitmap>}
 */
function load(options, cb) {
    const nativeObject = new _ImageBitmap(options);
    return cb(nativeObject)
        .then(resolution => {
        const wrapper = new ImageBitmap(nativeObject, resolution);
        Object.defineProperty(wrapper, 'wrapper', { value: wrapper });
        return wrapper;
    })
        .catch(message => {
        nativeObject.dispose();
        throw new Error(message);
    });
}

class CanvasContext {
    /**
     * @param {GC} gc
     */
    constructor(gc) {
        Object.defineProperties(this, {
            _gc: { enumerable: false, writable: false, value: gc },
            _state: { enumerable: false, writable: true, value: createState() },
            _savedStates: { enumerable: false, writable: false, value: [] }
        });
        this.canvas = {
            width: 0,
            height: 0,
            style: {}
        };
        for (const name in properties) {
            defineProperty(this, name);
        }
    }
    measureText(text) {
        // TODO: delegate to native function, once it is implemented (#56)
        return { width: text.length * 5 + 5 };
    }
    // ImageData operations
    getImageData(x, y, width, height) {
        checkRequiredArgs(arguments, 4, 'CanvasContext.getImageData');
        this._gc.flush();
        // TODO check validity of args
        const array = this._gc.getImageData(x, y, width, height);
        return new ImageData(array, width, height);
    }
    putImageData(imageData, x, y) {
        checkRequiredArgs(arguments, 3, 'CanvasContext.putImageData');
        this._gc.flush();
        this._gc.putImageData(imageData, x, y);
    }
    createImageData(width, height) {
        if (arguments[0] instanceof ImageData) {
            const data = arguments[0];
            width = data.width;
            height = data.height;
        }
        else {
            checkRequiredArgs(arguments, 2, 'CanvasContext.createImageData');
        }
        return new ImageData(width, height);
    }
    _init(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this._gc.init({ width, height });
    }
}
/** @typedef {{[Key in keyof typeof properties]: any}} State */
Object.defineProperty(CanvasContext.prototype, '_gc', {
    enumerable: false, value: ( /** @type {GC} */(null))
});
Object.defineProperty(CanvasContext.prototype, '_state', {
    enumerable: false, writable: true, value: ( /** @type {State} */(null))
});
Object.defineProperty(CanvasContext.prototype, '_savedStates', {
    enumerable: false, writable: false, value: ( /** @type {State[]} */(null))
});
// State operations
defineMethod('save', 0, /** @this {CanvasContext} */ function () {
    this._savedStates.push(Object.assign({}, this._state));
});
defineMethod('restore', 0, /** @this {CanvasContext} */ function () {
    this._state = this._savedStates.pop() || this._state;
});
// Path operations
defineMethod('beginPath');
defineMethod('closePath');
defineMethod('lineTo', 2, /** @this {CanvasContext} */ function (x, y) {
    this._gc.addDouble(x, y);
});
defineMethod('moveTo', 2, /** @this {CanvasContext} */ function (x, y) {
    this._gc.addDouble(x, y);
});
defineMethod('bezierCurveTo', 6, /** @this {CanvasContext} */ function (cp1x, cp1y, cp2x, cp2y, x, y) {
    this._gc.addDouble(cp1x, cp1y, cp2x, cp2y, x, y);
});
defineMethod('quadraticCurveTo', 4, /** @this {CanvasContext} */ function (cpx, cpy, x, y) {
    this._gc.addDouble(cpx, cpy, x, y);
});
defineMethod('rect', 4, /** @this {CanvasContext} */ function (x, y, width, height) {
    this._gc.addDouble(x, y, width, height);
});
defineMethod('arc', 5, /** @this {CanvasContext} */ function (x, y, radius, startAngle, endAngle, anticlockwise) {
    this._gc.addDouble(x, y, radius, startAngle, endAngle);
    this._gc.addBoolean(!!anticlockwise);
});
defineMethod('arcTo', 5, /** @this {CanvasContext} */ function (x1, y1, x2, y2, radius) {
    this._gc.addDouble(x1, y1, x2, y2, radius);
});
// Transformations
defineMethod('scale', 2, /** @this {CanvasContext} */ function (x, y) {
    this._gc.addDouble(x, y);
});
defineMethod('rotate', 1, /** @this {CanvasContext} */ function (angle) {
    this._gc.addDouble(angle);
});
defineMethod('translate', 2, /** @this {CanvasContext} */ function (x, y) {
    this._gc.addDouble(x, y);
});
defineMethod('transform', 6, /** @this {CanvasContext} */ function (a, b, c, d, e, f) {
    this._gc.addDouble(a, b, c, d, e, f);
});
defineMethod('setTransform', 6, /** @this {CanvasContext} */ function (a, b, c, d, e, f) {
    this._gc.addDouble(a, b, c, d, e, f);
});
// Drawing operations
defineMethod('clearRect', 4, /** @this {CanvasContext} */ function (x, y, width, height) {
    this._gc.addDouble(x, y, width, height);
});
defineMethod('fillRect', 4, /** @this {CanvasContext} */ function (x, y, width, height) {
    this._gc.addDouble(x, y, width, height);
});
defineMethod('strokeRect', 4, /** @this {CanvasContext} */ function (x, y, width, height) {
    this._gc.addDouble(x, y, width, height);
});
defineMethod('fillText', 3, /** @this {CanvasContext} */ function (text, x, y /* , maxWidth */) {
    this._gc.addString(text);
    this._gc.addBoolean(false, false, false);
    this._gc.addDouble(x, y);
});
defineMethod('strokeText', 3, /** @this {CanvasContext} */ function (text, x, y /* , maxWidth */) {
    this._gc.addString(text);
    this._gc.addBoolean(false, false, false);
    this._gc.addDouble(x, y);
});
defineMethod('fill');
defineMethod('stroke');
defineMethod('drawImage', 3, /** @this {CanvasContext} */ function (image, x1, y1, w1, h1, x2, y2, w2, h2) {
    if (!(image instanceof ImageBitmap)) {
        throw new TypeError('First argument of CanvasContext.drawImage must be of type ImageBitmap');
    }
    this._gc.addString(getNativeObject(image).cid);
    if (arguments.length === 9) {
        this._gc.addDouble(x1, y1, w1, h1, x2, y2, w2, h2);
    }
    else if (arguments.length === 5) {
        this._gc.addDouble(0, 0, image.width, image.height, x1, y1, w1, h1);
    }
    else if (arguments.length === 3) {
        this._gc.addDouble(0, 0, image.width, image.height, x1, y1, image.width, image.height);
    }
    else {
        throw new TypeError(arguments.length + ' is not a valid argument count for any overload of Canvas.drawImage.');
    }
});
CanvasContext.getContext = function (canvas, width, height) {
    if (!canvas._gc) {
        const gc = new GC({ parent: canvas });
        canvas.on('dispose', () => gc.dispose());
        Object.defineProperty(canvas, '_gc', {
            enumerable: false,
            writable: false,
            value: gc
        });
    }
    if (!canvas._ctx) {
        Object.defineProperty(canvas, '_ctx', {
            enumerable: false,
            writable: false,
            value: new CanvasContext(canvas._gc)
        });
    }
    canvas._ctx._init(width, height);
    return canvas._ctx;
};
const properties = {
    lineWidth: {
        init: 1,
        encode(value) {
            if (!isNaN(value) && value > 0) {
                return value;
            }
            throw new Error(`Invalid value ${toValueString(value)}`);
        },
        decode: passThrough,
        addOperations(value) {
            this._gc.addDouble(value);
        }
    },
    lineCap: {
        init: 'butt',
        values: toObject(['butt', 'round', 'square']),
        encode: checkValue,
        decode: passThrough,
        addOperations(value) {
            this._gc.addString(value);
        }
    },
    lineJoin: {
        init: 'miter',
        values: toObject(['bevel', 'miter', 'round']),
        encode: checkValue,
        decode: passThrough,
        addOperations(value) {
            this._gc.addString(value);
        }
    },
    fillStyle: {
        init: [0, 0, 0, 255],
        encode: value => Color.from(value).toArray(),
        decode: colorArrayToString,
        addOperations(value) {
            this._gc.addInt(value[0], value[1], value[2], value[3]);
        }
    },
    strokeStyle: {
        init: [0, 0, 0, 255],
        encode: value => Color.from(value).toArray(),
        decode: colorArrayToString,
        addOperations(value) {
            this._gc.addInt(value[0], value[1], value[2], value[3]);
        }
    },
    textAlign: {
        init: 'start',
        values: toObject(['start', 'end', 'left', 'right', 'center']),
        encode: checkValue,
        decode: passThrough,
        addOperations(value) {
            this._gc.addString(value);
        }
    },
    textBaseline: {
        init: 'alphabetic',
        values: toObject(['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom']),
        encode: checkValue,
        decode: passThrough,
        addOperations(value) {
            this._gc.addString(value);
        }
    },
    font: {
        init: { family: ['sans-serif'], size: 12, weight: 'normal', style: 'normal' },
        encode: fontStringToObject,
        decode: fontObjectToString,
        addOperations(font) {
            this._gc.addString(font.family.join(', '), font.style, font.weight);
            this._gc.addDouble(font.size);
        }
    }
};
function passThrough(value) {
    return value;
}
/** @this {{values: any[]}} */
function checkValue(value) {
    if (value in this.values) {
        return value;
    }
    throw new Error(`Invalid value ${toValueString(value)}`);
}
function toObject(array) {
    const obj = {};
    array.forEach((name) => {
        obj[name] = true;
    });
    return obj;
}
function createState() {
    const state = {};
    for (const name in properties) {
        state[name] = properties[name].init;
    }
    return state;
}
/**
 * @param {string} name
 * @param {number=} reqArgCount
 * @param {((this: CanvasContext, ...args: any[]) => any)=} fn
 */
function defineMethod(name, reqArgCount, fn) {
    CanvasContext.prototype[name] = /** @this {CanvasContext} */ function () {
        checkRequiredArgs(arguments, reqArgCount, 'CanvasContext.' + name);
        this._gc.addOperation(name);
        if (fn) {
            fn.apply(this, arguments);
        }
    };
}
function defineProperty(context, name) {
    const prop = properties[name];
    Object.defineProperty(context, name, {
        get() {
            return prop.decode(context._state[name]);
        },
        set(value) {
            try {
                context._state[name] = prop.encode(value);
                context._gc.addOperation(name);
                prop.addOperations.call(context, context._state[name]);
            }
            catch (error$$1) {
                hint(context, 'Unsupported value for ' + name + ': ' + value);
            }
        }
    });
}
function checkRequiredArgs(args, nr, name) {
    if (args.length < nr) {
        throw new Error('Not enough arguments to ' + name);
    }
}

class Printer extends NativeObject {
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('Printer can not be created');
        }
        super._nativeCreate();
    }
    get _nativeType() {
        return 'tabris.Printer';
    }
    print(data, options) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to print');
            }
            if (!isDataValid(data)) {
                throw new Error('data is not an ArrayBuffer or typed array');
            }
            this._nativeCall('print', {
                data: data instanceof ArrayBuffer ? data : data.buffer,
                options,
                onResult: (result) => resolve({ result }),
                onError: (error) => reject(new Error(error))
            });
        });
    }
    dispose() {
        throw new Error('Cannot dispose printer object');
    }
}
function isDataValid(value) {
    return (value instanceof ArrayBuffer) ||
        (value instanceof Int8Array) ||
        (value instanceof Uint8Array) ||
        (value instanceof Uint8ClampedArray) ||
        (value instanceof Int16Array) ||
        (value instanceof Uint16Array) ||
        (value instanceof Int32Array) ||
        (value instanceof Uint32Array) ||
        (value instanceof Float32Array) ||
        (value instanceof Float64Array);
}
function create$1() {
    return new Printer(true);
}

class Permission extends NativeObject {
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('Permission can not be created');
        }
        super._nativeCreate();
    }
    get _nativeType() {
        return 'tabris.Permission';
    }
    getAuthorizationStatus(...permissions) {
        Permission.validatePermissions(permissions, 'get authorization status');
        const result = this._nativeCall('getAuthorizationStatus', { permissions });
        if (!result || result.error) {
            throw new Error(!result ? 'No result returned for getAuthorizationStatus()' : result.error);
        }
        else {
            return result.status;
        }
    }
    isAuthorized(...permissions) {
        Permission.validatePermissions(permissions, 'check if permission is authorized');
        return this.getAuthorizationStatus(...permissions) === 'granted';
    }
    isAuthorizationPossible(...permissions) {
        Permission.validatePermissions(permissions, 'check if authorization is possible');
        const status = this.getAuthorizationStatus(...permissions);
        return status === 'undetermined' || status === 'declined';
    }
    requestAuthorization(...permissions) {
        return new Promise$1((resolve, reject) => {
            Permission.validatePermissions(permissions, 'request permission authorization');
            this._nativeCall('requestAuthorization', {
                permissions,
                onResult: (result) => {
                    if (!result || result.error) {
                        reject(new Error(!result ? 'Authorization could not be requested' : result.error));
                    }
                    else {
                        resolve(result.status);
                    }
                }
            });
        });
    }
    withAuthorization(permission, onAuthorized, onUnauthorized, onError) {
        if (Array.isArray(permission)) {
            if (!permission.every(entry => typeof entry === 'string')) {
                throw new Error('Permissions need to be of type string');
            }
        }
        else if (typeof permission === 'string') {
            permission = [permission];
        }
        else {
            throw new Error('Permission needs to be of type string or an array of strings');
        }
        this.requestAuthorization(...permission)
            .then(status => {
            if (status === 'granted' && typeof onAuthorized === 'function') {
                onAuthorized(status);
            }
            else if (typeof onUnauthorized === 'function') {
                onUnauthorized(status);
            }
        })
            .catch(e => {
            if (typeof onError === 'function') {
                onError(e);
            }
        });
    }
    static validatePermissions(permissions, action) {
        if (permissions.length === 0) {
            throw new Error(`Not enough arguments to ${action}`);
        }
        if (!permissions.every(entry => typeof entry === 'string')) {
            throw new Error('Permissions need to be of type string');
        }
    }
    dispose() {
        throw new Error('Cannot dispose permission object');
    }
}
function create$2() {
    return new Permission(true);
}

class Authentication extends NativeObject {
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('Authentication can not be created');
        }
        super._nativeCreate();
    }
    get _nativeType() {
        return 'tabris.Authentication';
    }
    canAuthenticate(options = {}) {
        checkType(options.allowCredentials, Boolean, { name: 'allowCredentials', nullable: true });
        return this._nativeCall('canAuthenticate', options);
    }
    authenticate(options = {}) {
        return new Promise$1((resolve, reject) => {
            checkType(options.title, String, { name: 'title', nullable: true });
            checkType(options.subtitle, String, { name: 'subtitle', nullable: true });
            checkType(options.message, String, { name: 'message', nullable: true });
            checkType(options.allowCredentials, Boolean, { name: 'allowCredentials', nullable: true });
            checkType(options.confirmationRequired, Boolean, { name: 'confirmationRequired', nullable: true });
            this._nativeCall('authenticate', {
                options,
                onResult: (result) => resolve(result),
                onError: (error) => reject(new Error(error))
            });
        });
    }
    cancel() {
        this._nativeCall('cancel');
    }
    dispose() {
        throw new Error('Cannot dispose authentication object');
    }
}
NativeObject.defineProperties(Authentication.prototype, {
    availableBiometrics: { readonly: true }
});
function create$3() {
    return new Authentication(true);
}

class File extends Blob {
    /**
     * @param {Array} chunks
     * @param {string} name
     * @param {Object=} options
     */
    constructor(chunks, name, options = {}) {
        if (arguments.length < 2) {
            throw new TypeError(`File requires at least 2 arguments, but only ${arguments.length} were passed.`);
        }
        super(chunks, options);
        Object.defineProperty(this, 'name', { value: name + '' });
        const lastModified = 'lastModified' in options ? options.lastModified : Date.now();
        if (isNaN(lastModified) || !isFinite(lastModified)) {
            Object.defineProperty(this, 'lastModified', { value: 0 });
        }
        else {
            Object.defineProperty(this, 'lastModified', {
                value: Math.round(typeof lastModified === 'string' ? parseInt(lastModified) : 0 + lastModified)
            });
        }
    }
}
File.prototype[Symbol.toStringTag] = 'File';
Object.defineProperty(File.prototype, 'name', { value: '' });
Object.defineProperty(File.prototype, 'lastModified', { value: 0 });

const CERTIFICATE_ALGORITHMS = ['RSA2048', 'RSA4096', 'ECDSA256'];
class App extends NativeObject {
    get _nativeType() {
        return 'tabris.App';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('App can not be created');
        }
        super._nativeCreate();
        this._nativeSet('encodeColor', (color) => types.ColorValue.encode(types.ColorValue.convert(color)));
        this._nativeSet('encodeFont', (font) => types.FontValue.encode(types.FontValue.convert(font)));
    }
    /**
     * @override
     * @param {string} name
     */
    _beforePropertyChange(name) {
        if (name === 'pinnedCertificates') {
            this.on('certificatesReceived', this._validateCertificate, this);
        }
    }
    get id() {
        return this._nativeGet('appId');
    }
    get debugBuild() {
        return this._nativeGet('debugBuild');
    }
    get version() {
        return this._nativeGet('version');
    }
    get versionCode() {
        return this._nativeGet('versionId');
    }
    launch(url) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to launch');
            }
            if (typeof url !== 'string') {
                throw new Error(`Invalid url: ${toValueString(url)} is not a string`);
            }
            this._nativeCall('launch', {
                url,
                onError: (err) => reject(new Error(err)),
                onSuccess: () => resolve()
            });
        });
    }
    share(data) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('The share functions requires a data object');
            }
            if (typeof data !== 'object'
                || (data.text == null && data.title == null && data.url == null && data.files == null)) {
                throw new TypeError(`Invalid data object: ${JSON.stringify(data)}. At least one of title, text, url or files is required`);
            }
            this._nativeCall('share', {
                data: this._prepareShareData(data),
                onSuccess: (target) => resolve(target),
                onError: (err) => reject(new Error(err))
            });
        });
    }
    _prepareShareData(data) {
        const shareData = {};
        if (data.title) {
            shareData.title = String(data.title);
        }
        if (data.text) {
            shareData.text = String(data.text);
        }
        if (data.url) {
            shareData.url = String(data.url);
        }
        if (data.files) {
            if (!Array.isArray(data.files)) {
                throw new Error('The share data "files" is not an array');
            }
            if (!data.files.every((file) => file instanceof File)) {
                throw new Error('The share data "files" array can only contain File objects');
            }
            shareData.files = data.files.map(file => ({ name: file.name, type: file.type, data: getBytes(file) }));
        }
        return shareData;
    }
    getResourceLocation(path) {
        if (!this._resourceBaseUrl) {
            Object.defineProperty(this, '_resourceBaseUrl', {
                enumerable: false, writable: false, value: this._nativeGet('resourceBaseUrl')
            });
        }
        const subPath = path != null ? '/' + normalizePath$1('' + path) : '';
        return this._resourceBaseUrl + subPath;
    }
    dispose() {
        throw new Error('tabris.app can not be disposed');
    }
    reload(url) {
        this._nativeCall('reload', { url });
    }
    close() {
        this._nativeCall('close');
    }
    registerFont(alias, file) {
        if (arguments.length < 2) {
            throw new Error('Not enough arguments to register a font');
        }
        if (typeof alias !== 'string') {
            throw new Error(`Invalid alias: ${toValueString(alias)} is not a string`);
        }
        if (typeof file !== 'string') {
            throw new Error(`Invalid file path: ${toValueString(file)} is not a string`);
        }
        this._nativeCall('registerFont', { alias, file });
    }
    _validateCertificate(event) {
        const hashes = this.$pinnedCerts[event.host];
        if (hashes && !hashes.some(hash => event.hashes.includes(hash))) {
            event.preventDefault();
        }
    }
    get $pinnedCerts() {
        const certificates = this.pinnedCertificates;
        const hashes = {};
        for (const cert of certificates) {
            hashes[cert.host] = hashes[cert.host] || [];
            hashes[cert.host].push(cert.hash);
        }
        return hashes;
    }
}
NativeObject.defineProperties(App.prototype, {
    pinnedCertificates: {
        type: {
            convert: certificates => Object.freeze(certificates),
            encode(certificates) {
                // Do checks here instead of in convert to force an exception instead of a warning
                if (!Array.isArray(certificates)) {
                    throw new Error('Not an Array');
                }
                for (const cert of certificates) {
                    if (typeof cert.host !== 'string') {
                        throw new Error(`Invalid host ${toValueString(cert.host)}`);
                    }
                    if (typeof cert.hash !== 'string' || !cert.hash.startsWith('sha256/')) {
                        throw new Error(`Invalid hash ${toValueString(cert.hash)} for pinned certificate ${cert.host}`);
                    }
                    if (tabris.device.platform === 'iOS') {
                        if (!('algorithm' in cert)) {
                            throw new Error(`Missing algorithm for pinned certificate ${cert.host}`);
                        }
                        if (typeof cert.algorithm !== 'string' || CERTIFICATE_ALGORITHMS.indexOf(cert.algorithm) === -1) {
                            throw new Error(`Invalid algorithm ${toValueString(cert.algorithm)} for pinned certificate ${cert.host}`);
                        }
                    }
                }
                return certificates;
            }
        },
        default: Object.freeze([])
    },
    trustedCertificates: {
        type: {
            convert: certificates => Object.freeze(certificates),
            encode(value) {
                // Do checks here instead of in convert to force an exception instead of a warning
                if (!Array.isArray(value)) {
                    throw new Error('Not an Array');
                }
                for (let i = 0; i < value.length; i++) {
                    const certificate = value[i];
                    if (!(certificate instanceof ArrayBuffer)) {
                        throw new Error(`certificate entry ${toValueString(certificate)} is not an ArrayBuffer`);
                    }
                }
                return value;
            }
        },
        default: Object.freeze([])
    },
    idleTimeoutEnabled: {
        type: {
            convert(value) {
                if (!tabris.contentView) {
                    throw new Error('The device property "idleTimeoutEnabled" can only be changed in main context.');
                }
                return types.boolean.convert(value);
            }
        },
        default: true
    }
});
NativeObject.defineEvents(App.prototype, {
    foreground: { native: true },
    background: { native: true },
    pause: { native: true },
    resume: { native: true },
    terminate: { native: true },
    keyPress: { native: true },
    backNavigation: { native: true },
    certificatesReceived: { native: true }
});
function create$4() {
    return new App(true);
}
function normalizePath$1(path) {
    return path.split(/\/+/).map((segment) => {
        if (segment === '..') {
            throw new Error(`Path ${toValueString(path)} must not contain ".."`);
        }
        if (segment === '.') {
            return '';
        }
        return segment;
    }).filter(string => !!string).join('/');
}

const ERRORS = {
    EACCES: 'Permission denied',
    EEXIST: 'File exists',
    ENOENT: 'No such file or directory',
    EISDIR: 'Is a directory',
    ENOTDIR: 'Not a directory',
    ENOTEMPTY: 'Directory not empty'
};
class FileSystem extends NativeObject {
    get _nativeType() {
        return 'tabris.FileSystem';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('FileSystem can not be created');
        }
        super._nativeCreate();
    }
    get filesDir() {
        return this._nativeGet('filesDir');
    }
    get cacheDir() {
        return this._nativeGet('cacheDir');
    }
    get externalFileDirs() {
        return this._nativeGet('externalFileDirs');
    }
    get externalCacheDirs() {
        return this._nativeGet('externalCacheDirs');
    }
    readFile(path, encoding) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to readFile');
            }
            this._nativeCall('readFile', {
                path: checkPath(path, 'file name'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: (data) => encoding ? TextDecoder.decode(data, encoding).then(resolve, reject) : resolve(data)
            });
        });
    }
    openFile(options) {
        return new Promise$1((resolve, reject) => {
            let optionsObject = {};
            if (arguments.length >= 1) {
                if (!(options instanceof Object)) {
                    throw new Error('Options need to be an Object');
                }
                const type = 'type' in options ? options.type : '*/*';
                if (typeof type !== 'string') {
                    throw new Error(`Invalid type: ${toValueString(type)} is not a string`);
                }
                const quantity = 'quantity' in options ? options.quantity : 'single';
                if (typeof quantity !== 'string') {
                    throw new Error(`Invalid quantity: ${toValueString(quantity)} is not a string`);
                }
                if (quantity !== 'single' && quantity !== 'multiple') {
                    throw new Error(`Quantity has to be "single" or "multiple" but is ${toValueString(quantity)}`);
                }
                optionsObject = { type, quantity };
            }
            this._nativeCall('openFile', {
                options: optionsObject,
                onSuccess: result => {
                    if (Array.isArray(result) && result.length > 0) {
                        resolve(result.map(entry => new File([entry.data], entry.name, {
                            type: entry.type,
                            lastModified: entry.lastModified
                        })));
                    }
                    else {
                        resolve([]);
                    }
                },
                onError: message => reject(new Error(message))
            });
        });
    }
    writeFile(path, data, encoding) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 2) {
                throw new Error('Not enough arguments to writeFile');
            }
            const write = finalData => this._nativeCall('writeFile', {
                path: checkPath(path, 'file name'),
                data: checkBuffer(finalData),
                onError: (err) => reject(createError(err, path)),
                onSuccess: () => resolve()
            });
            if (typeof data === 'string') {
                TextEncoder.encode(data, encoding || 'utf-8').then(write, reject);
            }
            else {
                write(data);
            }
        });
    }
    appendToFile(path, data, encoding) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 2) {
                throw new Error('Not enough arguments to appendToFile');
            }
            const write = finalData => this._nativeCall('appendToFile', {
                path: checkPath(path, 'file name'),
                data: checkBuffer(finalData),
                onError: (err) => reject(createError(err, path)),
                onSuccess: (fileCreated) => resolve(fileCreated)
            });
            if (typeof data === 'string') {
                TextEncoder.encode(data, encoding || 'utf-8').then(write, reject);
            }
            else {
                write(data);
            }
        });
    }
    removeFile(path) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to removeFile');
            }
            this._nativeCall('removeFile', {
                path: checkPath(path, 'file name'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: () => resolve()
            });
        });
    }
    readDir(path) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to readDir');
            }
            this._nativeCall('readDir', {
                path: checkPath(path, 'directory'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: (data) => resolve(data)
            });
        });
    }
    createDir(path) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to createDir');
            }
            this._nativeCall('createDir', {
                path: checkPath(path, 'directory'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: () => resolve()
            });
        });
    }
    removeDir(path) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to removeDir');
            }
            this._nativeCall('removeDir', {
                path: checkPath(path, 'directory'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: () => resolve()
            });
        });
    }
    remove(path) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to remove');
            }
            this._nativeCall('remove', {
                path: checkPath(path, 'file or directory'),
                onError: (err) => reject(createError(err, path)),
                onSuccess: (success) => resolve(success)
            });
        });
    }
    isFile(path) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to isFile');
        }
        return this._nativeCall('isFile', {
            path: checkPath(path, 'file name')
        });
    }
    isDir(path) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to isDir');
        }
        return this._nativeCall('isDir', {
            path: checkPath(path, 'directory')
        });
    }
    dispose() {
        throw new Error('Cannot dispose fs object');
    }
}
function create$5() {
    return new FileSystem(true);
}
function createError(err, path) {
    const message = `${ERRORS[err] || err}: ${path}`;
    const code = err in ERRORS ? err : null;
    const error$$1 = new Error(message);
    Object.defineProperties(error$$1, {
        path: { value: path },
        code: { value: code }
    });
    return error$$1;
}
function checkPath(path, type) {
    try {
        return normalizePath(path);
    }
    catch (err) {
        throw new Error(`${toValueString(path)} is not a valid ${type}. ${err.message}`);
    }
}
function checkBuffer(buffer) {
    if (ArrayBuffer.isView(buffer)) {
        buffer = buffer.buffer;
    }
    if (buffer instanceof Blob) {
        return getBytes(buffer);
    }
    if (!(buffer instanceof ArrayBuffer)) {
        throw new Error(`${toValueString(buffer)} is not an ArrayBuffer`);
    }
    return buffer;
}

class DevTools extends NativeObject {
    get _nativeType() {
        return 'tabris.DevTools';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('DevTools can not be created');
        }
        super._nativeCreate();
    }
    showUi() {
        return this._nativeCall('showUi');
    }
    hideUi() {
        this._nativeCall('hideUi');
    }
    isUiVisible() {
        return this._nativeCall('isUiVisible');
    }
    dispose() {
        throw new Error('Cannot dispose devTools object');
    }
}
function create$6() {
    return new DevTools(true);
}

const PHASE_CONSTANTS = {
    NONE: { value: 0 },
    CAPTURING_PHASE: { value: 1 },
    AT_TARGET: { value: 2 },
    BUBBLING_PHASE: { value: 3 }
};
class Event {
    constructor(type, config) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to Event');
        }
        Object.defineProperties(this, {
            $timeStamp: { enumerable: false, writable: true, value: Date.now() },
            $type: { enumerable: false, writable: true, value: type || '' },
            $bubbles: { enumerable: false, writable: true, value: config && !!config.bubbles || false },
            $cancelable: { enumerable: false, writable: true, value: config && !!config.cancelable || false },
            $target: { enumerable: false, writable: true, value: null },
            $defaultPrevented: { enumerable: false, writable: true, value: false }
        });
    }
    initEvent(type, bubbles, cancelable) {
        if (arguments.length < 3) {
            throw new Error('Not enough arguments to initEvent');
        }
        this.$type = type + '';
        this.$bubbles = !!bubbles;
        this.$cancelable = !!cancelable;
    }
    get type() {
        return this.$type;
    }
    get timeStamp() {
        return this.$timeStamp;
    }
    get bubbles() {
        return this.$bubbles;
    }
    get cancelable() {
        return this.$cancelable;
    }
    get target() {
        return this.$target;
    }
    get currentTarget() {
        return this.$target;
    }
    get defaultPrevented() {
        return this.$defaultPrevented;
    }
    get eventPhase() {
        return 0;
    }
    get isTrusted() {
        return false;
    }
    stopPropagation() {
    }
    stopImmediatePropagation() {
    }
    preventDefault() {
        if (this.$cancelable) {
            this.$defaultPrevented = true;
        }
    }
}
Object.defineProperties(Event, PHASE_CONSTANTS);
Object.defineProperties(Event.prototype, PHASE_CONSTANTS);
function addDOMEventTargetMethods(target) {
    if (typeof target.addEventListener === 'function') {
        return;
    }
    let listeners;
    target.addEventListener = function (type, listener /* , useCapture*/) {
        if (arguments.length < 2) {
            throw new Error('Not enough arguments to addEventListener');
        }
        if (!listeners) {
            listeners = [];
        }
        if (!(type in listeners)) {
            listeners[type] = [];
        }
        if (!listeners[type].includes(listener)) {
            listeners[type].push(listener);
        }
    };
    target.removeEventListener = function (type, listener /* , useCapture */) {
        if (arguments.length < 2) {
            throw new Error('Not enough arguments to removeEventListener');
        }
        if (listeners && type in listeners) {
            const index = listeners[type].indexOf(listener);
            if (index !== -1) {
                listeners[type].splice(index, 1);
            }
        }
    };
    target.dispatchEvent = function (event) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to dispatchEvent');
        }
        if (!(event instanceof Event)) {
            throw new Error('Invalid event given to dispatchEvent');
        }
        event.$target = target;
        if (listeners && event.type in listeners) {
            for (const listener of listeners[event.type]) {
                listener.call(this, event);
            }
        }
        return !event.defaultPrevented;
    };
}
function defineEventHandlerProperties(target, types) {
    types.forEach(type => defineEventHandlerProperty(target, type));
}
function defineEventHandlerProperty(target, type) {
    const handler = 'on' + type;
    let listener = null;
    Object.defineProperty(target, handler, {
        get() {
            return listener;
        },
        set(value) {
            // ignore other types, mimicks the behavior of Firefox and Chromium
            if (typeof value === 'function') {
                if (listener) {
                    target.removeEventListener(type, listener);
                }
                listener = value;
                target.addEventListener(type, listener);
            }
        }
    });
}

function addDOMDocument(target) {
    class HTMLElement {
        constructor(tagName) {
            this.tagName = (tagName || '').toUpperCase();
            this.children = [];
        }
        setAttribute() {
        }
        appendChild(el) {
            this.children.push(el);
            handleElementInserted(this, el, target);
            return el;
        }
        cloneNode() {
            return new HTMLElement();
        }
        lastChild() {
            return new HTMLElement();
        }
    }
    target.document = {
        documentElement: {},
        createDocumentFragment() { return new HTMLElement(); },
        createElement(tagName) { return new HTMLElement(tagName); },
        location: { href: '' },
        readyState: 'loading',
        head: new HTMLElement('head'),
        getElementsByTagName(tagName) {
            return this.head.children.filter(node => node.tagName === tagName.toUpperCase());
        },
        createEvent(type) {
            return new Event(type);
        }
    };
    addDOMEventTargetMethods(target.document);
    if (typeof target.location === 'undefined') {
        target.location = target.document.location;
    }
    tabris.once('start', () => {
        target.document.readyState = 'complete';
        const event = new Event('DOMContentLoaded', false, false);
        target.document.dispatchEvent(event);
    });
}
function handleElementInserted(parent, child, target) {
    if (parent.tagName === 'HEAD' && child.tagName === 'SCRIPT' && child.src) {
        let result;
        try {
            result = tabris._client.loadAndExecute(child.src, '', '');
        }
        catch (ex) {
            error('Error loading ' + child.src + ':', ex);
            log(ex.stack);
            if (typeof child.onerror === 'function') {
                child.onerror.call(target, ex);
            }
            return;
        }
        if (result.loadError) {
            if (typeof child.onerror === 'function') {
                child.onerror.call(target, new Error('Could not load ' + child.src));
            }
        }
        else if (typeof child.onload === 'function') {
            child.onload.call(target);
        }
    }
}

function addWindowTimerMethods(target) {
    if (typeof target.setTimeout === 'function') {
        return;
    }
    let idSequence = 0;
    function createTimer(fn, delay, repeat, args) {
        const id = idSequence++;
        // If tabris is not ready, create the timer on load.
        // However, clearTimeout won't work until after load.
        const create = () => tabris.app._nativeCall('startTimer', {
            id, delay, repeat, callback: createNativeCallback(fn, target, args)
        });
        if (tabris.started) {
            create();
        }
        else {
            tabris.once('start', create);
        }
        return id;
    }
    target.setTimeout = function (fn, delay) {
        if (arguments.length < 1) {
            throw new TypeError('Not enough arguments to setTimeout');
        }
        if (typeof fn !== 'function') {
            throw new TypeError('Illegal argument to setTimeout: not a function');
        }
        const args = Array.prototype.slice.call(arguments, 2);
        return createTimer(fn, adjustDelay(delay), false, args);
    };
    target.setInterval = function (fn, delay) {
        if (arguments.length < 1) {
            throw new TypeError('Not enough arguments to setInterval');
        }
        if (typeof fn !== 'function') {
            throw new TypeError('Illegal argument to setInterval: not a function');
        }
        const args = Array.prototype.slice.call(arguments, 2);
        return createTimer(fn, adjustDelay(delay), true, args);
    };
    target.clearTimeout = target.clearInterval = id => tabris.app._nativeCall('cancelTimer', { id });
}
function adjustDelay(value) {
    return typeof value === 'number' && isFinite(value) ? Math.max(0, Math.round(value)) : 0;
}

class NativeStore extends NativeObject {
    constructor(secure) {
        super(secure);
    }
    get keys() {
        return this._nativeCall('keys');
    }
    /** @override */
    _nativeCreate(secure) {
        this.secure = secure;
        super._nativeCreate();
    }
    get _nativeType() {
        return this.secure ? 'tabris.SecureStore' : 'tabris.ClientStore';
    }
    _getXMLElementName() {
        return 'Storage';
    }
    _getXMLAttributes() {
        return [['length', this.keys.length]];
    }
    _getXMLContent() {
        return this.keys.map(key => {
            const value = this._nativeCall('get', { key });
            const item = key.replace(/[^a-zA-Z0-9_.:-]/g, '');
            const lines = value.split('\n');
            if (lines.length === 1) {
                return `  <${item}>${value}</${item}>`;
            }
            return `  <${item}>\n${lines.map(line => '    ' + line).join('\n')}\n  </${item}>`;
        });
    }
}
class Storage {
    constructor() {
        const nativeObject = arguments[0];
        if (!(nativeObject instanceof NativeObject)) {
            throw new Error('Cannot instantiate Storage');
        }
        Object.defineProperty(this, '_nativeObject', { value: nativeObject });
    }
    // Note: key and length methods currently not supported
    setItem(key, value) {
        if (arguments.length < 2) {
            throw new TypeError('Not enough arguments to \'setItem\'');
        }
        this._nativeObject._nativeCall('add', {
            key: encode(key),
            value: encode(value)
        });
    }
    getItem(key) {
        if (arguments.length < 1) {
            throw new TypeError('Not enough arguments to \'getItem\'');
        }
        const result = this._nativeObject._nativeCall('get', { key: encode(key) });
        // Note: iOS can not return null, only undefined:
        return result === undefined ? null : result;
    }
    removeItem(key) {
        if (arguments.length < 1) {
            throw new TypeError('Not enough arguments to \'removeItem\'');
        }
        this._nativeObject._nativeCall('remove', { keys: [encode(key)] });
    }
    clear() {
        this._nativeObject._nativeCall('clear');
    }
    key(index) {
        return this._nativeObject.keys[index] || null;
    }
    [toXML$1]() {
        return this._nativeObject[toXML$1]();
    }
    get length() {
        return this._nativeObject.keys.length;
    }
}
function encode(value) {
    return '' + value;
}
function create$7(secure) {
    return new Storage(new NativeStore(secure));
}

class Action extends Widget {
    get _nativeType() {
        return 'tabris.Action';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([['title', this.title]]);
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'title'));
    }
}
NativeObject.defineProperties(Action.prototype, {
    image: { type: types.ImageValue, default: null },
    placement: {
        type: types.string,
        choice: ['default', 'navigation', 'overflow'],
        default: 'default'
    },
    title: { type: types.string, default: '' }
});
NativeObject.defineEvents(Action.prototype, {
    select: { native: true }
});

class Popup extends NativeObject {
    open() {
        if (this.isDisposed()) {
            throw new Error('Can not open a popup that was disposed');
        }
        this._nativeCall('open');
        return this;
    }
    close() {
        if (this._autoDispose) {
            this.dispose();
        }
        return this;
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        return this.createNativeObject(Type, attributes);
    }
}

class ActionSheet extends Popup {
    static open(actionSheet) {
        if (!(actionSheet instanceof ActionSheet)) {
            throw new Error('Not an ActionSheet: ' + toValueString(actionSheet));
        }
        return actionSheet.open();
    }
    /**
     * @param {Partial<ActionSheet>} properties
     */
    constructor(properties) {
        super(properties);
        Object.defineProperties(this, {
            _index: { enumerable: false, writable: true, value: null },
            _action: { enumerable: false, writable: true, value: null }
        });
        this._autoDispose = true;
        this._nativeListen('select', true);
    }
    get _nativeType() {
        return 'tabris.ActionSheet';
    }
    _trigger(name, event) {
        if (name === 'select') {
            this._index = event.index;
            this._action = this.actions[this._index];
            super._trigger('select', Object.assign(event, { action: this._action }));
        }
        else if (name === 'close') {
            super._trigger('close', Object.assign(event, { index: this._index, action: this._action }));
            this.dispose();
        }
        else {
            return super._trigger(name, event);
        }
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes) || [];
        let normalAttributes = this.withoutChildren(attributes);
        normalAttributes = this.withContentChildren(normalAttributes, children.filter(child => child instanceof Object), 'actions');
        normalAttributes = this.withContentText(normalAttributes, children.filter(child => !(child instanceof Object)), 'message');
        return this.createNativeObject(Type, normalAttributes);
    }
}
NativeObject.defineProperties(ActionSheet.prototype, {
    title: { type: types.string, default: '' },
    message: { type: types.string, default: '' },
    actions: /** @type {TabrisProp<readonly ActionSheetItem[], ActionSheetItem[]>} */ ({
        type: {
            convert(value) {
                if (!Array.isArray(value)) {
                    throw new Error(toValueString(value) + ' is not an array');
                }
                return Object.freeze(value.map(ActionSheetItem.from));
            },
            encode(value) {
                return value.map(action => ({
                    title: action.title,
                    image: types.ImageValue.encode(action.image),
                    style: action.style
                }));
            }
        },
        default: Object.freeze([])
    })
});
NativeObject.defineEvents(ActionSheet.prototype, {
    close: { native: true },
    select: { native: true }
});
class ActionSheetItem {
    /**
     * @param {{title?: any, image?: any, style?: any}} param0
     */
    constructor({ title, image, style } = {}) {
        Object.defineProperty(this, 'title', { value: types.string.convert(title), enumerable: true });
        Object.defineProperty(this, 'image', { value: types.ImageValue.convert(image), enumerable: true });
        Object.defineProperty(this, 'style', {
            value: allowOnlyValues(style || 'default', ['default', 'cancel', 'destructive'], 'style'),
            enumerable: true
        });
    }
    toString() {
        return this.title || '[object ActionSheetItem]';
    }
    /** @this {import("./JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return new Type(this.withContentText(normalAttributes, children, 'title'));
    }
    /**
     * @param {any} value
     */
    static from(value) {
        if (value instanceof ActionSheetItem) {
            return value;
        }
        if (value.constructor !== Object) {
            throw new Error('Can not convert a non-object to an ActionSheetItem');
        }
        try {
            return new ActionSheetItem(allowOnlyKeys(value, ['title', 'image', 'style']));
        }
        catch (ex) {
            throw new Error('Can not convert to an ActionSheetItem: ' + ex.message);
        }
    }
}
Object.defineProperty(ActionSheetItem.prototype, 'title', { value: '' });
Object.defineProperty(ActionSheetItem.prototype, 'image', {
    value: /** @type {import('./Image').default} */ (null)
});
Object.defineProperty(ActionSheetItem.prototype, 'style', {
    value: /** @type {'default'|'cancel'|'destructive'} */ ('default')
});

class ActivityIndicator extends Widget {
    get _nativeType() {
        return 'tabris.ActivityIndicator';
    }
}
NativeObject.defineProperties(ActivityIndicator.prototype, {
    tintColor: { type: 'ColorValue', default: 'initial' }
});

class TextInput extends Widget {
    get _nativeType() {
        return 'tabris.TextInput';
    }
    _getXMLContent() {
        let content = super._getXMLContent();
        if (this._shouldPrintTextAsXMLContent()) {
            content = content.concat(this.text.split('\n').map(line => '  ' + line));
        }
        return content;
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (this.type !== 'default') {
            result.push(['type', this.type]);
        }
        if (!this._shouldPrintTextAsXMLContent()) {
            result.push(['text', this.text]);
        }
        if (this.message) {
            result.push(['message', this.message]);
        }
        if (!this.editable) {
            result.push(['editable', 'false']);
        }
        if (this.focused) {
            result.push(['focused', 'true']);
        }
        if (this.keepFocus) {
            result.push(['keepFocus', 'true']);
        }
        return result;
    }
    _shouldPrintTextAsXMLContent() {
        return this.text.length > 25 || this.text.indexOf('\n') !== -1;
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text'));
    }
}
NativeObject.defineProperties(TextInput.prototype, {
    type: {
        type: types.string,
        choice: ['default', 'password', 'search', 'multiline'],
        const: true,
        default: 'default'
    },
    style: {
        type: types.string,
        choice: ['default', 'outline', 'fill', 'underline', 'none'],
        const: true,
        default: 'default'
    },
    text: { type: types.string, nocache: true },
    message: { type: types.string, default: '' },
    floatMessage: { type: types.boolean, default: true },
    editable: { type: types.boolean, default: true },
    maxChars: {
        type: {
            convert: value => value <= 0 ? null : types.natural.convert(value)
        },
        default: null,
        nullable: true
    },
    keepFocus: { type: types.boolean, default: false },
    alignment: {
        type: types.string,
        choice: ['left', 'centerX', 'right'],
        default: 'left'
    },
    autoCorrect: { type: types.boolean, default: false },
    autoCapitalize: {
        type: { convert: v => v === true ? 'all' : v || 'none' },
        choice: ['none', 'sentence', 'word', 'all'],
        default: false
    },
    keyboard: {
        type: types.string,
        choice: ['ascii', 'decimal', 'email', 'number', 'numbersAndPunctuation', 'phone', 'url', 'default'],
        default: 'default'
    },
    enterKeyType: {
        type: types.string,
        choice: ['default', 'done', 'next', 'send', 'search', 'go'],
        default: 'default'
    },
    messageColor: { type: types.ColorValue, default: 'initial' },
    focused: { type: types.boolean, nocache: true },
    borderColor: { type: types.ColorValue, default: 'initial' },
    textColor: { type: types.ColorValue, default: 'initial' },
    revealPassword: { type: types.boolean, default: false },
    cursorColor: { type: types.ColorValue, default: 'initial' },
    selection: {
        type: {
            convert(value, textInput) {
                if (!(value instanceof Array) || value.length !== 2) {
                    throw new Error(`Selection has to be a two element array with start and end position but is ${toValueString(value)}`);
                }
                const textLength = textInput.text.length;
                const result = value.map(num => types.number.convert(num));
                if (result[1] > textLength || result[0] > textLength || result[1] < 0 || result[0] < 0) {
                    throw new Error(`The selection has to be in the range of 0 to text length [0-${textLength}] but is ${value}`);
                }
                return Object.freeze(result);
            }
        },
        nocache: true
    },
    font: { type: types.FontValue, default: 'initial' },
    keyboardAppearanceMode: {
        type: types.string,
        choice: ['never', 'ontouch', 'onfocus'],
        default: 'onfocus'
    }
});
NativeObject.defineEvents(TextInput.prototype, {
    focus: { native: true, changes: 'focused', changeValue: () => true },
    blur: { native: true, changes: 'focused', changeValue: () => false },
    accept: { native: true },
    input: { native: true, changes: 'text' },
    beforeTextChange: { native: true },
    select: { native: true, changes: 'selection' }
});

class ContentView extends Composite {
    /** @override */
    _nativeCreate(properties) {
        if (!properties || properties[creationAllowed] !== true) {
            throw new Error('ContentView can not be created');
        }
        Object.defineProperties(this, {
            _childType: { enumerable: false, writable: false, value: properties.childType },
            _phantom: { enumerable: false, writable: false, value: properties.phantom }
        });
        delete properties[creationAllowed];
        delete properties.childType;
        delete properties.phantom;
        if (this._phantom) {
            this._register();
            this._initLayout(properties);
        }
        else {
            super._nativeCreate(properties);
        }
    }
    /** @override */
    _nativeSet(name, value) {
        if (!this._phantom) {
            super._nativeSet(name, value);
        }
    }
    /** @override */
    _nativeGet(name) {
        if (!this._phantom) {
            return super._nativeGet(name);
        }
    }
    /** @override */
    _nativeListen(event, state) {
        if (!this._phantom) {
            return super._nativeListen(event, state);
        }
    }
    /** @override */
    _nativeCall(method, properties) {
        if (!this._phantom) {
            return super._nativeCall(method, properties);
        }
    }
    /** @override */
    _acceptChild(child) {
        if (!this._childType) {
            return true;
        }
        return child instanceof this._childType;
    }
    _setParent(parent, index) {
        if (this._parent) {
            throw new Error('Parent of ContentView can not be changed');
        }
        super._setParent(parent, index);
    }
    _dispose() {
        throw new Error('ContentView can not be disposed');
    }
}
function create$8(properties) {
    return new ContentView(Object.assign({ [creationAllowed]: true }, properties));
}

class AlertDialog extends Popup {
    static open(value) {
        let alertDialog;
        if (value instanceof AlertDialog) {
            alertDialog = value;
        }
        else {
            alertDialog = new AlertDialog({ message: value, buttons: { ok: 'OK' } });
        }
        return alertDialog.open();
    }
    constructor(properties) {
        super(properties);
        this._nativeListen('close', true);
        this._autoDispose = true;
    }
    get _nativeType() {
        return 'tabris.AlertDialog';
    }
    get textInputs() {
        if (!this._contentView) {
            Object.defineProperty(this, '_contentView', {
                enumerable: false,
                writable: false,
                value: create$8({
                    layout: null,
                    childType: TextInput,
                    phantom: true
                })
            });
        }
        return this._contentView;
    }
    set textInputs(value) {
        hint(this, 'Property "textInputs" can not be set, append to it instead');
    }
    open() {
        if (!this.isDisposed() && this._contentView) {
            this._nativeSet('textInputs', this._contentView.children().toArray().map(object => object.cid));
        }
        return super.open();
    }
    _trigger(name, event) {
        if (name === 'close') {
            event.button = event.button || null;
            event.texts = [];
            if (this._contentView) {
                event.texts = this._contentView.children().toArray().map(textInput => textInput.text);
            }
            if (event.button) {
                super._trigger('close' + capitalizeFirstChar(event.button), event);
            }
            super._trigger('close', event);
            this.dispose();
        }
        else {
            return super._trigger(name, event);
        }
    }
    _dispose() {
        if (!this.isDisposed() && this._contentView) {
            Composite.prototype._dispose.call(this._contentView, true);
        }
        super._dispose();
    }
}
NativeObject.defineProperties(AlertDialog.prototype, {
    title: { type: types.string, default: '' },
    message: { type: types.string, default: '' },
    buttons: {
        type: {
            convert(value) {
                allowOnlyKeys(value, ['ok', 'cancel', 'neutral']);
                const result = {};
                if ('ok' in value) {
                    result.ok = value.ok + '';
                }
                if ('cancel' in value) {
                    result.cancel = value.cancel + '';
                }
                if ('neutral' in value) {
                    result.neutral = value.neutral + '';
                }
                return Object.freeze(result);
            }
        },
        default: Object.freeze({})
    }
});
NativeObject.defineEvents(AlertDialog.prototype, {
    close: true,
    closeOk: true,
    closeCancel: true,
    closeNeutral: true
});
AlertDialog.prototype[JSX.jsxFactory] = createElement$2;
/** @this {import("./JsxProcessor").default} */
function createElement$2(Type, attributes) {
    const children = this.getChildren(attributes) || [];
    let normalAttributes = this.withoutChildren(attributes);
    normalAttributes = this.withContentText(normalAttributes, children.filter(child => !(child instanceof Object)), 'message');
    const textInputs = children.filter(child => child instanceof Object);
    const result = Popup.prototype[JSX.jsxFactory].call(this, Type, normalAttributes);
    if (children && children.length) {
        result.textInputs.append(textInputs);
    }
    return result;
}

class Button extends Widget {
    /**
     * @param {Partial<Button>=} properties
     */
    constructor(properties) {
        super(Object.assign({ style: 'default' }, properties));
    }
    get _nativeType() {
        return 'tabris.Button';
    }
    /**
     * @param {string[]} properties
     */
    _reorderProperties(properties) {
        const styleIndex = properties.indexOf('style');
        if (styleIndex === -1) {
            return super._reorderProperties(properties);
        }
        return super._reorderProperties(['style']
            .concat(properties.slice(0, styleIndex))
            .concat(properties.slice(styleIndex + 1)));
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([['text', this.text]]);
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text'));
    }
}
NativeObject.defineProperties(Button.prototype, {
    style: {
        type: types.string,
        choice: ['default', 'elevate', 'flat', 'outline', 'text'],
        default: 'default',
        const: true
    },
    strokeColor: {
        type: {
            convert(value, button) {
                if (button.style !== 'outline') {
                    throw new Error(`The strokeColor can only be set on buttons with style "outline" but it has style ${button.style}.`);
                }
                return types.ColorValue.convert(value);
            },
            encode: types.ColorValue.encode
        },
        default: 'initial'
    },
    strokeWidth: {
        type: {
            convert(value, button) {
                if (button.style !== 'outline') {
                    throw new Error(`The strokeWidth can only be set on buttons with style "outline" but it has style ${button.style}.`);
                }
                return types.dimension.convert(value);
            }
        },
        nullable: true,
        default: null
    },
    alignment: {
        type: types.string,
        choice: ['left', 'right', 'centerX'],
        default: 'centerX'
    },
    autoCapitalize: {
        type: types.string,
        choice: ['default', 'none', 'all'],
        default: 'default'
    },
    image: { type: types.ImageValue, default: null },
    imageTintColor: { type: types.ColorValue, default: 'initial' },
    text: { type: types.string, default: '' },
    textColor: { type: types.ColorValue, default: 'initial' },
    font: { type: types.FontValue, default: 'initial' }
});
NativeObject.defineEvents(Button.prototype, {
    select: { native: true }
});

class CheckBox extends Widget {
    get _nativeType() {
        return 'tabris.CheckBox';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['text', this.text],
            ['checked', this.checked]
        ]);
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text'));
    }
}
NativeObject.defineProperties(CheckBox.prototype, {
    text: { type: 'string', default: '' },
    checked: { type: 'boolean', nocache: true },
    textColor: { type: 'ColorValue', default: 'initial' },
    tintColor: { type: 'ColorValue', default: 'initial' },
    checkedTintColor: { type: 'ColorValue', default: 'initial' },
    font: { type: 'FontValue', default: 'initial' }
});
NativeObject.defineEvents(CheckBox.prototype, {
    select: { native: true, changes: 'checked' }
});

class CollectionView extends Composite {
    /**
     * @param {Partial<CollectionView>} properties
     */
    constructor(properties) {
        super();
        Object.defineProperties(this, {
            _needsReload: {
                enumerable: false,
                writable: true,
                value: false
            },
            _updateCell: {
                enumerable: false,
                writable: true,
                value: ( /** @type {(cell: Widget) => void} */(() => { }))
            },
            _itemCount: {
                enumerable: false,
                writable: true,
                value: ( /** @type {number} */(0))
            },
            _createCell: {
                enumerable: false,
                writable: true,
                value: ( /** @type {(item: any) => Widget} */(() => new Composite()))
            },
            _cellHeight: {
                enumerable: false,
                writable: true,
                value: ( /** @type {number|'auto'|((item: any) => number)} */('auto'))
            },
            _cellType: {
                enumerable: false,
                writable: true,
                value: ( /** @type {string|((item: any) => string)} */(null))
            },
            _cellMapping: {
                enumerable: false,
                writable: true,
                value: ( /** @type {Map<Widget, number>} */(new Map()))
            },
            _itemMapping: {
                enumerable: false,
                writable: true,
                value: ( /** @type {Map<number, Widget>} */(new Map()))
            }
        });
        this.set(properties || {});
        this._nativeListen('requestInfo', true);
        this._nativeListen('createCell', true);
        this._nativeListen('updateCell', true);
        tabris.on('flush', this.$flush, this);
        this.on('dispose', () => tabris.off('flush', this.$flush, this));
    }
    get _nativeType() {
        return 'tabris.CollectionView';
    }
    set itemCount(value) {
        try {
            const oldValue = this._itemCount;
            this._itemCount = types.natural.convert(value);
            // explicit requirement by tests to do this even if the value is unchanged:
            this._needsReload = true;
            if (oldValue !== this._itemCount) {
                this._triggerChangeEvent('itemCount', this._itemCount);
            }
        }
        catch (ex) {
            this._printPropertyWarning('itemCount', ex);
        }
    }
    get itemCount() {
        return this._itemCount;
    }
    set cellType(value) {
        if (value === null || typeof value === 'string' || value instanceof Function) {
            if (value !== this._cellType) {
                this._cellType = value;
                this._needsReload = true;
                this._triggerChangeEvent('cellType', this._itemCount);
            }
        }
        else {
            this._printPropertyWarning('cellType', new Error('Not a string or function'));
        }
    }
    get cellType() {
        return this._cellType;
    }
    set cellHeight(value) {
        try {
            const oldValue = this._cellHeight;
            if (value === 'auto' || value instanceof Function) {
                this._cellHeight = value;
            }
            else {
                this._cellHeight = types.dimension.convert(value);
            }
            if (oldValue !== this._cellHeight) {
                this._needsReload = true;
                this._triggerChangeEvent('cellHeight', this._cellHeight);
            }
        }
        catch (ex) {
            this._printPropertyWarning('cellHeight', ex);
        }
    }
    get cellHeight() {
        return this._cellHeight;
    }
    /** @type {(item: any) => Widget} */
    set createCell(value) {
        if (value instanceof Function) {
            if (value !== this._createCell) {
                this._createCell = value;
                this._needsReload = true;
                this._triggerChangeEvent('createCell', this._createCell);
            }
        }
        else {
            this._printPropertyWarning('createCell', new Error('Not a function'));
        }
    }
    get createCell() {
        return this._createCell;
    }
    /** @type {(cell: Widget) => void} */
    set updateCell(value) {
        if (value instanceof Function) {
            if (this._updateCell !== value) {
                this._updateCell = value;
                this._needsReload = true;
                this._triggerChangeEvent('updateCell', this._updateCell);
            }
        }
        else {
            this._printPropertyWarning('updateCell', new Error('Not a function'));
        }
    }
    get updateCell() {
        return this._updateCell;
    }
    load(itemCount) {
        if (!isNumber$1(itemCount) || itemCount < 0) {
            throw new Error(`Invalid itemCount ${toValueString(itemCount)}`);
        }
        this._itemCount = itemCount;
        this._needsReload = true;
    }
    reveal(index, options) {
        index = this.$checkIndex(index);
        if (index >= 0 && index < this.itemCount) {
            this.$flush();
            this._nativeCall('reveal', {
                index,
                animate: options && 'animate' in options ? !!options.animate : true,
                offset: options && 'offset' in options ? options.offset : null
            });
        }
    }
    refresh(index) {
        if (arguments.length === 0) {
            this.$flush();
            this._nativeCall('refresh', { index: 0, count: this.itemCount });
            return;
        }
        index = this.$checkIndex(index);
        if (index >= 0 && index < this.itemCount) {
            this.$flush();
            this._nativeCall('refresh', { index, count: 1 });
        }
    }
    insert(index, count = 1) {
        index = Math.min(Math.max(0, this.$checkIndex(index)), this.itemCount);
        if (!isNumber$1(count) || count <= 0) {
            throw new Error(`Invalid insert count ${toValueString(count)}`);
        }
        this._itemCount = this.itemCount + count;
        this.$flush();
        for (let i = index; i < index + count; i++) {
            this._itemMapping.delete(i);
        }
        for (const cell of this._children()) {
            const oldIndex = this._cellMapping.get(cell);
            if (oldIndex >= index) {
                const newIndex = oldIndex + count;
                this._cellMapping.set(cell, newIndex);
                this._itemMapping.set(newIndex, cell);
            }
        }
        this._nativeCall('insert', { index, count });
    }
    remove(index, count = 1) {
        index = this.$checkIndex(index);
        if (isNumber$1(count) && count >= 0) {
            count = Math.min(count, this.itemCount - index);
        }
        else {
            throw new Error(`Invalid remove count ${toValueString(count)}`);
        }
        if (index >= 0 && index < this.itemCount && count > 0) {
            this._itemCount = this.itemCount - count;
            this.$flush();
            for (let i = this._itemCount; i < this.itemCount + count; i++) {
                this._itemMapping.delete(i);
            }
            for (const cell of this._children()) {
                const oldIndex = this._cellMapping.get(cell);
                if (oldIndex >= index) {
                    if (oldIndex < index + count) {
                        this._cellMapping.delete(cell);
                        this._itemMapping.delete(oldIndex);
                    }
                    else {
                        const newIndex = oldIndex - count;
                        this._cellMapping.set(cell, newIndex);
                        this._itemMapping.set(newIndex, cell);
                    }
                }
            }
            this._nativeCall('remove', { index, count });
        }
    }
    /**
     * @param {Widget} widget
     * @returns {number}
     */
    itemIndex(widget) {
        if (!(widget instanceof Widget)) {
            throw new Error(`${toValueString(widget)} is not a widget`);
        }
        let cell = widget;
        while (cell && cell.parent() !== this) {
            cell = cell.parent();
        }
        if (!cell) {
            throw new Error(`${toValueString(widget)} not a cell or child of a cell`);
        }
        if (this._cellMapping.has(cell)) {
            return this._cellMapping.get(cell);
        }
        return -1;
    }
    /**
     * @param {number} index
     * @returns {Widget}
     */
    cellByItemIndex(index) {
        if (!isNumber$1(index) || index < 0) {
            throw new Error(`${toValueString(index)} is not a valid index`);
        }
        if (this._itemMapping.has(index)) {
            return this._itemMapping.get(index);
        }
        return null;
    }
    set layout(value) {
        if (value) {
            this._printPropertyWarning('layout', new Error('CollectionView does not support layouts'));
        }
    }
    get layout() {
        return null;
    }
    _listen(name, listening) {
        if (name === 'firstVisibleIndexChanged') {
            this._onoff('scroll', listening, triggerChangeFirstVisibleIndex);
        }
        else if (name === 'lastVisibleIndexChanged') {
            this._onoff('scroll', listening, triggerChangeLastVisibleIndex);
        }
        else {
            super._listen(name, listening);
        }
    }
    _trigger(name, event) {
        if (name === 'requestInfo') {
            const type = resolveProperty(this, 'cellType', event.index);
            const height = resolveProperty(this, 'cellHeight', event.index, type);
            return {
                type: encodeCellType(this, type),
                height: encodeCellHeight(this, height)
            };
        }
        else if (name === 'createCell') {
            const item = this.$createCell(event.type);
            return item.cid;
        }
        else if (name === 'updateCell') {
            const cell = tabris._nativeObjectRegistry.find(event.widget);
            if (this._cellMapping.has(cell)) {
                this._itemMapping.delete(this._cellMapping.get(cell));
            }
            this._cellMapping.set(cell, event.index);
            this._itemMapping.set(event.index, cell);
            this.updateCell(cell, event.index);
        }
        else {
            return super._trigger(name, event);
        }
    }
    _initLayout() { }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['itemCount', this.itemCount],
            ['firstVisibleIndex', this.firstVisibleIndex]
        ]);
    }
    $checkIndex(index) {
        if (!isNumber$1(index)) {
            throw new Error(`${toValueString(index)} is not a valid index`);
        }
        return index < 0 ? index + this.itemCount : index;
    }
    $flush() {
        // Load new items if needed after all properties have been set
        // to avoid intercepting the aggregation of properties in set.
        if (this._needsReload) {
            this._needsReload = false;
            this._nativeCall('load', { itemCount: this.itemCount });
        }
    }
    $createCell(type) {
        const cell = this.createCell(decodeCellType(this, type));
        if (!(cell instanceof Widget)) {
            throw new Error(`Created cell ${toValueString(cell)} is not a widget`);
        }
        if (cell._parent) {
            throw new Error(`Created cell ${toValueString(cell)} already has a parent`);
        }
        cell._parent = this;
        this._addChild(cell);
        cell._setParent = () => hint(this, 'Cannot re-parent collection view cell');
        cell.dispose = () => hint(this, 'Cannot dispose of collection view cell');
        return cell;
    }
}
NativeObject.defineProperties(CollectionView.prototype, {
    refreshEnabled: {
        type: types.boolean,
        default: false
    },
    refreshIndicator: {
        type: types.boolean,
        nocache: true
    },
    refreshMessage: {
        type: types.string,
        default: ''
    },
    firstVisibleIndex: {
        type: types.number,
        readonly: true,
        nocache: true
    },
    lastVisibleIndex: {
        type: types.number,
        readonly: true,
        nocache: true
    },
    columnCount: {
        type: types.number,
        default: 1
    },
    scrollbarVisible: {
        type: types.boolean,
        default: true
    }
});
NativeObject.defineEvents(CollectionView.prototype, {
    refresh: { native: true },
    scroll: { native: true }
});
NativeObject.defineChangeEvents(CollectionView.prototype, [
    'createCell',
    'cellType',
    'cellHeight',
    'itemCount',
    'updateCell'
]);
function resolveProperty(ctx, name) {
    const value = ctx[name];
    if (typeof value === 'function') {
        return value.apply(null, Array.prototype.slice.call(arguments, 2));
    }
    return value;
}
function encodeCellType(ctx, type) {
    const cellTypes = ctx._cellTypes || (ctx._cellTypes = []);
    let index = cellTypes.indexOf(type);
    if (index === -1) {
        index += cellTypes.push(type);
    }
    return index;
}
function decodeCellType(ctx, type) {
    const cellTypes = ctx._cellTypes || [];
    return cellTypes[type] || null;
}
function encodeCellHeight(ctx, value) {
    if (value === 'auto') {
        return -1;
    }
    if (isNumber$1(value)) {
        return Math.max(-1, value);
    }
    hint(ctx, 'Invalid cell height: ' + value);
}
const triggerChangeFirstVisibleIndex = createDelegate('firstVisibleIndex');
const triggerChangeLastVisibleIndex = createDelegate('lastVisibleIndex');
function createDelegate(prop) {
    return function () {
        // eslint-disable-next-line no-invalid-this
        const instance = this;
        const actual = instance[prop];
        if (actual !== instance['_prev:' + prop]) {
            instance._triggerChangeEvent(prop, actual);
        }
        instance['_prev:' + prop] = actual;
    };
}
function isNumber$1(value) {
    return typeof value === 'number' && isFinite(value);
}

// NOTE:
// This module shall only contain dependency free,
// pure function so it can also be used at build time.
const refKey = Symbol();
/**
 * @template {unknown} RawType
 * @template {unknown} ResourceType
 * @param {import('./Resources').default} base
 * @param {ResourceConfig} config
 * @param {((value: any) => void)} typeCheck
 * @param {(value: any) => any} converter
 * @returns {import('./Resources').default<ResourceType>}
 */
function processResources(data, base, config, typeCheck, converter) {
    const resources = Object.assign({}, base);
    /** @type {{[key: string]: string}} */
    const references = {};
    for (const key in data) {
        const value = selectResource(data[key], config, tabris.device, typeCheck);
        if (isInherit(value)) {
            if (!(key in resources)) {
                throw new Error(`Resource "${key}" resolved to "inherit: true", but "${key}" does not exist in base object`);
            }
        }
        else if (value instanceof Object && refKey in value) {
            references[key] = value[refKey];
        }
        else {
            resources[key] = converter(value);
        }
    }
    return Object.assign(resources, resolveReferences(resources, references));
}
function isInherit(value) {
    if (!(value instanceof Object) || value.constructor !== Object) {
        return false;
    }
    const keys = Object.keys(value).map(str => str.toLowerCase());
    if (keys.indexOf('inherit') === -1) {
        return false;
    }
    if (keys.length === 1 && value.inherit === true) {
        return true;
    }
    throw new Error('Invalid inherit syntax ' + JSON.stringify(value));
}
/**
 * @template {unknown} ResourceType
 * @param {import('./Resources').default<ResourceType>} resources
 * @param {{[key: string]: string}} references
 * @returns {import('./Resources').default<ResourceType>}
 */
function resolveReferences(resources, references) {
    /** @type {typeof resources} */
    const result = {};
    for (const key in references) {
        const ref = references[key];
        if (ref in resources) {
            result[key] = resources[ref];
        }
        else {
            if (ref in references) {
                throw new Error(`"${key}": References can not be nested`);
            }
            else {
                throw new Error(`"${key}": Can not resolve reference "${ref}"`);
            }
        }
    }
    return result;
}
/**
 * Applies the selector logic to a single resource definition object.
 * @template {unknown} RawType
 * @param {Selectable<RawType>} selectable
 * @param {ResourceConfig} resourceConfig
 * @param {object} targetConfig
 * @param {'android'|'ios'|'Android'|'iOS'} targetConfig.platform
 * @param {number} targetConfig.scaleFactor
 * @param {string} targetConfig.language
 * @param {((value: any) => void)=} checkRawType
 * @returns {RawType | {inherit: true} | {[key: symbol]: string}}
 */
function selectResource(selectable, resourceConfig, targetConfig, checkRawType) {
    if (isPlatformSelector(selectable)) {
        return selectResource(getValue(selectable, targetConfig.platform), resourceConfig, targetConfig, checkRawType);
    }
    else if (isScaleSelector(selectable)) {
        return selectResource(getNearbyValue(selectable, targetConfig.scaleFactor, resourceConfig.scaleFactor), resourceConfig, targetConfig, checkRawType);
    }
    else if (isLangSelector(selectable, resourceConfig.fallbackLanguage)) {
        return selectResource(getLocalValue(selectable, targetConfig.language, resourceConfig.fallbackLanguage), resourceConfig, targetConfig, checkRawType);
    }
    else if (isReference(selectable)) {
        return { [refKey]: getValue(selectable, 'ref') };
    }
    checkHasNoInvalidKeys(selectable);
    if (checkRawType) {
        checkRawType(selectable);
    }
    return /** @type {RawType}*/ (selectable);
}
function isReference(value) {
    if (!(value instanceof Object) || value.constructor !== Object) {
        return false;
    }
    const keys = Object.keys(value).map(str => str.toLowerCase());
    if (keys.indexOf('ref') === -1) {
        return false;
    }
    if (keys.length === 1 && typeof value.ref === 'string') {
        return true;
    }
    throw new Error('Invalid reference syntax ' + JSON.stringify(value));
}
function isPlatformSelector(value) {
    if (!(value instanceof Object)) {
        return false;
    }
    const keys = Object.keys(value).map(str => str.toLowerCase());
    const hasAndroid = keys.indexOf('android') !== -1;
    const hasIOs = keys.indexOf('ios') !== -1;
    if (!hasAndroid && !hasIOs) {
        return false;
    }
    if (hasAndroid && hasIOs && keys.length === 2) {
        return true;
    }
    throw new Error('Invalid platform selector ' + JSON.stringify(value));
}
const SCALE_REGEX = /^([0-9]+|[0-9]\.[0-9]+)x$/;
const SCALE_REGEX_STRICT = /^([1-9]|[1-9]\.[0-9]+)x$/;
function isScaleSelector(value) {
    if (!(value instanceof Object)) {
        return false;
    }
    const keys = Object.keys(value).map(str => str.toLowerCase());
    const scaleKeys = keys.filter(key => SCALE_REGEX.test(key));
    if (scaleKeys.length === 0) {
        return false;
    }
    if ((keys.length === scaleKeys.length)
        && !hasDuplicates(keys)
        && scaleKeys.every(key => SCALE_REGEX_STRICT.test(key))) {
        return true;
    }
    throw new Error('Invalid scale selector ' + JSON.stringify(value));
}
const SHORT_LANG_REGEX = /^[a-zA-Z][a-zA-Z][a-zA-Z]?$/;
const LONG_LANG_REGEX = /^[a-zA-Z][a-zA-Z][a-zA-Z]?-[a-zA-Z0-9][-a-zA-Z0-9]+$/;
const LANG_LIKE_REGEX = /^[a-zA-Z][-a-zA-Z0-9]$/;
/**
 * @param {string} key
 */
function isLangKey(key) {
    return SHORT_LANG_REGEX.test(key) || LONG_LANG_REGEX.test(key);
}
/**
 * @param {any} value
 * @param {string} fallback
 */
function isLangSelector(value, fallback) {
    if (!(value instanceof Object)) {
        return false;
    }
    const keys = Object.keys(value).map(str => str.toLowerCase());
    const langLikeKeys = keys.filter(key => LANG_LIKE_REGEX.test(key));
    if (langLikeKeys.length === 0) {
        return false;
    }
    if (!value[fallback.toLowerCase()] && !value[fallback.toLowerCase().split('-')[0]]) {
        throw new Error(`Missing entry for fallback language (currently "${fallback}") `
            + 'in selector '
            + JSON.stringify(value));
    }
    const langKeys = keys.filter(isLangKey);
    if ((keys.length === langKeys.length) && !hasDuplicates(keys)) {
        return true;
    }
    throw new Error('Invalid language selector ' + JSON.stringify(value));
}
const RESERVED = [
    '', 'small', 'normal', 'large', 'xlarge', 'horizontal', 'vertical', 'landscape', 'portrait',
    'debug', 'production', 'phone', 'tablet', 'browser', 'online', 'offline', 'wifi', 'cell',
    'other', 'long', 'notlong', 'ldrtl', 'ldltr'
];
const INVALID = [/^mcc[0-9]/, /^[a-z0-9]+dpi$/, /^!/, /[*:._$@#]/];
function checkHasNoInvalidKeys(resource) {
    if (resource instanceof Object && resource.constructor === Object) {
        Object.keys(resource).forEach(key => {
            if (typeof key === 'string' && RESERVED.indexOf(key.toLowerCase().trim()) !== -1) {
                throw new Error(`Resource uses reserved property name "${key}".`);
            }
            INVALID.forEach(regex => {
                if (regex.test(key)) {
                    throw new Error(`Resource uses reserved property name "${key}".`);
                }
            });
        });
    }
}
/**
 * @param {object} source
 * @param {string} name
 */
function getValue(source, name) {
    const lowerCaseName = name.toLowerCase();
    for (const key in source) {
        if (key.toLowerCase() === lowerCaseName) {
            return source[key];
        }
    }
}
/**
 * @param {object} selectable
 * @param {number} approx
 * @param {ResourceConfig['scaleFactor']} strategy
 */
function getNearbyValue(selectable, approx, strategy) {
    const candidates = Object.keys(selectable)
        .map(key => /** @type {[number, any]} */ ([parseFloat(key), selectable[key]]))
        .sort((a, b) => a[0] - b[0]);
    const last = candidates.length - 1;
    for (let i = 0; i < last; i++) {
        const lower = candidates[i];
        const higher = candidates[i + 1];
        if ((approx >= lower[0]) && (approx < higher[0])) {
            if (strategy === 'lower') {
                return lower[1];
            }
            else if (strategy === 'higher') {
                return higher[1];
            }
            else {
                return (approx - lower[0]) < (higher[0] - approx) ? lower[1] : higher[1];
            }
        }
    }
    return candidates[last][1];
}
/**
 * @param {object} source
 * @param {string} language
 * @param {string} fallback
 */
function getLocalValue(source, language, fallback) {
    const map = {};
    Object.keys(source).forEach(key => map[key.toLowerCase()] = source[key]);
    return map[language.toLowerCase()]
        || map[language.toLowerCase().split('-')[0]]
        || map[fallback.toLowerCase()]
        || map[fallback.toLowerCase().split('-')[0]];
}
/**
 * @param {any[]} arr
 * @returns boolean
 */
function hasDuplicates(arr) {
    for (let i = 0; i < arr.length; i++) {
        if (arr.indexOf(arr[i], i + 1) !== -1) {
            return true;
        }
    }
    return false;
}

/**
 * @template {any} ResourceType
 * @template {any} RawType
 */
class ResourceBuilder {
    /**
     * @param {ResourceBuilderConstructorOptions<ResourceType, RawType>} options
     */
    constructor(options) {
        validateOptions(options);
        this.validator = options.validator || null;
        this.type = options.type || null;
        this.converter = options.converter || null;
        Object.freeze(this);
    }
    /**
     * @template {ResourceBaseData<ResourceType>} Base
     * @template {ResourceDataWithConfig<RawType>} Data
     * @param {Base} obj1
     * @param {Data=} obj2
     * @returns {NamedResources<ResourceType, keyof Base & Data>}
     */
    from(obj1, obj2) {
        const withBase = arguments.length === 2;
        const base = ( /** @type {ResourceBaseData<ResourceType>}*/(withBase ? obj1 : {}));
        const dataWithConfig = ( /** @type {ResourceDataWithConfig<RawType>} */(withBase ? obj2 : obj1));
        /** @type {ResourceConfig} */
        const config = {};
        /** @type {ResourceRawData<RawType>} */
        const data = {};
        Object.keys(dataWithConfig).forEach(key => {
            if (CONFIG_KEYS[key]) {
                config[key.slice(1)] = dataWithConfig[key];
            }
            else if (key !== '$schema') {
                data[key] = dataWithConfig[key];
            }
        });
        /** @type {ResourcesConstructorOptions<ResourceType, RawType>} */
        const options = Object.assign({ data, base, config }, this);
        // @ts-ignore
        return new Resources(options);
    }
}
const CONFIG_KEYS = {
    $scaleFactor: true,
    $fallbackLanguage: true
};
/**
 * @param {any} options
 */
function validateOptions(options) {
    checkType(options, Object, { name: 'parameter 1' });
    if (options.converter || options.type || options.validator) {
        return;
    }
    throw new Error('At least one option required');
}

const RESOURCE_REGEX = /^[a-z][a-zA-Z][a-zA-Z0-9]+$/;
const SCALE_FACTOR = ['nearest', 'lower', 'higher'];
const CONFIG_DEFAULTS = {
    scaleFactor: SCALE_FACTOR[1],
    fallbackLanguage: 'en'
};
const ALLOWED_OPTIONS = ['data', 'config', 'base', 'converter', 'type', 'validator'];
/**
 * @template {unknown} ResourceType
 * @template {unknown} RawType
 */
class Resources {
    /**
     * @template ResourceType
     * @template RawType
     * @param {ResourceBuildConvertOptions<ResourceType, RawType>} options
     * @returns {ResourceBuilder<ResourceType, RawType>}
     */
    static build(options) {
        if (arguments.length !== 1) {
            throw new Error(`Expected 1 parameter, got ${arguments.length}`);
        }
        return new ResourceBuilder(options);
    }
    /**
     * @param {ResourcesConstructorOptions<ResourceType, RawType>} options
     */
    constructor(options) {
        validateArguments(arguments);
        const result = wrap(this, options.type);
        return Object.assign(result, processResources(options.data, options.base || {}, Object.assign({}, CONFIG_DEFAULTS, options.config), createRawTypeCheck(options.validator, options.type), options.converter || (v => v)));
    }
}
/**
 * @param {IArguments} args
 */
function validateArguments(args) {
    if (args.length !== 1) {
        throw new Error(`Expected 1 parameter, got ${args.length}`);
    }
    const options = args[0];
    checkType(options, Object, { name: 'parameter 1' });
    if (!(options.data instanceof Object)) {
        checkType(options.data, Object, { name: 'option "data"' });
    }
    checkType(options.converter, Function, { name: 'option "converter"', nullable: true });
    if (('type' in options) && options.type != null && !(options.type instanceof Function && options.type.prototype)) {
        throw new Error(`Expected option "type" to be a constructor, got ${typeof options.type}`);
    }
    checkType(options.base, Object, { name: 'option "base"', nullable: true });
    Object.keys(options).forEach(key => {
        if (ALLOWED_OPTIONS.indexOf(key) === -1) {
            throw new Error(`Unknown option "${key}"`);
        }
    });
    validateResourceNames(Object.keys(options.data));
    validateResourceNames(Object.keys(options.base || {}));
    validateConfig(options.config);
}
/**
 * @param {string[]} names
 */
function validateResourceNames(names) {
    for (const name of names) {
        if (name === '$') {
            continue;
        }
        if (!RESOURCE_REGEX.test(name)) {
            throw new Error(`Invalid resource name ${name}`);
        }
    }
}
/**
 * @param {ResourceConfig} config
 */
function validateConfig(config) {
    if (typeof config === 'undefined') {
        return;
    }
    checkType(config, Object, { name: 'option "config"' });
    for (const key of Object.keys(config)) {
        if (!(key in CONFIG_DEFAULTS)) {
            throw new Error(`Unknown configuration key "${key}"`);
        }
    }
    if ('scaleFactor' in config && SCALE_FACTOR.indexOf(config.scaleFactor) === -1) {
        throw new Error(`Invalid scaleFactor "${config.scaleFactor}"`);
    }
}
/**
 * @param {Resources<any, any>} resources
 * @param {Constructor<any>=} type
 */
function wrap(resources, type) {
    return new Proxy(resources, {
        set(target, property, value) {
            if (type) {
                checkType(value, type, { name: 'data', nullable: true });
            }
            target[property] = value;
            return true;
        }
    });
}
/**
 * @param {(value: any) => boolean} validator
 * @param {Constructor<any>=} type
 */
function createRawTypeCheck(validator, type) {
    const typeName = type ? type.name : 'resource';
    return rawValue => {
        if (!isInherit(rawValue) && validator && !validator(rawValue)) {
            const entry = typeof rawValue === 'string' ? rawValue : JSON.stringify(rawValue);
            throw new Error(`data entry "${entry}" is not a valid selector or raw ${typeName} type`);
        }
    };
}

const COLOR_OPTIONS = {
    type: Color,
    converter: Color.from,
    validator: Color.isValidColorValue
};
class ColorResources extends Resources {
    static from() {
        const builder = Resources.build(/** @type {any} */ (COLOR_OPTIONS));
        return builder.from.apply(builder, arguments);
    }
    constructor(options) {
        if (arguments.length !== 1) {
            throw new Error(`Expected 1 parameter, got ${arguments.length}`);
        }
        checkType(options, Object, { name: 'parameter 1' });
        super(Object.assign({}, COLOR_OPTIONS, options));
    }
}

const Align = {
    top: 'top',
    centerY: 'centerY',
    baseline: 'baseline',
    bottom: 'bottom',
    stretchY: 'stretchY'
};
const zero$1 = new Percent(0);
class RowLayout extends Layout {
    static get default() {
        if (!this._default) {
            Object.defineProperty(this, '_default', {
                enumerable: false,
                writable: true,
                configurable: true,
                value: new RowLayout()
            });
        }
        return this._default;
    }
    constructor(properties = {}, queue) {
        super({}, queue);
        const align = Align[properties.alignment] || Align.top;
        Object.defineProperties(this, {
            _spacing: {
                enumerable: false,
                writable: false,
                value: 'spacing' in properties ? types.number.convert(properties.spacing) : 0
            },
            _alignment: {
                enumerable: false,
                writable: false,
                value: align
            },
            _layoutDataVertical: {
                enumerable: false,
                writable: false,
                value: LayoutData.from({
                    top: (align === Align.top || align === Align.stretchY) ? 0 : 'auto',
                    bottom: (align === Align.bottom || align === Align.stretchY) ? 0 : 'auto',
                    centerY: (align === Align.centerY) ? 0 : 'auto',
                    baseline: (align === Align.baseline) ? Constraint.prev : 'auto'
                })
            }
        });
    }
    get spacing() {
        return this._spacing;
    }
    get alignment() {
        return this._alignment;
    }
    _getLayoutData(child) {
        const result = child.layoutData;
        ['left', 'top', 'right', 'bottom']
            .filter(prop => !isValidConstraint(result[prop]))
            .forEach(prop => layoutWarn(child, prop, 'RowLayout only supports "auto" and numeric offset.'));
        ['centerX']
            .filter(prop => result[prop] !== 'auto')
            .forEach(prop => layoutWarn(child, prop, 'StackLayout only supports "auto".'));
        if (result.centerY !== 'auto'
            && (result.top !== 'auto' || result.bottom !== 'auto' || result.baseline !== 'auto')) {
            warn('Inconsistent layoutData: centerY overrides top, bottom and baseline.\nTarget: ' + getPath(child));
        }
        else if (result.baseline !== 'auto' && (result.top !== 'auto' || result.bottom !== 'auto')) {
            warn('Inconsistent layoutData: baseline overrides top and bottom.\nTarget: ' + getPath(child));
        }
        if (result.top !== 'auto' && result.bottom !== 'auto' && result.height !== 'auto') {
            warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
        }
        return result;
    }
    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */
    _renderLayoutData(children, allLayoutData) {
        const stretchIndex = this._findStretchIndex(allLayoutData);
        let alignLeft = true;
        for (let i = 0; i < children.length; i++) {
            const targetLayoutData = Object.assign({}, this._layoutDataVertical);
            this._layoutY(targetLayoutData, allLayoutData, i);
            this._applyWidth(allLayoutData[i], targetLayoutData);
            if (alignLeft) {
                this._applyLeft(targetLayoutData, allLayoutData, i);
            }
            if (i === stretchIndex) {
                alignLeft = false;
                targetLayoutData.width = 'auto';
            }
            if (!alignLeft) {
                this._applyRight(targetLayoutData, allLayoutData, i);
            }
            children[i]._nativeSet('layoutData', this._resolveAttributes(targetLayoutData, children[i]));
        }
    }
    _layoutY(targetLayoutData, allLayoutData, index) {
        const layoutData = allLayoutData[index];
        if (layoutData.top !== 'auto'
            || layoutData.bottom !== 'auto'
            || layoutData.centerY !== 'auto'
            || layoutData.baseline !== 'auto') {
            if (layoutData.centerY !== 'auto') {
                Object.assign(targetLayoutData, { top: 'auto', bottom: 'auto', baseline: 'auto', centerY: layoutData.centerY });
            }
            else if (layoutData.baseline !== 'auto') {
                Object.assign(targetLayoutData, { top: 'auto', bottom: 'auto', baseline: layoutData.baseline });
            }
            else {
                Object.assign(targetLayoutData, {
                    top: layoutData.top !== 'auto' ? new Constraint(zero$1, layoutData.top.offset) : 'auto',
                    bottom: layoutData.bottom !== 'auto' ? new Constraint(zero$1, layoutData.bottom.offset) : 'auto',
                    centerY: 'auto',
                    baseline: 'auto'
                });
            }
        }
        else if (index === 0 && targetLayoutData.baseline !== 'auto') {
            targetLayoutData.baseline = 'auto';
            targetLayoutData.top = 0;
        }
        if (layoutData.height !== 'auto' && (layoutData.top === 'auto' || layoutData.bottom === 'auto')) {
            targetLayoutData.height = layoutData.height;
            if (this._alignment === Align.stretchY) {
                targetLayoutData.bottom = 'auto';
            }
        }
    }
    _applyLeft(targetLayoutData, allLayoutData, index) {
        const left = allLayoutData[index].left;
        const prevLayoutData = allLayoutData[index - 1];
        const prevRight = prevLayoutData ? prevLayoutData.right : 'auto';
        const ref = prevLayoutData ? LayoutData.prev : zero$1;
        if (left === 'auto' && prevRight === 'auto') {
            targetLayoutData.left = new Constraint(ref, prevLayoutData ? this._spacing : 0);
        }
        else {
            targetLayoutData.left = new Constraint(ref, maxPositive(left !== 'auto' ? left.offset : 0, prevRight !== 'auto' ? prevRight.offset : 0));
        }
    }
    _applyRight(targetLayoutData, allLayoutData, index) {
        const right = allLayoutData[index].right;
        const nextLayoutData = allLayoutData[index + 1];
        const nextLeft = nextLayoutData ? nextLayoutData.left : 'auto';
        const ref = nextLayoutData ? LayoutData.next : zero$1;
        if (right === 'auto' && nextLeft === 'auto') {
            targetLayoutData.right = new Constraint(ref, nextLayoutData ? this._spacing : 0);
        }
        else {
            targetLayoutData.right = new Constraint(ref, maxPositive(right !== 'auto' ? right.offset : 0, nextLeft !== 'auto' ? nextLeft.offset : 0));
        }
    }
    _applyWidth(layoutData, targetLayoutData) {
        if (layoutData.width !== 'auto') {
            targetLayoutData.width = layoutData.width;
        }
    }
    _findStretchIndex(allLayoutData) {
        for (let i = 0; i < allLayoutData.length; i++) {
            const { left, width, right } = allLayoutData[i];
            if (left !== 'auto' && width === 'auto' && right !== 'auto') {
                return i;
            }
        }
        return -1;
    }
}

class Row extends Composite {
    constructor(properties) {
        super(properties);
    }
    get spacing() {
        return this._layout.spacing;
    }
    // prevent error due to _nativeCreate attempting to set
    set spacing(value) { }
    get alignment() {
        return this._layout.alignment;
    }
    // prevent error due to _nativeCreate attempting to set
    set alignment(value) { }
    _initLayout(props = {}) {
        let layout = props.layout || RowLayout.default;
        if ('spacing' in props || 'alignment' in props) {
            layout = new RowLayout({
                spacing: 'spacing' in props ? props.spacing : layout.spacing,
                alignment: 'alignment' in props ? props.alignment : layout.alignment
            });
        }
        this._checkLayout(layout);
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: layout });
        this._layout.add(this);
    }
    _checkLayout(value) {
        if (!(value instanceof RowLayout)) {
            throw new Error(`${toValueString(value)} is not an instance of RowLayout`);
        }
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        result.push(['alignment', this.alignment]);
        return result;
    }
}

const Align$1 = {
    left: 'left',
    centerX: 'centerX',
    right: 'right',
    stretchX: 'stretchX'
};
const zero$2 = new Percent(0);
class StackLayout extends Layout {
    static get default() {
        if (!this._default) {
            Object.defineProperty(this, '_default', {
                enumerable: false,
                writable: true,
                configurable: true,
                value: new StackLayout()
            });
        }
        return this._default;
    }
    constructor(properties = {}, queue) {
        super({}, queue);
        const align = Align$1[properties.alignment] || Align$1.left;
        Object.defineProperties(this, {
            _spacing: {
                enumerable: false,
                writable: false,
                value: 'spacing' in properties ? types.number.convert(properties.spacing) : 0
            },
            _alignment: {
                enumerable: false,
                writable: false,
                value: align
            },
            _layoutDataHorizontal: {
                enumerable: false,
                writable: false,
                value: LayoutData.from({
                    left: (align === Align$1.left || align === Align$1.stretchX) ? 0 : 'auto',
                    right: (align === Align$1.right || align === Align$1.stretchX) ? 0 : 'auto',
                    centerX: (align === Align$1.centerX) ? 0 : 'auto'
                })
            }
        });
    }
    get spacing() {
        return this._spacing;
    }
    get alignment() {
        return this._alignment;
    }
    _getLayoutData(child) {
        const result = child.layoutData;
        ['left', 'top', 'right', 'bottom']
            .filter(prop => !isValidConstraint(result[prop]))
            .forEach(prop => layoutWarn(child, prop, 'StackLayout only supports "auto" and numeric offset.'));
        ['centerY', 'baseline']
            .filter(prop => result[prop] !== 'auto')
            .forEach(prop => layoutWarn(child, prop, 'StackLayout only supports "auto".'));
        if (result.centerX !== 'auto' && (result.left !== 'auto' || result.right !== 'auto')) {
            warn('Inconsistent layoutData: centerX overrides left and right.\nTarget: ' + getPath(child));
        }
        if (result.left !== 'auto' && result.right !== 'auto' && result.width !== 'auto') {
            warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
        }
        return result;
    }
    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */
    _renderLayoutData(children, allLayoutData) {
        const stretchIndex = this._findStretchIndex(allLayoutData);
        let alignTop = true;
        for (let i = 0; i < children.length; i++) {
            const targetLayoutData = Object.assign({}, this._layoutDataHorizontal);
            this._layoutX(allLayoutData[i], targetLayoutData);
            this._applyHeight(allLayoutData[i], targetLayoutData);
            if (alignTop) {
                this._applyTop(targetLayoutData, allLayoutData, i);
            }
            if (i === stretchIndex) {
                alignTop = false;
                targetLayoutData.height = 'auto';
            }
            if (!alignTop) {
                this._applyBottom(targetLayoutData, allLayoutData, i);
            }
            children[i]._nativeSet('layoutData', this._resolveAttributes(targetLayoutData, children[i]));
        }
    }
    _layoutX(layoutData, targetLayoutData) {
        if (layoutData.left !== 'auto' || layoutData.right !== 'auto' || layoutData.centerX !== 'auto') {
            if (layoutData.centerX !== 'auto') {
                Object.assign(targetLayoutData, { left: 'auto', right: 'auto', centerX: layoutData.centerX });
            }
            else {
                Object.assign(targetLayoutData, {
                    left: layoutData.left !== 'auto' ? new Constraint(zero$2, layoutData.left.offset) : 'auto',
                    right: layoutData.right !== 'auto' ? new Constraint(zero$2, layoutData.right.offset) : 'auto',
                    centerX: 'auto'
                });
            }
        }
        if (layoutData.width !== 'auto' && (layoutData.left === 'auto' || layoutData.right === 'auto')) {
            targetLayoutData.width = layoutData.width;
            if (this._alignment === Align$1.stretchX) {
                targetLayoutData.right = 'auto';
            }
        }
    }
    _applyTop(targetLayoutData, allLayoutData, index) {
        const top = allLayoutData[index].top;
        const prevLayoutData = allLayoutData[index - 1];
        const prevBottom = prevLayoutData ? prevLayoutData.bottom : 'auto';
        const ref = prevLayoutData ? LayoutData.prev : zero$2;
        if (top === 'auto' && prevBottom === 'auto') {
            targetLayoutData.top = new Constraint(ref, prevLayoutData ? this._spacing : 0);
        }
        else {
            targetLayoutData.top = new Constraint(ref, maxPositive(top !== 'auto' ? top.offset : 0, prevBottom !== 'auto' ? prevBottom.offset : 0));
        }
    }
    _applyBottom(targetLayoutData, allLayoutData, index) {
        const bottom = allLayoutData[index].bottom;
        const nextLayoutData = allLayoutData[index + 1];
        const nextTop = nextLayoutData ? nextLayoutData.top : 'auto';
        const ref = nextLayoutData ? LayoutData.next : zero$2;
        if (bottom === 'auto' && nextTop === 'auto') {
            targetLayoutData.bottom = new Constraint(ref, nextLayoutData ? this._spacing : 0);
        }
        else {
            targetLayoutData.bottom = new Constraint(ref, maxPositive(bottom !== 'auto' ? bottom.offset : 0, nextTop !== 'auto' ? nextTop.offset : 0));
        }
    }
    _applyHeight(layoutData, targetLayoutData) {
        if (layoutData.height !== 'auto') {
            targetLayoutData.height = layoutData.height;
        }
    }
    _findStretchIndex(allLayoutData) {
        for (let i = 0; i < allLayoutData.length; i++) {
            const { top, height, bottom } = allLayoutData[i];
            if (top !== 'auto' && height === 'auto' && bottom !== 'auto') {
                return i;
            }
        }
        return -1;
    }
}

class Stack extends Composite {
    constructor(properties) {
        super(properties);
    }
    get spacing() {
        return this._layout.spacing;
    }
    // prevent error due to _nativeCreate attempting to set
    set spacing(value) { }
    get alignment() {
        return this._layout.alignment;
    }
    // prevent error due to _nativeCreate attempting to set
    set alignment(value) { }
    _initLayout(props = {}) {
        let layout = props.layout || StackLayout.default;
        if ('spacing' in props || 'alignment' in props) {
            layout = new StackLayout({
                spacing: 'spacing' in props ? props.spacing : layout.spacing,
                alignment: 'alignment' in props ? props.alignment : layout.alignment
            });
        }
        this._checkLayout(layout);
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: layout });
        this._layout.add(this);
    }
    _checkLayout(value) {
        if (!(value instanceof StackLayout)) {
            throw new Error(`${toValueString(value)} is not an instance of StackLayout`);
        }
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        result.push(['alignment', this.alignment]);
        return result;
    }
}

class CameraView extends Widget {
    get _nativeType() {
        return 'tabris.CameraView';
    }
}
NativeObject.defineProperties(CameraView.prototype, {
    camera: { type: Camera, default: null, nullable: true },
    scaleMode: {
        type: 'string',
        choice: ['fit', 'fill'],
        default: 'fit'
    }
});

class Crypto {
    constructor() {
        Object.defineProperties(this, {
            _nativeObject: { enumerable: false, writable: false, value: NativeCrypto.getInstance() },
            subtle: { enumerable: false, writable: false, value: new SubtleCrypto() }
        });
    }
    getRandomValues(typedArray) {
        if (arguments.length === 0) {
            throw new Error('Not enough arguments to Crypto.getRandomValues');
        }
        if (!isIntArray(typedArray)) {
            throw new Error(`Argument ${toValueString(typedArray)} is not an accepted array type`);
        }
        return this._nativeObject.getRandomValues(typedArray);
    }
}
const validAlgorithms = new Set(['SHA-1', 'SHA-256', 'SHA-384', 'SHA-512']);
class SubtleCrypto {
    constructor() {
        Object.defineProperty(this, '_nativeObject', {
            enumerable: false, writable: false, value: NativeCrypto.getInstance()
        });
    }
    digest(algorithm, data) {
        return __awaiter(this, arguments, void 0, function* () {
            if (arguments.length < 2) {
                return Promise$1.reject(new TypeError('Not enough arguments to SubtleCrypto.digest'));
            }
            if (!validAlgorithms.has(algorithm)) {
                return Promise$1.reject(new TypeError(`Algorithm: Unrecognized name ${algorithm}`));
            }
            if (!isIntArray(data) && !(data instanceof ArrayBuffer)) {
                return Promise$1.reject(new TypeError(`Argument ${toValueString(data)} is not an accepted array type`));
            }
            return new Promise$1((resolve, reject) => this._nativeObject.subtleDigest({ algorithm, data, resolve, reject }));
        });
    }
}
class NativeCrypto extends NativeObject {
    static getInstance() {
        if (!this.instance) {
            this.instance = new NativeCrypto();
        }
        return this.instance;
    }
    get _nativeType() {
        return 'tabris.Crypto';
    }
    getRandomValues(typedArray) {
        const byteLength = typedArray.byteLength;
        const values = new Uint8Array(this._nativeCall('getRandomValues', { byteLength }));
        if (values.byteLength !== byteLength) {
            throw new Error('Not enough random bytes available');
        }
        new Uint8Array(typedArray.buffer).set(values);
        return typedArray;
    }
    subtleDigest(arg) {
        this._nativeCall('subtleDigest', {
            algorithm: arg.algorithm,
            data: ArrayBuffer.isView(arg.data) ? arg.data.buffer : arg.data,
            onSuccess: (result) => {
                if (!(result instanceof ArrayBuffer) || result.byteLength === 0) {
                    throw new TypeError('Internal Type Error: result is not valid ArrayBuffer');
                }
                arg.resolve(result);
            },
            onError: (reason) => arg.reject(new Error(String(reason)))
        });
    }
}
function isIntArray(value) {
    return (value instanceof Int8Array) ||
        (value instanceof Uint8Array) ||
        (value instanceof Uint8ClampedArray) ||
        (value instanceof Int16Array) ||
        (value instanceof Uint16Array) ||
        (value instanceof Int32Array) ||
        (value instanceof Uint32Array);
}

class Drawer extends ContentView {
    get _nativeType() {
        return 'tabris.Drawer';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('Drawer can not be created');
        }
        super._nativeCreate({ [creationAllowed]: true });
    }
    _setParent() {
        throw new Error('Parent of Drawer can not be changed');
    }
    _listen(name, listening) {
        if (name === 'open' || name === 'close') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _dispose() {
        throw new Error('Drawer can not be disposed');
    }
    open() {
        this._nativeCall('open', {});
        return this;
    }
    close() {
        this._nativeCall('close', {});
        return this;
    }
}
NativeObject.defineProperties(Drawer.prototype, {
    enabled: {
        type: 'boolean',
        default: false
    }
});
NativeObject.defineEvents(Drawer.prototype, {
    open: { native: true },
    close: { native: true }
});
function create$9() {
    return new Drawer(true);
}

class DateDialog extends Popup {
    static open(value) {
        let dateDialog;
        if (value instanceof DateDialog) {
            dateDialog = value;
        }
        else if (value instanceof Date) {
            dateDialog = new DateDialog({ date: value });
        }
        else {
            dateDialog = new DateDialog();
        }
        return dateDialog.open();
    }
    /**
     * @param {Partial<DateDialog>=} properties
     */
    constructor(properties) {
        super(properties);
        this._nativeListen('close', true);
        this._nativeListen('select', true);
        this._autoDispose = true;
    }
    get _nativeType() {
        return 'tabris.DateDialog';
    }
    _trigger(name, event) {
        if (name === 'close') {
            this._handleCloseEvent(event);
        }
        else if (name === 'select') {
            event.date = new Date(event.date);
            super._trigger('select', event);
            this._handleCloseEvent(event);
        }
        else {
            return super._trigger(name, event);
        }
    }
    _handleCloseEvent(event) {
        super._trigger('close', event);
        this.dispose();
    }
}
NativeObject.defineProperties(DateDialog.prototype, {
    date: { type: types.Date, default: null },
    maxDate: { type: types.Date, default: null },
    minDate: { type: types.Date, default: null }
});
NativeObject.defineEvents(DateDialog.prototype, {
    select: { native: true },
    close: { native: true }
});

class FormData {
    getAll(name) {
        if (arguments.length === 0) {
            throw new TypeError('FormData.getAll requires at least 1 argument, but only 0 were passed');
        }
        const values = data$1(this)[name];
        return values ? values.concat() : [];
    }
    get(name) {
        if (arguments.length === 0) {
            throw new TypeError('FormData.get requires at least 1 argument, but only 0 were passed');
        }
        const values = data$1(this)[name];
        return values ? values[0] : null;
    }
    has(name) {
        if (arguments.length === 0) {
            throw new TypeError('FormData.has requires at least 1 argument, but only 0 were passed');
        }
        return !!data$1(this)[name];
    }
    append(name, value, filename) {
        if (arguments.length < 2) {
            throw new TypeError(arguments.length + ' is not a valid argument count for any overload of FormData.append.');
        }
        if (arguments.length === 3 && !(value instanceof Blob)) {
            throw new TypeError('Argument 2 of FormData.append is not an object.');
        }
        const values = data$1(this)[name] || [];
        values.push(normalize(value, filename));
        data$1(this)[name] = values;
    }
    set(name, value, filename) {
        if (arguments.length < 2) {
            throw new TypeError(arguments.length + ' is not a valid argument count for any overload of FormData.set.');
        }
        if (arguments.length === 3 && !(value instanceof Blob)) {
            throw new TypeError('Argument 2 of FormData.set is not an object.');
        }
        data$1(this)[name] = [normalize(value, filename)];
    }
    delete(name) {
        if (arguments.length === 0) {
            throw new TypeError('0 is not a valid argument count for any overload of FormData.delete.');
        }
        delete data$1(this)[name];
    }
    keys() {
        const entries = this.entries();
        const next = () => {
            const { done, value } = entries.next();
            return { done, value: !done ? value[0] : undefined };
        };
        return { next, [Symbol.iterator]() { return this; } };
    }
    values() {
        const entries = this.entries();
        const next = () => {
            const { done, value } = entries.next();
            return { done, value: !done ? value[1] : undefined };
        };
        return { next, [Symbol.iterator]() { return this; } };
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        const keys = Object.keys(data$1(this)).sort();
        let i = 0;
        let j = 0;
        const next = () => {
            if (i < keys.length) {
                const values = data$1(this)[keys[i]];
                if (values && (j < values.length)) {
                    return { done: false, value: [keys[i], values[j++]] };
                }
                else {
                    i++;
                    j = 0;
                    return next();
                }
            }
            return { done: true, value: undefined };
        };
        return { next, [Symbol.iterator]() { return this; } };
    }
}
FormData.prototype[Symbol.toStringTag] = 'FormData';
/**
 * @param {FormData} formData
 * @returns {Blob}
 */
function formDataToBlob(formData) {
    const boundary = '----tabrisformdataboundary-' + Math.round(Math.random() * 100000000) + '-yradnuobatadmrofsirbat';
    const parts = [];
    for (const [name, value] of formData) {
        parts.push(`--${boundary}\r\n`);
        if (value instanceof File) {
            parts.push(`Content-Disposition: form-data; name="${name}"; filename="${value.name}"\r\n`);
            parts.push(`Content-Type: ${value.type || 'application/octet-stream'}\r\n\r\n`);
            parts.push(value);
            parts.push('\r\n');
        }
        else {
            parts.push(`Content-Disposition: form-data; name="${name}"\r\n\r\n${value}\r\n`);
        }
    }
    parts.push(`--${boundary}--`);
    return new Blob(parts, { type: 'multipart/form-data; boundary=' + boundary });
}
/**
 * @param {FormData} formData
 * @returns {{[name: string]: Array<string|File>}}
 */
function data$1(formData) {
    if (!formData[data]) {
        formData[data] = {};
    }
    return formData[data];
}
function normalize(value, filename) {
    if (value instanceof File && filename === undefined) {
        return value;
    }
    else if (value instanceof Blob) {
        return new File([value], filename === undefined ? 'blob' : filename);
    }
    return value + '';
}

const FONT_OPTIONS = {
    type: Font,
    converter: Font.from,
    validator: Font.isValidFontValue
};
class FontResources extends Resources {
    static from() {
        const builder = Resources.build(/** @type {any} */ (FONT_OPTIONS));
        return builder.from.apply(builder, arguments);
    }
    constructor(options) {
        if (arguments.length !== 1) {
            throw new Error(`Expected 1 parameter, got ${arguments.length}`);
        }
        checkType(options, Object, { name: 'parameter 1' });
        super(Object.assign({}, FONT_OPTIONS, options));
    }
}

class ImageView extends Widget {
    get _nativeType() {
        return 'tabris.ImageView';
    }
    _beforePropertyChange(name, value) {
        if (name === 'zoomEnabled' && !value) {
            this.minZoomLevel = 1;
            this.maxZoomLevel = 3;
            this.zoomLevel = 1;
        }
        else if (name === 'minZoomLevel' && value > this.zoomLevel) {
            this.zoomLevel = value;
        }
        else if (name === 'maxZoomLevel' && value < this.zoomLevel) {
            this.zoomLevel = value;
        }
    }
    /**
     * @param {string[]} properties
     */
    _reorderProperties(properties) {
        if (properties.indexOf('maxZoomLevel') !== -1) {
            properties.unshift(properties.splice(properties.indexOf('maxZoomLevel'), 1)[0]);
        }
        if (properties.indexOf('minZoomLevel') !== -1) {
            properties.unshift(properties.splice(properties.indexOf('minZoomLevel'), 1)[0]);
        }
        if (properties.indexOf('zoomEnabled') !== -1) {
            properties.unshift(properties.splice(properties.indexOf('zoomEnabled'), 1)[0]);
        }
        return super._reorderProperties(properties);
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['image', (this.image || { src: '' }).src]
        ]);
    }
}
NativeObject.defineProperties(ImageView.prototype, {
    image: { type: types.ImageValue, default: null },
    scaleMode: {
        type: types.string,
        choice: ['auto', 'fit', 'fill', 'stretch', 'none'],
        default: 'auto'
    },
    tintColor: { type: types.ColorValue, default: 'initial' },
    zoomEnabled: { type: types.boolean, default: false },
    zoomLevel: {
        type: {
            convert(value, imageView) {
                if (!imageView.zoomEnabled && value !== 1) {
                    throw new Error('zoomLevel can not be set when zoomEnabled is false');
                }
                const num = types.number.convert(value);
                if (num < imageView.minZoomLevel) {
                    throw new Error('zoomLevel can not be smaller than minZoomLevel');
                }
                if (num > imageView.maxZoomLevel) {
                    throw new Error('zoomLevel can not be larger than maxZoomLevel');
                }
                return num;
            }
        },
        nocache: true
    },
    minZoomLevel: {
        type: {
            convert(value, imageView) {
                if (!imageView.zoomEnabled && value !== 1) {
                    throw new Error('minZoomLevel can not be set when zoomEnabled is false');
                }
                const num = types.number.convert(value);
                if (num > imageView.maxZoomLevel) {
                    throw new Error('minZoomLevel can not be larger than maxZoomLevel');
                }
                return num;
            }
        },
        default: 1.0
    },
    maxZoomLevel: {
        type: {
            convert(value, imageView) {
                if (!imageView.zoomEnabled && value !== 3) {
                    throw new Error('maxZoomLevel can not be set when zoomEnabled is false');
                }
                const num = types.number.convert(value);
                if (num < imageView.minZoomLevel) {
                    throw new Error('maxZoomLevel can not be smaller than minZoomLevel');
                }
                return num;
            }
        },
        default: 3.0
    }
});
NativeObject.defineEvents(ImageView.prototype, {
    load: { native: true },
    zoom: { native: true, changes: 'zoomLevel' },
    nativeObservable: false
});

class InactivityTimer extends NativeObject {
    constructor(properties) {
        super(properties);
        this._nativeListen('timeout', true);
    }
    start() {
        this._nativeCall('start');
    }
    cancel() {
        this._nativeCall('cancel');
    }
    get _nativeType() {
        return 'tabris.InactivityTimer';
    }
}
NativeObject.defineProperties(InactivityTimer.prototype, {
    delay: {
        type: 'natural',
        default: 0
    }
});
NativeObject.defineEvents(InactivityTimer.prototype, {
    timeout: true
});

class SearchAction extends Widget {
    get _nativeType() {
        return 'tabris.SearchAction';
    }
    open() {
        this._nativeCall('open', {});
        return this;
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes().concat([['title', this.title]]);
        if (this.text) {
            result.push(['text', this.text]);
        }
        if (this.message) {
            result.push(['message', this.message]);
        }
        return result;
    }
}
NativeObject.defineProperties(SearchAction.prototype, {
    image: { type: types.ImageValue, default: null },
    placementPriority: {
        type: types.string,
        choice: ['low', 'high', 'normal'],
        default: 'normal'
    },
    title: { type: types.string, default: '' },
    proposals: {
        type: {
            convert(value) {
                if (!Array.isArray(value)) {
                    throw new Error('Not an array');
                }
                return Object.freeze(value.map(types.string.convert));
            }
        },
        default: Object.freeze([])
    },
    text: { type: types.string, nocache: true },
    message: { type: types.string, default: '' }
});
NativeObject.defineEvents(SearchAction.prototype, {
    input: { native: true },
    accept: { native: true },
    select: { native: true }
});

class NavigationView extends Composite {
    constructor(properties) {
        super(properties);
        this._nativeListen('backNavigation', true);
    }
    get _nativeType() {
        return 'tabris.NavigationView';
    }
    _initLayout() {
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
    }
    _acceptChild(child) {
        return child instanceof Page || child instanceof Action || child instanceof SearchAction;
    }
    _addChild(child, index) {
        const isTopPage = (child instanceof Page && typeof index !== 'number' || index === this.pages().length);
        if (isTopPage) {
            this.$triggerDisappear();
        }
        super._addChild(child, index);
        if (isTopPage) {
            this.$triggerAppear();
        }
    }
    _removeChild(child) {
        const isTopPage = (child instanceof Page && child === this.pages().last());
        if (isTopPage) {
            this.$triggerDisappear();
        }
        super._removeChild(child);
        if (isTopPage) {
            this.$triggerAppear();
        }
    }
    $handleBackNavigation() {
        this.$pop(this.pages().last());
    }
    $pop(page) {
        if (page && page.autoDispose) {
            page.dispose();
        }
        else if (page) {
            page._setParent(null);
        }
    }
    _listen(name, listening) {
        if (name === 'toolbarHeightChanged') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _trigger(name, event) {
        if (name === 'backNavigation') {
            this.$handleBackNavigation();
        }
        else if (name === 'toolbarHeightChanged') {
            this._triggerChangeEvent('toolbarHeight', event.toolbarHeight);
        }
        else {
            return super._trigger(name, event);
        }
    }
    $triggerAppear() {
        const topPage = this.pages().last();
        if (topPage) {
            topPage.$trigger('appear');
        }
    }
    $triggerDisappear() {
        const topPage = this.pages().last();
        if (topPage) {
            topPage.$trigger('disappear');
        }
    }
    pages(selector) {
        return this.children(selector).filter(child => child instanceof Page);
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (!this.drawerActionVisible) {
            result.push(['drawerActionVisible', 'false']);
        }
        if (!this.toolbarVisible) {
            result.push(['toolbarVisible', 'false']);
        }
        return result;
    }
}
NativeObject.defineProperties(NavigationView.prototype, {
    drawerActionVisible: { type: types.boolean, default: false },
    toolbarVisible: { type: types.boolean, default: true },
    toolbarColor: { type: types.ColorValue, default: null },
    toolbarHeight: { readonly: true },
    titleTextColor: { type: types.ColorValue, default: null },
    actionColor: { type: types.ColorValue, default: null },
    actionTextColor: { type: types.ColorValue, default: null },
    pageAnimation: {
        type: types.string,
        choice: ['default', 'none'],
        default: 'default'
    }
});
NativeObject.defineEvents(NavigationView.prototype, {
    backNavigation: true
});

class Page extends Composite {
    get _nativeType() {
        return 'tabris.Page';
    }
    /** @returns {never} */
    insertBefore() {
        throw new Error('insertBefore not supported on Page');
    }
    /** @returns {never} */
    insertAfter() {
        throw new Error('insertAfter not supported on Page');
    }
    _setParent(parent, index) {
        if (parent && !(parent instanceof NavigationView)) {
            throw new Error(`Page could not be appended to ${toValueString(parent)}`);
        }
        super._setParent(parent, index);
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([['title', this.title]]);
    }
}
NativeObject.defineProperties(Page.prototype, {
    image: { type: 'ImageValue', default: null },
    title: { type: 'string', default: '' },
    autoDispose: { type: 'boolean', default: true }
});
NativeObject.defineEvents(Page.prototype, {
    appear: true,
    disappear: true
});

class PdfView extends Widget {
    get _nativeType() {
        return 'tabris.PdfView';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['src', (this.src || '')]
        ]);
    }
    set padding(value) {
        if (tabris.device.platform !== 'iOS') {
            super.padding = value;
        }
    }
}
NativeObject.defineProperties(PdfView.prototype, {
    src: {
        type: {
            convert(value) {
                if (value != null && typeof value !== 'string' && !(value instanceof Blob)) {
                    throw new Error('Value must be of type string or Blob');
                }
                return value || null;
            },
            encode(value) {
                if (typeof value === 'string') {
                    return { type: 'uri', uri: value };
                }
                else if (value instanceof Blob) {
                    return { type: 'buffer', buffer: getBytes(value) };
                }
                return null;
            }
        },
        default: null
    },
    zoomEnabled: { type: types.boolean, default: false },
    spacing: { type: 'dimension', default: 0 },
    pageElevation: { type: 'natural', default: 0 },
    pageBackground: { type: 'ColorValue', default: 'initial' }
});
NativeObject.defineEvents(PdfView.prototype, {
    load: { native: true }
});

class Picker extends Widget {
    /**
     * @param {Partial<Picker>} properties
     */
    constructor(properties) {
        super(pick(properties, ['style']));
        Object.defineProperties(this, {
            _itemCount: { enumerable: false, writable: true, value: 0 },
            _itemText: { enumerable: false, writable: true, value: () => '' }
        });
        this.set(omit(properties, ['style']));
        tabris.on('flush', this.$flush, this);
        this.on('dispose', () => tabris.off('flush', this.$flush, this));
    }
    get _nativeType() {
        return 'tabris.Picker';
    }
    set itemCount(value) {
        try {
            const oldValue = this._itemCount;
            this._itemCount = types.natural.convert(value);
            if (this._itemCount !== oldValue) {
                Object.defineProperty(this, '$needsUpdateItems', { enumerable: false, writable: true, value: true });
                this._triggerChangeEvent('itemCount');
            }
        }
        catch (ex) {
            this._printPropertyWarning('itemCount', ex);
        }
    }
    get itemCount() {
        return this._itemCount;
    }
    set itemText(value) {
        try {
            if (!(value instanceof Function)) {
                throw new Error('Not a Function');
            }
            const oldValue = this._itemText;
            this._itemText = value;
            if (this._itemText !== oldValue) {
                Object.defineProperty(this, '$needsUpdateItems', {
                    enumerable: false, writable: true, value: true
                });
                this._triggerChangeEvent('itemText');
            }
        }
        catch (ex) {
            this._printPropertyWarning('itemText', ex);
        }
    }
    get itemText() {
        return this._itemText;
    }
    set selectionIndex(value) {
        try {
            const oldValue = this.$newSelectionIndex;
            this.$newSelectionIndex = types.integer.convert(value);
            if (this.$newSelectionIndex !== oldValue) {
                this._triggerChangeEvent('selectionIndex');
            }
        }
        catch (ex) {
            this._printPropertyWarning('selectionIndex', ex);
        }
    }
    get selectionIndex() {
        return this.$newSelectionIndex >= -1 ? this.$newSelectionIndex : this._nativeGet('selectionIndex');
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['itemCount', this.itemCount],
            ['selectionIndex', this.selectionIndex]
        ]);
    }
    $flush() {
        if (this.$needsUpdateItems) {
            const items = new Array(this.itemCount);
            for (let index = 0; index < items.length; index++) {
                items[index] = this.itemText(index) + '';
            }
            this._nativeSet('items', items);
            tabris._nativeBridge.flush();
            this.$needsUpdateItems = false;
        }
        if (this.$newSelectionIndex >= -1) {
            this._nativeSet('selectionIndex', this.$newSelectionIndex);
            this._triggerChangeEvent('selectionIndex', this.$newSelectionIndex);
            tabris._nativeBridge.flush();
            this.$newSelectionIndex = undefined;
        }
    }
    _trigger(name, event) {
        if (name === 'select') {
            return super._trigger('select', { index: event.selectionIndex });
        }
        return super._trigger(name, event);
    }
}
NativeObject.defineProperties(Picker.prototype, {
    style: {
        type: types.string,
        choice: ['default', 'outline', 'fill', 'underline', 'none'],
        const: true,
        default: 'default'
    },
    message: { type: types.string, default: '' },
    floatMessage: { type: types.boolean, default: true },
    borderColor: { type: types.ColorValue, default: null },
    textColor: { type: types.ColorValue, default: null },
    font: { type: types.FontValue, default: null }
});
NativeObject.defineChangeEvents(Picker.prototype, [
    'selectionIndex',
    'itemText',
    'itemCount'
]);
NativeObject.defineEvents(Picker.prototype, {
    select: {
        native: true,
        changes: 'selectionIndex',
        changeValue: ev => 'index' in ev ? ev.index : ev.selectionIndex
    }
});

class Pbkdf2 extends NativeObject {
    constructor(properties) {
        super(properties);
        this._nativeListen('done', true);
    }
    start(parameters) {
        this._nativeCall('start', parameters);
    }
    pbkdf2Sync(parameters) {
        return this._nativeCall('pbkdf2Sync', parameters);
    }
    get _nativeType() {
        return 'tabris.pkcs5.Pbkdf2';
    }
}
class Pkcs5 {
    pbkdf2(password, salt, iterationCount, keySize) {
        return new Promise$1((resolve) => {
            if (arguments.length < 4) {
                throw new Error('Not enough arguments to pbkdf2');
            }
            validatePbkdf2Arguments(password, salt, iterationCount, keySize);
            const pbkdf2 = new Pbkdf2();
            pbkdf2.on('done', (event) => {
                pbkdf2.dispose();
                resolve(event.key);
            });
            // TODO: transfer salt as typed array once iOS 9 support is discontinued
            pbkdf2.start({ password, salt: toArray(salt), iterationCount, keySize });
        });
    }
    pbkdf2Sync(password, salt, iterationCount, keySize) {
        if (arguments.length < 4) {
            throw new Error('Not enough arguments to pbkdf2Sync');
        }
        validatePbkdf2Arguments(password, salt, iterationCount, keySize);
        const pbkdf2 = new Pbkdf2();
        const result = pbkdf2.pbkdf2Sync({ password, salt, iterationCount, keySize });
        pbkdf2.dispose();
        return result;
    }
}
function validatePbkdf2Arguments(password, salt, iterationCount, keySize) {
    if (typeof password !== 'string') {
        throw new Error('Invalid type for password in pbkdf2');
    }
    if (!(salt instanceof Uint8Array)) {
        throw new Error('Invalid type for salt in pbkdf2');
    }
    if (typeof iterationCount !== 'number' || iterationCount <= 0) {
        throw new Error('Invalid number for iterationCount in pbkdf2');
    }
    if (typeof keySize !== 'number' || keySize <= 0) {
        throw new Error('Invalid number for keySize in pbkdf2');
    }
}
function toArray(typedArray) {
    const array = new Array(typedArray.length);
    for (let i = 0; i < typedArray.length; i++) {
        array[i] = typedArray[i];
    }
    return array;
}

class Process {
    constructor() {
        if (arguments[0] !== true || arguments.length !== 2) {
            throw new Error('Process can not be created');
        }
        /** @type {import('./App').default} */
        const app = arguments[1].app;
        /** @type {import('./Device').default} */
        const device = arguments[1].device;
        this.env = {
            NODE_ENV: app.debugBuild ? 'development' : 'production'
        };
        this.platform = (device.platform || '').toLowerCase();
        this.argv = ['tabris', './'];
    }
}
function create$a(tabris) {
    return new Process(true, tabris);
}

class ProgressEvent extends Event {
    constructor(type, config) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to ProgressEvent');
        }
        super(type, config);
        Object.defineProperties(this, {
            $lengthComputable: { enumerable: false, writable: true, value: config && config.lengthComputable || false },
            $loaded: { enumerable: false, writable: true, value: config && config.loaded || 0 },
            $total: { enumerable: false, writable: true, value: config && config.total || 0 }
        });
    }
    get lengthComputable() {
        return this.$lengthComputable;
    }
    get loaded() {
        return this.$loaded;
    }
    get total() {
        return this.$total;
    }
}

class ProgressBar extends Widget {
    get _nativeType() {
        return 'tabris.ProgressBar';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['selection', this.selection],
            ['minimum', this.minimum],
            ['maximum', this.maximum]
        ]);
    }
}
NativeObject.defineProperties(ProgressBar.prototype, {
    minimum: { type: types.integer, default: 0 },
    maximum: { type: types.integer, default: 100 },
    tintColor: { type: types.ColorValue, default: null },
    selection: { type: types.integer, default: 0 },
    state: {
        type: types.string,
        choice: ['normal', 'paused', 'error'],
        default: 'normal'
    }
});

class Popover extends Popup {
    static open(value) {
        let popover;
        if (value instanceof Popover) {
            popover = value;
        }
        else {
            throw new Error('Not a Popover: ' + typeof value);
        }
        return popover.open();
    }
    /**
     * @param {Partial<Popover>=} properties
     */
    constructor(properties) {
        super(properties);
        Object.defineProperty(this, 'contentView', { value: create$8() });
        this._nativeListen('close', true);
        this._autoDispose = true;
        this._nativeSet('contentView', this.contentView.cid);
    }
    get _nativeType() {
        return 'tabris.Popover';
    }
    _trigger(name, event) {
        if (name === 'close') {
            super._trigger('close', event);
            this.dispose();
        }
        else {
            return super._trigger(name, event);
        }
    }
    _dispose() {
        if (!this.isDisposed()) {
            Composite.prototype._dispose.call(this.contentView);
        }
        super._dispose();
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        const result = super[JSX.jsxFactory](Type, normalAttributes);
        if (children && children.length) {
            result.contentView.append(children);
        }
        return result;
    }
}
NativeObject.defineProperties(Popover.prototype, {
    anchor: { type: 'Widget', default: null },
    width: { type: 'dimension', nocache: true, nullable: true },
    height: { type: 'dimension', nocache: true, nullable: true }
});
NativeObject.defineEvents(Popover.prototype, {
    close: {}
});

class NavigationBar extends NativeObject {
    get _nativeType() {
        return 'tabris.NavigationBar';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('NavigationBar can not be created');
        }
        super._nativeCreate();
    }
    _setParent() {
        throw new Error('Parent of NavigationBar can not be changed');
    }
    _dispose() {
        throw new Error('NavigationBar can not be disposed');
    }
}
NativeObject.defineProperties(NavigationBar.prototype, {
    theme: {
        type: types.string,
        choice: ['default', 'light', 'dark'],
        default: 'default'
    },
    displayMode: {
        type: types.string,
        choice: ['default', 'float', 'hide'],
        default: 'default'
    },
    height: {
        type: types.number,
        readonly: true,
        nocache: true
    },
    background: {
        type: types.ColorValue,
        nocache: true
    }
});
function create$b() {
    return new NavigationBar(true);
}

class RadioButton extends Widget {
    get _nativeType() {
        return 'tabris.RadioButton';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['text', this.text],
            ['checked', this.checked]
        ]);
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text'));
    }
}
NativeObject.defineProperties(RadioButton.prototype, {
    text: { type: 'string', default: '' },
    checked: { type: 'boolean', nocache: true },
    textColor: { type: 'ColorValue', default: 'initial' },
    tintColor: { type: 'ColorValue', default: 'initial' },
    checkedTintColor: { type: 'ColorValue', default: 'initial' },
    font: { type: 'FontValue', default: 'initial' }
});
NativeObject.defineEvents(RadioButton.prototype, {
    select: { native: true, changes: 'checked' }
});

class RefreshComposite extends Composite {
    get _nativeType() {
        return 'tabris.RefreshComposite';
    }
    _listen(name, listening) {
        if (name === 'refresh') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
}
NativeObject.defineProperties(RefreshComposite.prototype, {
    refreshEnabled: {
        type: 'boolean',
        default: true
    },
    refreshIndicator: {
        type: 'boolean',
        nocache: true
    },
    refreshMessage: {
        type: 'string',
        default: ''
    }
});
NativeObject.defineEvents(RefreshComposite.prototype, {
    refresh: { native: true }
});

class ScrollView extends Composite {
    get _nativeType() {
        return 'tabris.ScrollView';
    }
    scrollToY(offset, options) {
        this._nativeCall('scrollToY', {
            offset,
            animate: options && 'animate' in options ? !!options.animate : true
        });
        return this;
    }
    scrollToX(offset, options) {
        this._nativeCall('scrollToX', {
            offset,
            animate: options && 'animate' in options ? !!options.animate : true
        });
        return this;
    }
    _listen(name, listening) {
        if (name === 'scrollXStateChanged') {
            this._nativeListen('scrollXStateChanged', listening);
        }
        else if (name === 'scrollYStateChanged') {
            this._nativeListen('scrollYStateChanged', listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _getXMLAttributes() {
        const offset = this.direction === 'vertical' ? 'offsetY' : 'offsetX';
        return super._getXMLAttributes().concat([
            ['direction', this.direction],
            [offset, this[offset]]
        ]);
    }
}
NativeObject.defineProperties(ScrollView.prototype, {
    direction: {
        type: types.string,
        choice: ['horizontal', 'vertical'],
        default: 'vertical',
        const: true
    },
    offsetX: { type: types.number, nocache: true, readonly: true },
    offsetY: { type: types.number, nocache: true, readonly: true },
    scrollbarVisible: { type: types.boolean, default: true },
    scrollXState: { type: types.string, nocache: true, readonly: true },
    scrollYState: { type: types.string, nocache: true, readonly: true }
});
NativeObject.defineEvents(ScrollView.prototype, {
    scrollX: {
        native: true,
        nativeObservable: false,
        changes: 'offsetX',
        changeValue: 'offset'
    },
    scrollY: {
        native: true,
        nativeObservable: false,
        changes: 'offsetY',
        changeValue: 'offset'
    }
});

function Setter(arg1, arg2, arg3) {
    if (arguments.length < 1 || arguments.length > 3) {
        throw new TypeError(`Expected 1-2 arguments, got ${arguments.length}`);
    }
    if (arguments.length === 1) {
        const setterAttr = arg1;
        checkType(setterAttr, Object, { name: 'parameter 1' });
        checkType(setterAttr.attribute, String, { name: 'attribute' });
        checkType(setterAttr.children, Array, { name: 'children' });
        if (setterAttr.children.length < 1) {
            throw new TypeError('value is missing');
        }
        if (setterAttr.children.length > 1) {
            throw new TypeError('too many child elements');
        }
        return Setter(setterAttr.target, { [setterAttr.attribute]: setterAttr.children[0] });
    }
    else if (arguments.length === 2) {
        const target = arg1;
        const attr = arg2;
        checkType(target, Function, { name: 'target', typeName: 'a constructor' });
        checkType(attr, Object, { name: 'parameter 2' });
        checkType(target.prototype, NativeObject, { name: 'target', typeName: 'a widget or dialog constructor' });
        const result = Object.assign({}, arg2);
        Object.defineProperty(result, setterTargetType, {
            enumerable: false, value: arg1
        });
        return result;
    }
    else {
        const target = arg1;
        const selector = arg2;
        const attr = arg3;
        checkType(selector, String, { name: 'parameter 2' });
        checkType(attr, Object, { name: 'parameter 3' });
        return {
            [selector]: Setter(target, attr)
        };
    }
}
const Apply = (attr) => {
    const setterAttr = { target: Composite, attribute: 'apply', children: null };
    if (attr.attr instanceof Object
        && attr.children
        && attr.children[0] instanceof Object) {
        throw new Error('RuleSet given twice');
    }
    const ruleSet = attr.attr || attr.children[0];
    if (!(ruleSet instanceof Object)) {
        throw new TypeError('No RuleSet found');
    }
    if (attr.target && attr.selector) {
        setterAttr.children = [{ [attr.selector]: Setter(attr.target, ruleSet) }];
    }
    else if (attr.target) {
        setterAttr.children = [Setter(attr.target, ruleSet)];
    }
    else if (attr.selector) {
        setterAttr.children = [{ [attr.selector]: ruleSet }];
    }
    else {
        setterAttr.children = [ruleSet];
    }
    const applySetter = Setter(setterAttr);
    if (!Array.isArray(applySetter.apply)) {
        applySetter.apply = [applySetter.apply];
    }
    return applySetter;
};

class SizeMeasurement extends NativeObject {
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('SizeMeasurement can not be created');
        }
        super._nativeCreate();
    }
    get _nativeType() {
        return 'tabris.SizeMeasurement';
    }
    measureTexts(configs) {
        return new Promise$1((resolve, reject) => {
            if (arguments.length < 1) {
                throw new Error('Not enough arguments to measure texts');
            }
            if (!Array.isArray(configs)) {
                throw new Error('The text measurement configs have to be an array');
            }
            this._nativeCall('measureTexts', {
                configs: this._createTextMeasureConfigs(configs),
                onResult: (result) => resolve(result),
                onError: (error) => reject(new Error(error))
            });
        });
    }
    measureTextsSync(configs) {
        if (arguments.length < 1) {
            throw new Error('Not enough arguments to measure texts');
        }
        if (!Array.isArray(configs)) {
            throw new Error('The text measurement configs have to be an array');
        }
        return this._nativeCall('measureTextsSync', {
            configs: this._createTextMeasureConfigs(configs)
        });
    }
    _createTextMeasureConfigs(configs) {
        return configs.map((config) => ({
            text: checkText(config.text),
            font: checkFont(config.font),
            markupEnabled: !!config.markupEnabled,
            maxWidth: 'maxWidth' in config ? types.dimension.convert(config.maxWidth) : undefined
        }));
    }
    dispose() {
        throw new Error('Cannot dispose sizeMeasurement object');
    }
}
function checkText(text) {
    if (typeof text !== 'string') {
        throw new Error('A text measurement configuration has to provide a "text" string');
    }
    return text;
}
function checkFont(fontValue) {
    const font = Font.from(fontValue);
    if (!font.size) {
        throw new Error('A text measurement configuration has to provide a font size via the "font" property');
    }
    return font;
}
function create$c() {
    return new SizeMeasurement(true);
}

class Slider extends Widget {
    get _nativeType() {
        return 'tabris.Slider';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['selection', this.selection],
            ['minimum', this.minimum],
            ['maximum', this.maximum]
        ]);
    }
}
NativeObject.defineProperties(Slider.prototype, {
    minimum: { type: 'integer', default: 0 },
    maximum: { type: 'integer', default: 100 },
    selection: { type: 'integer', nocache: true },
    tintColor: { type: 'ColorValue', default: 'initial' }
});
NativeObject.defineEvents(Slider.prototype, {
    select: { native: true, changes: 'selection' }
});

class StatusBar extends NativeObject {
    get _nativeType() {
        return 'tabris.StatusBar';
    }
    /** @override */
    _nativeCreate(param) {
        if (param !== true) {
            throw new Error('StatusBar can not be created');
        }
        super._nativeCreate();
    }
    _listen(name, listening) {
        if (name === 'tap') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _setParent() {
        throw new Error('Parent of StatusBar can not be changed');
    }
    _dispose() {
        throw new Error('StatusBar can not be disposed');
    }
}
NativeObject.defineProperties(StatusBar.prototype, {
    theme: {
        type: types.string,
        choice: ['default', 'light', 'dark'],
        default: 'default'
    },
    displayMode: {
        type: types.string,
        choice: ['default', 'float', 'hide'],
        default: 'default'
    },
    height: {
        type: types.number,
        readonly: true,
        nocache: true
    },
    background: { type: types.ColorValue, nocache: true }
});
NativeObject.defineEvents(StatusBar.prototype, {
    tap: true
});
function create$d() {
    return new StatusBar(true);
}

class Switch extends Widget {
    get _nativeType() {
        return 'tabris.Switch';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['text', this.text],
            ['checked', this.checked]
        ]);
    }
}
NativeObject.defineProperties(Switch.prototype, {
    checked: { type: 'boolean', nocache: true },
    thumbOnColor: { type: 'ColorValue', default: 'initial' },
    thumbOffColor: { type: 'ColorValue', default: 'initial' },
    trackOnColor: { type: 'ColorValue', default: 'initial' },
    trackOffColor: { type: 'ColorValue', default: 'initial' }
});
NativeObject.defineEvents(Switch.prototype, {
    select: { native: true, changes: 'checked' }
});

class TabFolder extends Composite {
    /**
     * @param {Partial<TabFolder>=} properties
     */
    constructor(properties) {
        super(properties);
        Object.defineProperty(this, '$previousSelection', {
            enumerable: false, writable: true, value: undefined
        });
        this._nativeListen('select', true);
    }
    get _nativeType() {
        return 'tabris.TabFolder';
    }
    set selectionIndex(index) {
        const children = this._children();
        if (!children[index]) {
            hint(this, 'Can not set selectionIndex to ' + index + ', value out of bounds');
            return;
        }
        this.selection = children[index];
    }
    get selectionIndex() {
        return this._children().indexOf(this.selection);
    }
    _scheduleRenderChildren() {
        // Skip the queue mechanism to avoid tab selection-before-appended issue
        this.$flushChildren();
    }
    _nativeListen(event, state) {
        if (event === 'select' && !state) {
            return;
        }
        super._nativeListen(event, state);
    }
    _initLayout() {
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
    }
    _acceptChild(child) {
        return child instanceof Tab;
    }
    _addChild(child, index) {
        super._addChild(child, index);
        if (this.$children.indexOf(child) === 0) {
            child.$trigger('appear');
            this.$previousSelection = child;
        }
    }
    _removeChild(child) {
        if (!this._inDispose) {
            const childIndex = this.$children.indexOf(child);
            const rightNeighbor = this.$children[childIndex + 1];
            const leftNeighbor = this.$children[childIndex - 1];
            const newSelection = rightNeighbor || leftNeighbor;
            if (newSelection) {
                this.selection = newSelection;
            }
            else {
                this._triggerChangeEvent('selection', null);
            }
        }
        super._removeChild(child);
    }
    _listen(name, listening) {
        if (name === 'selectionIndexChanged') {
            this._onoff('selectionChanged', listening, this.$triggerSelectionIndexChanged);
        }
        else {
            super._listen(name, listening);
        }
    }
    _trigger(name, event) {
        if (name === 'select') {
            const selection = tabris._nativeObjectRegistry.find(event.selection);
            const result = super._trigger('select', { selection });
            selection._trigger('select');
            if (this.$previousSelection === selection) {
                selection._trigger('reselect');
            }
            this._triggerChangeEvent('selection', selection);
            return result;
        }
        if (name === 'scroll') {
            const selection = event.selection ? tabris._nativeObjectRegistry.find(event.selection) : null;
            return super._trigger('scroll', { selection, offset: event.offset });
        }
        return super._trigger(name, event);
    }
    _triggerChangeEvent(name, value) {
        if (name === 'selection') {
            if (this.$previousSelection !== value) {
                super._triggerChangeEvent(name, value);
                if (this.$previousSelection) {
                    this.$previousSelection._trigger('disappear');
                }
                if (value) {
                    value._trigger('appear');
                }
                this.$previousSelection = value;
            }
        }
        else {
            super._triggerChangeEvent(name, value);
        }
    }
    _getXMLAttributes() {
        const tab = this.selection;
        return super._getXMLAttributes().concat([
            ['selection', tab ? tab.toString() : '']
        ]);
    }
    $triggerSelectionIndexChanged({ value: tab }) {
        super._triggerChangeEvent('selectionIndex', this._children().indexOf(tab));
    }
}
NativeObject.defineProperties(TabFolder.prototype, {
    paging: { type: types.boolean, default: false },
    tabBarLocation: {
        choice: ['top', 'bottom', 'hidden', 'auto'],
        default: 'auto',
        const: true
    },
    tabMode: {
        type: types.string,
        choice: ['fixed', 'scrollable'],
        default: 'fixed',
        const: true
    },
    selection: {
        type: {
            convert(value, tabFolder) {
                const tab = types.Widget.convert(value);
                if (!tab || !(tab instanceof Tab) || tabFolder._children().indexOf(tab) < 0) {
                    throw new Error('Can not set selection to ' + toValueString(value));
                }
                return tab;
            },
            encode: types.Widget.encode,
            decode(value, tabFolder) {
                if (!tabFolder._children().length) {
                    return null;
                }
                return types.Widget.decode(value);
            }
        },
        nocache: true
    },
    tabTintColor: { type: types.ColorValue, default: 'initial' },
    selectedTabTintColor: { type: types.ColorValue, default: 'initial' },
    tabBarBackground: { type: types.ColorValue, default: 'initial' },
    tabBarElevation: { type: types.number, nocache: true },
    selectedTabIndicatorTintColor: { type: types.ColorValue, default: 'initial' }
});
NativeObject.defineChangeEvents(TabFolder.prototype, [
    'selectionIndex'
]);
NativeObject.defineEvents(TabFolder.prototype, {
    scroll: { native: true },
    select: { native: true }
});
TabFolder.prototype[JSX.jsxFactory] = createElement$3;
/** @this {import("../JsxProcessor").default} */
function createElement$3(Type, attributes) {
    const result = Composite.prototype[JSX.jsxFactory].call(this, Type, omit(attributes, ['selection', 'selectionIndex']));
    result.set(pick(attributes, ['selection', 'selectionIndex']));
    return result;
}

class Tab extends Composite {
    get _nativeType() {
        return 'tabris.Tab';
    }
    _setParent(parent, index) {
        if (parent && !(parent instanceof TabFolder)) {
            throw new Error(`Tab could not be appended to ${toValueString(parent)}`);
        }
        super._setParent(parent, index);
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([['title', this.title]]);
    }
}
NativeObject.defineProperties(Tab.prototype, {
    title: { type: 'string', default: '' },
    image: { type: 'ImageValue', default: null },
    selectedImage: { type: 'ImageValue', default: null },
    badge: { type: 'natural', default: 0 },
    badgeColor: { type: 'ColorValue', default: 'initial' }
});
NativeObject.defineEvents(Tab.prototype, {
    disappear: true,
    appear: true,
    select: true,
    reselect: true
});

const TEXT_OPTIONS = {
    validator: value => typeof value === 'string'
};
class TextResources extends Resources {
    static from() {
        const builder = Resources.build(/** @type {any} */ (TEXT_OPTIONS));
        return builder.from.apply(builder, arguments);
    }
    constructor(options) {
        if (arguments.length !== 1) {
            throw new Error(`Expected 1 parameter, got ${arguments.length}`);
        }
        checkType(options, Object, { name: 'parameter 1' });
        super(Object.assign({}, TEXT_OPTIONS, options));
    }
}

class TextView extends Widget {
    get _nativeType() {
        return 'tabris.TextView';
    }
    _getXMLContent() {
        let content = super._getXMLContent();
        if (this._shouldPrintTextAsXMLContent()) {
            content = content.concat(this.text.split('\n').map(line => '  ' + line));
        }
        return content;
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (this.markupEnabled) {
            result.push(['markupEnabled', 'true']);
        }
        if (!this._shouldPrintTextAsXMLContent()) {
            result.push(['text', this.text]);
        }
        return result;
    }
    _shouldPrintTextAsXMLContent() {
        return this.markupEnabled || this.text.length > 25 || this.text.indexOf('\n') !== -1;
    }
    _listen(name, listening) {
        if (name === 'tapLink') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text', attributes ? attributes.markupEnabled : false));
    }
}
NativeObject.defineProperties(TextView.prototype, {
    alignment: {
        type: types.string,
        choice: ['left', 'right', 'centerX'],
        default: 'left'
    },
    markupEnabled: { type: types.boolean, default: false },
    lineSpacing: { type: types.number, default: 1 },
    selectable: { type: types.boolean, default: false },
    maxLines: {
        type: {
            convert: value => value <= 0 ? null : types.natural.convert(value)
        },
        default: null,
        nullable: true
    },
    text: { type: types.string, default: '' },
    textColor: { type: types.ColorValue, default: 'initial' },
    font: { type: types.FontValue, default: 'initial' }
});
NativeObject.defineEvents(TextView.prototype, {
    tapLink: { native: true }
});

class TimeDialog extends Popup {
    static open(value) {
        let timeDialog;
        if (value instanceof TimeDialog) {
            timeDialog = value;
        }
        else if (value instanceof Date) {
            timeDialog = new TimeDialog({ date: value });
        }
        else {
            timeDialog = new TimeDialog();
        }
        return timeDialog.open();
    }
    /**
     * @param {Partial<TimeDialog>=} properties
     */
    constructor(properties) {
        super(properties);
        this._nativeListen('close', true);
        this._nativeListen('select', true);
        this._autoDispose = true;
    }
    get _nativeType() {
        return 'tabris.TimeDialog';
    }
    _trigger(name, event) {
        if (name === 'close') {
            this._handleCloseEvent(event);
        }
        else if (name === 'select') {
            event.date = new Date(event.date);
            super._trigger('select', event);
            this._handleCloseEvent(event);
        }
        else {
            return super._trigger(name, event);
        }
    }
    _handleCloseEvent(event) {
        super._trigger('close', event);
        this.dispose();
    }
}
NativeObject.defineProperties(TimeDialog.prototype, {
    date: { type: types.Date, default: null }
});
NativeObject.defineEvents(TimeDialog.prototype, {
    select: { native: true },
    close: { native: true }
});

class ToggleButton extends Widget {
    get _nativeType() {
        return 'tabris.ToggleButton';
    }
    _getXMLAttributes() {
        return super._getXMLAttributes().concat([
            ['text', this.text],
            ['checked', this.checked]
        ]);
    }
    /** @this {import("../JsxProcessor").default} */
    [JSX.jsxFactory](Type, attributes) {
        const children = this.getChildren(attributes);
        const normalAttributes = this.withoutChildren(attributes);
        return super[JSX.jsxFactory](Type, this.withContentText(normalAttributes, children, 'text'));
    }
}
NativeObject.defineProperties(ToggleButton.prototype, {
    text: { type: types.string, default: '' },
    image: { type: types.ImageValue, default: null },
    checked: { type: types.boolean, nocache: true },
    alignment: {
        type: types.string,
        choice: ['left', 'right', 'centerX'],
        default: 'centerX'
    },
    textColor: { type: types.ColorValue, default: 'initial' },
    font: { type: types.FontValue, default: 'initial' }
});
NativeObject.defineEvents(ToggleButton.prototype, {
    select: { native: true, changes: 'checked' }
});

class Video extends Widget {
    get _nativeType() {
        return 'tabris.Video';
    }
    _listen(name, listening) {
        if (name === 'stateChanged' || name === 'speedChanged') {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    _trigger(name, event) {
        if (name === 'stateChanged') {
            return this._triggerChangeEvent('state', event.state);
        }
        else if (name === 'speedChanged') {
            return this._triggerChangeEvent('speed', event.speed);
        }
        return super._trigger(name, event);
    }
    pause() {
        this._nativeCall('pause');
    }
    play(speed) {
        this._nativeCall('play', {
            speed: arguments.length > 0 ? types.number.convert(speed) : 1
        });
    }
    seek(position) {
        this._nativeCall('seek', { position: types.number.convert(position) });
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (this.url) {
            result.push(['url', this.url]);
        }
        result.push(['state', this.state]);
        if (this.state === 'play') {
            result.push(['speed', this.speed]);
        }
        if (this.state !== 'empty') {
            result.push(['position', this.position]);
        }
        if (this.duration) {
            result.push(['duration', this.duration]);
        }
        return result;
    }
}
NativeObject.defineProperties(Video.prototype, {
    url: { type: 'string', default: '' },
    controlsVisible: { type: 'boolean', default: true },
    autoPlay: { type: 'boolean', default: true },
    speed: { readonly: true, nocache: true },
    position: { readonly: true, nocache: true },
    duration: { readonly: true, nocache: true },
    state: { readonly: true, nocache: true }
});

const EVENT_TYPES = ['navigate', 'load', 'download', 'message'];
class WebView extends Widget {
    get _nativeType() {
        return 'tabris.WebView';
    }
    _listen(name, listening) {
        if (EVENT_TYPES.includes(name)) {
            this._nativeListen(name, listening);
        }
        else {
            super._listen(name, listening);
        }
    }
    postMessage(data, targetOrigin) {
        this._nativeCall('postMessage', {
            data,
            origin: targetOrigin
        });
        return this;
    }
    goBack() {
        this._nativeCall('goBack');
    }
    goForward() {
        this._nativeCall('goForward');
    }
    _loadData(data, mimeType) {
        this._nativeCall('loadData', { data, mimeType });
    }
    _getXMLContent() {
        let content = super._getXMLContent();
        if (this.html) {
            content = content.concat(this.html.split('\n').map(line => '  ' + line));
        }
        return content;
    }
    _getXMLAttributes() {
        const result = super._getXMLAttributes();
        if (this.url) {
            result.push(['url', this.url]);
        }
        return result;
    }
}
NativeObject.defineProperties(WebView.prototype, {
    url: { type: 'string', nocache: true },
    html: { type: 'string', nocache: true },
    headers: { type: 'any', default: Object.freeze({}) },
    canGoBack: { type: 'boolean', readonly: true, nocache: true },
    canGoForward: { type: 'boolean', readonly: true, nocache: true },
    initScript: { type: 'string', default: null, nullable: true }
});
NativeObject.defineEvents(WebView.prototype, {
    load: { native: true },
    message: { native: true }
});

const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;
const CONSTANTS = {
    CONNECTING: { value: CONNECTING },
    OPEN: { value: OPEN },
    CLOSING: { value: CLOSING },
    CLOSED: { value: CLOSED }
};
const EVENT_TYPES$1 = ['open', 'message', 'close', 'error'];
class _WebSocket extends NativeObject {
    constructor(properties) {
        super(properties);
        EVENT_TYPES$1.forEach(type => this._nativeListen(type, true));
    }
    get _nativeType() {
        return 'tabris.WebSocket';
    }
}
NativeObject.defineProperties(_WebSocket.prototype, {
    url: { type: 'string', default: '' },
    protocol: { type: 'any', default: '' },
    binaryType: { type: 'string', default: 'blob' },
    bufferedAmount: { type: 'number', nocache: true }
});
class WebSocket {
    constructor(url, protocol = '') {
        if (typeof url !== 'string') {
            throw new Error(`WebSocket url ${toValueString(url)} is not a string`);
        }
        const scheme = extractScheme(url);
        if (!(scheme === 'ws' || scheme === 'wss')) {
            throw new Error('The WebSocket url has to have a scheme of \'ws\' or \'wss\' but is \'' + scheme + '\'');
        }
        if (typeof protocol !== 'string' && !Array.isArray(protocol)) {
            throw new Error('The WebSocket protocol has too be a string or an array of strings');
        }
        const protocols = Array.isArray(protocol) ? protocol : [protocol];
        this.url = url;
        this.readyState = CONNECTING;
        this.protocol = '';
        this.extensions = '';
        addDOMEventTargetMethods(this);
        defineEventHandlerProperties(this, EVENT_TYPES$1);
        Object.defineProperty(this, '_nativeObject', {
            enumerable: false, writable: false, value: this.$createProxy(url, protocols)
        });
    }
    $createProxy(url, protocols) {
        return new _WebSocket({
            url,
            protocol: protocols
        }).on('open', event => {
            this.readyState = OPEN;
            this.protocol = event.protocol;
            this.extensions = event.extensions;
            this.dispatchEvent(Object.assign(new Event('open'), omit(event, ['target', 'type', 'timeStamp'])));
        }).on('message', event => {
            if (this.readyState === OPEN) {
                this.dispatchEvent(Object.assign(new Event('message'), omit(event, ['target', 'type', 'timeStamp'])));
            }
        }).on('close', event => {
            this.readyState = CLOSED;
            this.dispatchEvent(Object.assign(new Event('close'), omit(event, ['target', 'type', 'timeStamp'])));
        }).on('error', event => {
            this.readyState = CLOSED;
            this.dispatchEvent(Object.assign(new Event('error'), omit(event, ['target', 'type', 'timeStamp'])));
        });
    }
    set binaryType(binaryType) {
        this._nativeObject.binaryType = binaryType;
    }
    get binaryType() {
        return this._nativeObject.binaryType;
    }
    set bufferedAmount(bufferedAmount) {
        hint(this, 'Can not set read-only property "bufferedAmount"');
    }
    get bufferedAmount() {
        return this._nativeObject.bufferedAmount;
    }
    send(data) {
        if (this.readyState === CONNECTING) {
            throw new Error('Can not \'send\' WebSocket message when WebSocket state is CONNECTING');
        }
        if (typeof data === 'string') {
            this._nativeObject._nativeCall('send', { data });
        }
        else if (isReadable(data)) {
            this._nativeObject._nativeCall('send', { data: read(data) });
        }
        else {
            throw new Error('Data of type ' + typeof data + ' is not supported in WebSocket \'send\' operation');
        }
    }
    close(code, reason) {
        if (code &&
            (typeof code !== 'number' || !(typeof code === 'number' && (code === 1000 || code >= 3000 && code <= 4999)))) {
            throw new Error('A given close code has to be either 1000 or in the range 3000 - 4999 inclusive');
        }
        if (reason && getStringByteSize(reason) > 123) {
            throw new Error('The close reason can not be larger than 123 utf-8 bytes');
        }
        if (this.readyState !== CLOSING && this.readyState !== CLOSED) {
            this.readyState = CLOSING;
            const properties = {};
            if (code) {
                properties.code = code;
            }
            if (reason) {
                properties.reason = reason;
            }
            this._nativeObject._nativeCall('close', properties);
        }
    }
}
Object.defineProperties(WebSocket, CONSTANTS);
Object.defineProperties(WebSocket.prototype, CONSTANTS);
function getStringByteSize(input) {
    let len = 0;
    // TODO: workaround for https://github.com/babel/babili/issues/430
    if (!input.length) {
        return 0;
    }
    for (let i = 0; i < input.length; i++) {
        const code = input.charCodeAt(i);
        if (code <= 0x7f) {
            len += 1;
        }
        else if (code <= 0x7ff) {
            len += 2;
        }
        else if (code >= 0xd800 && code <= 0xdfff) {
            // Surrogate pair: These take 4 bytes in UTF-8 and 2 chars in UCS-2
            // (Assume next char is the other [valid] half and just skip it)
            len += 4;
            i++;
        }
        else if (code < 0xffff) {
            len += 3;
        }
        else {
            len += 4;
        }
    }
    return len;
}
function extractScheme(url) {
    const match = /^(\S+?):/.exec(url);
    return match ? match[1] : null;
}

const EVENT_TYPES$2 = ['message', 'error', 'messageerror'];
class _Worker extends NativeObject {
    get _nativeType() {
        return 'tabris.Worker';
    }
}
NativeObject.defineProperty(_Worker.prototype, 'scriptPath', { type: 'string', default: '' });
NativeObject.defineEvents(_Worker.prototype, {
    message: { native: true },
    error: { native: true },
    messageError: true
});
class Worker {
    constructor(scriptPath) {
        if (typeof scriptPath !== 'string') {
            throw new Error('The Worker script path has to be of type string');
        }
        addDOMEventTargetMethods(this);
        defineEventHandlerProperties(this, EVENT_TYPES$2);
        Object.defineProperty(this, '_nativeObject', {
            enumerable: false, writable: false, value: this.$createProxy({ scriptPath })
        });
    }
    $createProxy(scriptPath) {
        return new _Worker(scriptPath)
            .onMessage((event) => {
            this.dispatchEvent(Object.assign(new Event('message'), omit(event, ['target', 'type', 'timeStamp'])));
        }).onError((event) => {
            this.dispatchEvent(Object.assign(new Event('error'), omit(event, ['target', 'type', 'timeStamp'])));
        }).onMessageError((event) => {
            this.dispatchEvent(Object.assign(new Event('messageerror'), omit(event, ['target', 'type', 'timeStamp'])));
        });
    }
    postMessage(message, transferList) {
        this._validateMessage(message);
        this._nativeObject._nativeCall('postMessage', { message, transferList });
    }
    _validateMessage(message) {
        if (!this._isValidMessage(message)) {
            this.dispatchEvent(Object.assign(new Event('messageerror')));
        }
        else {
            if (message instanceof Array) {
                for (let i = 0; i < message.length; i++) {
                    this._validateMessage(message[i]);
                }
            }
            else if (typeof (message) === 'object') {
                for (const property in message) {
                    if (Object.prototype.hasOwnProperty.call(message, property)) {
                        this._validateMessage(message[property]);
                    }
                }
            }
        }
    }
    _isValidMessage(message) {
        return message === undefined ||
            message === null ||
            typeof message === 'string' ||
            typeof message === 'number' ||
            typeof message === 'boolean' ||
            message &&
                (message.constructor === Object ||
                    message.constructor === Array ||
                    message.constructor === DataView ||
                    message.constructor === ArrayBuffer ||
                    message.constructor === ImageData);
    }
    terminate() {
        this._nativeObject._nativeCall('terminate');
    }
}

class HttpRequest extends NativeObject {
    constructor() {
        super();
        this._nativeListen('stateChanged', true);
        this._nativeListen('downloadProgress', true);
        this._nativeListen('uploadProgress', true);
    }
    abort() {
        this._nativeCall('abort', {});
    }
    send(config) {
        this._nativeCall('send', config);
    }
    get _nativeType() {
        return 'tabris.HttpRequest';
    }
}

// XHR Spec: https://xhr.spec.whatwg.org/
const UNSENT = 0;
const OPENED = 1;
const HEADERS_RECEIVED = 2;
const LOADING = 3;
const DONE = 4;
const EVENT_TYPES$3 = [
    'loadstart', 'readystatechange', 'load', 'loadend', 'progress', 'timeout', 'abort', 'error'
];
const UPLOAD_EVENT_TYPES = ['progress', 'loadstart', 'load', 'loadend', 'timeout', 'abort', 'error'];
const SUPPORTED_SCHEMES = ['http', 'https', 'file'];
class XMLHttpRequest {
    constructor() {
        Object.defineProperties(this, {
            $authorRequestHeaders: { enumerable: false, writable: true, value: {} },
            $timeout: { enumerable: false, writable: true, value: 0 },
            $status: { enumerable: false, writable: true, value: 0 },
            $statusText: { enumerable: false, writable: true, value: '' },
            $responseHeaders: { enumerable: false, writable: true, value: '' },
            $readyState: { enumerable: false, writable: true, value: UNSENT },
            $responseData: { enumerable: false, writable: true, value: '' },
            $withCredentials: { enumerable: false, writable: true, value: false },
            $responseType: { enumerable: false, writable: true, value: '' },
            $sendInvoked: { enumerable: false, writable: true, value: false },
            $isSynchronous: { enumerable: false, writable: true, value: false },
            $error: { enumerable: false, writable: true, value: false },
            $uploadComplete: { enumerable: false, writable: true, value: false },
            upload: { value: {} }
        });
        defineEventHandlerProperties(this, EVENT_TYPES$3);
        defineEventHandlerProperties(this.upload, UPLOAD_EVENT_TYPES);
        addDOMEventTargetMethods(this);
        addDOMEventTargetMethods(this.upload);
    }
    get readyState() {
        return this.$readyState;
    }
    get timeout() {
        return this.$timeout;
    }
    set timeout(value) {
        // (1): superfluous, as we don't support synchronous requests
        if (!isNaN(value)) { // (2)
            this.$timeout = Math.round(value);
        }
    }
    get responseText() {
        // 1. If responseType is not the empty string or "text", throw an InvalidStateError exception.
        if (this.$responseType !== '' && this.$responseType !== 'text') {
            throw new Error('XHR responseText not accessible for non-text responseType');
        }
        // 2. If state is not loading or done, return the empty string.
        if ((this.$readyState !== LOADING && this.$readyState !== DONE)) {
            return '';
        }
        // 3. Return the text response.
        return this.$responseData || '';
    }
    get response() {
        // If responseType is the empty string or "text"
        if (this.$responseType === '' || this.$responseType === 'string') {
            // 1. If state is not loading or done, return the empty string.
            if (this.$readyState !== LOADING && this.$readyState !== DONE) {
                return '';
            }
            // 2. Return the text response.
            return this.$responseData || '';
        }
        // Otherwise
        // 1. If state is not done, return null.
        if (this.$readyState !== DONE) {
            return null;
        }
        // 2. If responseType is "arraybuffer"
        // Return the arraybuffer response.
        return this.$responseData;
    }
    get responseType() {
        return this.$responseType;
    }
    set responseType(value) {
        // 1. (concurrency related, skip)
        // 2. If state is loading or done, throw an InvalidStateError exception.
        if ((this.$readyState === LOADING || this.$readyState === DONE)) {
            throw new Error('The response type cannot be set when state is LOADING or DONE.');
        }
        // 3. (concurrency related, skip)
        // 4. Set the responseType attribute's value to the given value.
        // mimicking Chromium and Firefox behaviour when setting a not allowed responseType:
        if (['arraybuffer', 'blob', 'document', 'json', 'text'].indexOf(value) < 0) {
            return;
        }
        // currently only the response types 'text' and 'arraybuffer' are supported
        if (['blob', 'document', 'json'].indexOf(value) > -1) {
            throw new Error('Unsupported responseType, only \'text\' and \'arraybuffer\' are supported');
        }
        this.$responseType = value;
    }
    get status() {
        if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
            return 0;
        }
        if (this.$error) {
            return 0;
        }
        return this.$status;
    }
    get statusText() {
        if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
            return '';
        }
        if (this.$error) {
            return '';
        }
        return this.$statusText;
    }
    get withCredentials() {
        return this.$withCredentials;
    }
    set withCredentials(value) {
        if (this.$readyState !== UNSENT && this.$readyState !== OPENED) {
            throw new Error('InvalidStateError: state must be \'UNSENT\' or \'OPENED\' when setting withCredentials');
        }
        if (this.$sendInvoked) {
            throw new Error('InvalidStateError: \'send\' invoked, failed to set \'withCredentials\'');
        }
        // (3): superfluous as we don't support synchronous requests
        // mimicking Chromium and Firefox behaviour when setting a non-boolean value:
        if (typeof value === 'boolean') {
            this.$withCredentials = value; // (4)
        }
    }
    open(method, url, async) {
        const parsedUrl = {};
        // (2), (3), (4): we don't implement the 'settings' object
        validateRequiredOpenArgs(method, url);
        parsedUrl.source = url; // (8), (9): experimental non-standard parsing implementation:
        // regex taken from http://stackoverflow.com/a/19709846:
        parsedUrl.isRelative = !new RegExp('^(?:[a-z]+:)?//', 'i').test(url);
        if (typeof async === 'undefined') { // (10)
            async = true;
        }
        if (!async) {
            throw new Error('Only asynchronous request supported.');
        }
        // (12): superfluous as we don't support synchronous requests
        // TODO: (13) - should we call 'abort' to the nativeObject? We'd need to move the creation of the nativeObject
        // to the open() function
        this.$requestMethod = method; // (14)
        this.$requestUrl = parsedUrl;
        this.$isSynchronous = !async;
        this.$authorRequestHeaders = {};
        this.$sendInvoked = false;
        this.$responseData = null;
        if (this.$readyState !== OPENED) { // (15)
            this.$readyState = OPENED;
            dispatchEvent('readystatechange', this);
        }
    }
    send(data) {
        this.$nativeObject = new HttpRequest()
            .on('stateChanged', event => handleStateChange(event, this))
            .on('downloadProgress', event => dispatchProgressEvent('progress', this, event))
            .on('uploadProgress', event => dispatchProgressEvent('progress', this.upload, event));
        if (this.$readyState !== OPENED) { // (1)
            throw new Error('InvalidStateError: Object\'s state must be \'OPENED\', failed to execute \'send\'');
        }
        if (this.$sendInvoked) { // (2)
            throw new Error('InvalidStateError: \'send\' invoked, failed to execute \'send\'');
        }
        if (['GET', 'HEAD'].indexOf(this.$requestMethod) > -1) { // (3)
            data = null;
        }
        if (data instanceof FormData) {
            data = formDataToBlob(data);
        }
        this.$requestBody = (data && getBytes(data)) ? getBytes(data) : data; // (4)
        if ((data instanceof Blob)
            && Object.keys(this.$authorRequestHeaders).map(str => str.toLowerCase()).indexOf('content-type') === -1) {
            this.$authorRequestHeaders['Content-Type'] = data.type;
        }
        // TODO: support encoding and mimetype for string response types
        // (5): no storage mutex
        this.$error = this.$uploadComplete = false; // (6), see (8)
        if (!data) { // (7)
            this.$uploadComplete = true;
        }
        // (8): uploadEvents is relevant for the "force preflight flag", but this logic is handled by
        // the client
        // Basic access authentication
        this.$sendInvoked = true; // (9.1)
        dispatchProgressEvent('loadstart', this); // (9.2)
        if (!this.$uploadComplete) {
            dispatchProgressEvent('loadstart', this.upload); // (9.3)
        }
        // (10): only handling the same origin case
        this.$nativeObject.send({
            url: this.$requestUrl.source,
            method: this.$requestMethod,
            timeout: this.timeout,
            headers: this.$authorRequestHeaders,
            data: this.$requestBody,
            responseType: this.$responseType
        });
    }
    abort() {
        if (this.$nativeObject) {
            this.$nativeObject.abort(); // (1)
        }
        if (!([UNSENT, OPENED].indexOf(this.$readyState) > -1 && !this.$sendInvoked ||
            this.$readyState === DONE)) { // send() interrupted
            // (2.1), (2.2): setting readyState DONE with sendInvoked true or false seems to be an
            // internal state which doesn't affect the behavior and thus cannot be tested
            dispatchEvent('readystatechange', this); // (2.3)
            if (!this.$uploadComplete) {
                this.$uploadComplete = true; // (2.4.1)
                dispatchAbortProgressEvents(this.upload); // (2.4.2), (2.4.3), (2.4.4)
            }
            dispatchAbortProgressEvents(this); // (2.5), (2.6), (2.7)
        }
        this.$readyState = UNSENT; // (3)
    }
    setRequestHeader(header, value) {
        if (this.$readyState !== OPENED) { // (1)
            throw new Error('InvalidStateError: ' +
                'Object\'s state must be \'OPENED\', failed to execute \'setRequestHeader\'');
        }
        if (this.$sendInvoked) { // (2)
            throw new Error('InvalidStateError: ' +
                'cannot set request header if \'send()\' invoked and request not completed');
        }
        if (!validHttpToken(header)) { // (3)
            throw new TypeError('Invalid HTTP header name, failed to execute \'open\'');
        }
        if (!isValidHttpHeaderValue(value)) { // (4)
            throw new TypeError('Invalid HTTP header value, failed to execute \'open\'');
        }
        // (5) (No headers are filtered out as this restriction does not apply to native apps)
        if (header in this.$authorRequestHeaders) { // (6):
            this.$authorRequestHeaders[header] = this.$authorRequestHeaders[header] + ', ' + value; // (7)
        }
        else {
            this.$authorRequestHeaders[header] = value; // (8)
        }
    }
    getResponseHeader(header) {
        if ([UNSENT, OPENED].indexOf(this.readyState) > -1) { // (1)
            return null;
        }
        if (this.$error) { // (2)
            return null;
        }
        // (3) (No headers are filtered out as this restriction does not apply to native apps)
        for (const key in this.$responseHeaders) { // (4), (5)
            if (key.toLowerCase() === header.toLowerCase()) {
                return this.$responseHeaders[key];
            }
        }
        return null; // (6)
    }
    getAllResponseHeaders() {
        if ([UNSENT, OPENED].indexOf(this.readyState) > -1) { // (1)
            return '';
        }
        if (this.$error) { // (2)
            return '';
        }
        const result = [];
        for (const key in this.$responseHeaders) {
            result.push(key + ': ' + this.$responseHeaders[key]);
        }
        return result.join('\r\n');
    }
}
Object.defineProperties(XMLHttpRequest.prototype, {
    UNSENT: { value: UNSENT },
    OPENED: { value: OPENED },
    HEADERS_RECEIVED: { value: HEADERS_RECEIVED },
    LOADING: { value: LOADING },
    DONE: { value: DONE }
});
function handleStateChange(event, xhr) {
    // Note: we supply lengthComputable, loaded and total only with the "progress" event types
    switch (event.state) {
        case 'headers':
            xhr.$readyState = HEADERS_RECEIVED;
            xhr.$status = event.code;
            xhr.$statusText = event.message;
            xhr.$responseHeaders = event.headers;
            dispatchEvent('readystatechange', xhr);
            xhr.$uploadComplete = true; // #make-upload-progress-notifications
            dispatchFinishedProgressEvents(xhr.upload);
            break;
        case 'loading':
            xhr.$readyState = LOADING;
            dispatchEvent('readystatechange', xhr);
            break;
        case 'finished':
            // TODO create response based on responseType
            xhr.$responseData = event.response;
            xhr.$readyState = DONE;
            dispatchEvent('readystatechange', xhr);
            dispatchFinishedProgressEvents(xhr);
            dispatchFinishedProgressEvents(xhr.upload);
            xhr.$nativeObject.dispose();
            xhr.$nativeObject = null;
            break;
        case 'error':
            handleRequestError('error', xhr);
            break;
        case 'timeout':
            handleRequestError('timeout', xhr);
            break;
        case 'abort':
            handleRequestError('abort', xhr);
            break;
    }
}
function handleRequestError(type, xhr) {
    xhr.$error = true; // (1*) (#terminate-the-request)
    xhr.$readyState = DONE; // (1)
    // (2): superfluous as we don't support synchronous requests
    dispatchEvent('readystatechange', xhr); // (3)
    dispatchErrorProgressEvents(type, xhr);
    if (!xhr.$uploadComplete) {
        xhr.$uploadComplete = true;
        dispatchErrorProgressEvents(type, xhr.upload);
    }
    xhr.$nativeObject.dispose();
    xhr.$nativeObject = null;
}
function validateRequiredOpenArgs(method, url) {
    if (!method) {
        throw new TypeError('Method argument should be specified to execute \'open\'');
    }
    if (!url) {
        throw new TypeError('URL argument should be specified to execute \'open\'');
    }
    validateMethod(method);
    validateUrl(url);
}
function validateMethod(method) {
    if (!validHttpToken(method)) {
        throw new TypeError('Invalid HTTP method, failed to execute \'open\'');
    }
    // (6):
    const tokens = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'];
    const uppercaseMethod = method.toUpperCase();
    if (tokens.indexOf(uppercaseMethod) >= 0) {
        method = uppercaseMethod;
    }
    const forbiddenTokens = ['CONNECT', 'TRACE', 'TRACK']; // (7)
    if (forbiddenTokens.indexOf(method) >= 0) {
        throw new Error(`SecurityError: '${method}' HTTP method is not secure, failed to execute 'open'`);
    }
}
function validHttpToken(httpToken) {
    // RFC-compliant validation for HTTP tokens ported from Chromium:
    // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
    const forbiddenCharacters = ['(', ')', '<', '>', '@', ',', ';', ':', '\\', '"', '/', '[', ']', '?', '=', '{', '}'];
    return !(/[^\x21-\x7E]/.test(httpToken) || forbiddenCharacters.indexOf(httpToken) >= 0);
}
function isValidHttpHeaderValue(value) {
    // non-RFC compliant validation for HTTP header values ported from Chromium:
    // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
    // Regex for Latin-1 characters based on: http://www.ic.unicamp.br/~stolfi/EXPORT/www/ISO-8859-1-Encoding.html
    return /^[\x09\x0A\x0D\x20-\x7E\xA0-\xFF]*$/.test(value) && value.indexOf('\n') < 0 && value.indexOf('\r') < 0;
}
function validateUrl(url) {
    // TODO: rewrite (8),(9)
    const scheme = extractScheme$1(url);
    if (scheme && (SUPPORTED_SCHEMES.indexOf(scheme) === -1)) {
        throw new SyntaxError('Unsupported URL scheme, failed to execute \'open\'');
    }
}
function extractScheme$1(url) {
    const match = /^(\S+?):/.exec(url);
    return match ? match[1] : null;
}
function dispatchEvent(type, target) {
    target.dispatchEvent(new Event(type));
}
function dispatchProgressEvent(type, target, config) {
    target.dispatchEvent(new ProgressEvent(type, config));
}
function dispatchAbortProgressEvents(target) {
    dispatchProgressEvent('progress', target);
    dispatchProgressEvent('abort', target);
    dispatchProgressEvent('loadend', target);
}
function dispatchErrorProgressEvents(type, target) {
    dispatchProgressEvent('progress', target);
    dispatchProgressEvent(type, target);
    dispatchProgressEvent('loadend', target);
}
function dispatchFinishedProgressEvents(target) {
    // Note: progress event is dispatched separately by the downloadProgress/uploadProgress callbacks
    dispatchProgressEvent('load', target);
    dispatchProgressEvent('loadend', target);
}

/**
 * @param {any=} param
 * @param {Array=} arr
 * @returns {any}
 */
function $(param) {
    if (typeof param === 'number') {
        // @ts-ignore
        return tabris._nativeObjectRegistry.find('$' + param);
    }
    if (typeof param === 'string' || param instanceof Function || arguments.length === 0) {
        // @ts-ignore
        return tabris.contentView.find(param || '*');
    }
    if (!(param instanceof Object)) {
        return '' + param;
    }
    if (!Object.keys(param).length) {
        return new WidgetCollection();
    }
    if (Object.keys(param).length > 1 || !('children' in param)) {
        throw new Error('$ does not support attributes');
    }
    const flat = flattenChildren(param.children);
    if (flat.some(entry => entry instanceof Widget) || flat.length < 1) {
        return toWidgetCollection(flat);
    }
    return joinTextContent(flat, false);
}
function toWidgetCollection(flat) {
    const result = [];
    let str = [];
    flat.forEach(entry => {
        if (entry instanceof Widget) {
            if (str.length) {
                result.push(new TextView({ text: joinTextContent(str, false) }));
                str = [];
            }
            result.push(entry);
        }
        else {
            str.push(entry);
        }
    });
    if (str.length) {
        result.push(new TextView({ text: joinTextContent(str, false) }));
    }
    return new WidgetCollection(result);
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
class Headers {
    constructor(headers) {
        Object.defineProperties(this, {
            $map: { enumerable: false, writable: true, value: {} }
        });
        if (headers instanceof Headers) {
            headers.forEach((value, name) => this.append(name, value));
        }
        else if (Array.isArray(headers)) {
            headers.forEach(header => this.append(header[0], header[1]));
        }
        else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(name => this.append(name, headers[name]));
        }
    }
    append(name, value) {
        name = normalizeName(name);
        const oldValue = this.$map[name];
        this.$map[name] = oldValue ? oldValue + ',' + value : '' + value;
    }
    delete(name) {
        delete this.$map[normalizeName(name)];
    }
    get(name) {
        name = normalizeName(name);
        return this.has(name) ? this.$map[name] : null;
    }
    has(name) {
        return Object.prototype.hasOwnProperty.call(this.$map, normalizeName(name));
    }
    set(name, value) {
        this.$map[normalizeName(name)] = '' + value;
    }
    forEach(callback, thisArg) {
        for (const name in this.$map) {
            if (Object.prototype.hasOwnProperty.call(this.$map, name)) {
                callback.call(thisArg, this.$map[name], name, this);
            }
        }
    }
    keys() {
        const items = [];
        this.forEach((value, name) => items.push(name));
        return iteratorFor(items);
    }
    values() {
        const items = [];
        this.forEach(value => items.push(value));
        return iteratorFor(items);
    }
    entries() {
        const items = [];
        this.forEach((value, name) => items.push([name, value]));
        return iteratorFor(items);
    }
    [iteratorSymbol()]() {
        return this.entries();
    }
}
function normalizeName(name) {
    name = '' + name;
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
}
function iteratorFor(items) {
    const iterator = {
        next() {
            const value = items.shift();
            return { done: value === undefined, value };
        }
    };
    iterator[iteratorSymbol()] = function () {
        return iterator;
    };
    return iterator;
}
// TODO replace when ES6 iterator is available on all platforms
function iteratorSymbol() {
    return 'Symbol' in global && 'iterator' in global.Symbol ? global.Symbol.iterator : '@@iterator';
}

class Body {
    constructor() {
        Object.defineProperties(this, {
            $bodyUsed: { enumerable: false, writable: true, value: false }
        });
    }
    _initBody(body) {
        Object.defineProperty(this, '_bodyInit', {
            enumerable: false, writable: false, value: body
        });
        if (!body) {
            Object.defineProperty(this, '_bodyText', {
                enumerable: false, writable: false, value: ''
            });
        }
        else if (typeof body === 'string') {
            Object.defineProperty(this, '_bodyText', {
                enumerable: false, writable: false, value: body
            });
        }
        else if (isReadable(body)) {
            Object.defineProperty(this, '_bodyBuffer', {
                enumerable: false, writable: false, value: read(body)
            });
        }
        else {
            throw new Error('unsupported BodyInit type');
        }
    }
    text() {
        return this.$consumed() || Promise$1.resolve(this._bodyBuffer ?
            TextDecoder.decode(this._bodyBuffer, this._encoding) :
            this._bodyText);
    }
    json() {
        return this.text().then(JSON.parse);
    }
    blob() {
        return this.arrayBuffer().then(buffer => {
            const blob = new Blob([], {
                type: this.headers ? this.headers.get('content-type') : ''
            });
            setBytes(blob, buffer);
            return blob;
        });
    }
    arrayBuffer() {
        return this.$consumed() || Promise$1.resolve(this._bodyBuffer ?
            this._bodyBuffer :
            TextEncoder.encode(this._bodyText, this._encoding));
    }
    get bodyUsed() {
        return !!this.$bodyUsed;
    }
    $consumed() {
        if (this.$bodyUsed) {
            return Promise$1.reject(new TypeError('Already read'));
        }
        this.$bodyUsed = true;
    }
    get _encoding() {
        return undefined;
    }
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
// HTTP methods whose capitalization should be normalized
const METHODS = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
class Request extends Body {
    constructor(input, options = {}) {
        super();
        let body = options.body;
        if (input instanceof Request) {
            if (input.bodyUsed) {
                throw new TypeError('Already read');
            }
            if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.$bodyUsed = true;
            }
        }
        else {
            input = {
                url: input
            };
        }
        Object.defineProperties(this, {
            url: { value: '' + input.url },
            method: { value: normalizeMethod(options.method || input.method || 'GET') },
            headers: { value: new Headers(options.headers || input.headers || {}) },
            credentials: { value: options.credentials || input.credentials || 'omit' },
            mode: { value: options.mode || input.mode || null },
            referrer: { value: '' },
            timeout: { value: options.timeout || 0 }
        });
        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests');
        }
        if (body instanceof FormData) {
            body = formDataToBlob(body);
        }
        if (body instanceof Blob && !this.headers.has('Content-Type')) {
            this.headers.set('Content-Type', body.type);
        }
        this._initBody(body);
    }
    clone() {
        return new Request(this, {
            body: this._bodyInit
        });
    }
}
function normalizeMethod(method) {
    const upcased = method.toUpperCase();
    return METHODS.includes(upcased) ? upcased : method;
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
const REDIRECT_STATUSES = [301, 302, 303, 307, 308];
class Response extends Body {
    constructor(bodyInit, options = {}) {
        super();
        Object.defineProperties(this, {
            url: { value: options.url || '' },
            type: { value: options._type || 'default' },
            status: { value: 'status' in options ? options.status : 200 },
            statusText: { value: 'statusText' in options ? options.statusText : 'OK' },
            headers: { value: new Headers(options.headers) }
        });
        this._initBody(bodyInit);
    }
    get ok() {
        return this.status >= 200 && this.status < 300;
    }
    clone() {
        return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
        });
    }
    get _encoding() {
        const contentType = this.headers.get('content-type') || '';
        const parameters = contentType.split(';').slice(1);
        for (const param of parameters) {
            const match = /charset=(\S+)/i.exec(param.trim());
            if (match) {
                return match[1].toLowerCase();
            }
        }
        return null;
    }
    static error() {
        return new Response(null, { status: 0, statusText: '', _type: 'error' });
    }
    static redirect(url, status) {
        if (!REDIRECT_STATUSES.includes(status)) {
            throw new RangeError('Invalid status code');
        }
        return new Response(null, { status, headers: { location: url } });
    }
}

function fetch(input, init) {
    return new Promise$1((resolve, reject) => {
        const request = new Request(input, init);
        const hr = new HttpRequest();
        const options = {};
        hr.on('stateChanged', (event) => {
            switch (event.state) {
                case 'headers':
                    options.status = event.code;
                    options.statusText = event.message;
                    options.headers = new Headers(event.headers);
                    break;
                case 'finished':
                    options.url = options.headers.get('X-Request-URL') || request.url;
                    resolve(new Response(event.response, options));
                    hr.dispose();
                    break;
                case 'error':
                    reject(new TypeError('Network request failed'));
                    hr.dispose();
                    break;
                case 'timeout':
                    reject(new TypeError('Network request timed out'));
                    hr.dispose();
                    break;
                case 'abort':
                    reject(new TypeError('Network request aborted'));
                    hr.dispose();
                    break;
            }
        });
        hr.send({
            url: request.url,
            method: request.method,
            responseType: 'arraybuffer',
            data: (typeof request._bodyInit === 'undefined') ? null : request._bodyBuffer || request._bodyInit,
            headers: encodeHeaders(request.headers),
            timeout: request.timeout
        });
    });
}
function encodeHeaders(headers) {
    const map = {};
    headers.forEach((value, name) => map[name] = value);
    return map;
}

// @ts-ignore
if (global.tabris && global.tabris.version) {
    throw new Error('tabris module already loaded. Ensure the module is installed only once.');
}
const WIDGETS = Object.freeze({
    Action,
    ActivityIndicator,
    Button,
    Canvas,
    ContentView,
    CheckBox,
    CollectionView,
    CameraView,
    Composite,
    Drawer,
    ImageView,
    NavigationView,
    Page,
    PdfView,
    Picker,
    ProgressBar,
    RadioButton,
    RefreshComposite,
    Row,
    ScrollView,
    SearchAction,
    Slider,
    Stack,
    Switch,
    Tab,
    TabFolder,
    TextInput,
    TextView,
    ToggleButton,
    Video,
    WebView,
    Widget
});
const POPUPS = Object.freeze({
    ActionSheet,
    ActionSheetItem,
    AlertDialog,
    DateDialog,
    Popover,
    TimeDialog
});
const WHATWG = Object.freeze({
    Blob,
    Crypto,
    Event,
    File,
    FormData,
    ImageData,
    ImageBitmap,
    ProgressEvent,
    Promise: Promise$1,
    Storage,
    WebSocket,
    XMLHttpRequest,
    fetch,
    Headers,
    Request,
    Response,
    Worker,
    createImageBitmap: ImageBitmap.createImageBitmap
});
const NATIVE_OBJECT = Object.freeze({
    App,
    Camera,
    NavigationBar,
    Device,
    DevTools,
    FileSystem,
    InactivityTimer,
    NativeObject,
    Printer,
    SizeMeasurement,
    StatusBar
});
const UTILS = {
    checkType,
    format,
    asFactory: arg => tabrisMain.JSX.processor.makeFactory(arg),
    applyRules
};
const OTHER = Object.freeze({
    Apply,
    Authentication,
    CanvasContext,
    ChangeListeners,
    Color,
    ColorResources,
    ConstraintLayout,
    Constraint,
    Console,
    EventObject,
    Font,
    FontResources,
    Image,
    JsxProcessor,
    JSX,
    Layout,
    LayoutData,
    Listeners,
    LinearGradient,
    Observable,
    Percent,
    Permission,
    Process,
    Resources,
    RowLayout,
    StackLayout,
    Setter,
    Set: Setter,
    symbols,
    TextResources,
    WidgetCollection,
    $
});
const tabrisMain = Object.assign(new Tabris(), WIDGETS, POPUPS, WHATWG, NATIVE_OBJECT, UTILS, OTHER);
/** @typedef {typeof tabrisMain} TabrisMain */
if (typeof module !== 'undefined') { // Allow loading in browser
    module.exports = tabrisMain;
}
if (global.document) {
    // Running in browser
    global.tabris = tabrisMain;
    global.JSX = tabrisMain.JSX;
}
else {
    global.tabris = tabrisMain;
    global.tabris.tabris = tabrisMain;
    Object.assign(global, WHATWG, { $ });
    addDOMDocument(global);
    addDOMEventTargetMethods(global);
    addWindowTimerMethods(global);
}
tabrisMain.on('start', (options) => {
    // @ts-ignore
    if (global.console.print) {
        global.console = createConsole(global.console);
    }
    patchError(Error);
    patchError(EvalError);
    patchError(RangeError);
    patchError(ReferenceError);
    patchError(SyntaxError);
    patchError(TypeError);
    patchError(URIError);
    tabris.$app = create$4();
    checkVersion(tabris.version, tabris.app._nativeGet('tabrisJsVersion'));
    if (!options || !options.headless) {
        tabris.$contentView = create$8();
        tabris._nativeSet('contentView', tabris.contentView.cid);
        tabris.$drawer = create$9();
        tabris.$navigationBar = create$b();
        tabris.$statusBar = create$d();
        tabris.$printer = create$1();
        tabris.$permission = create$2();
        tabris.$authentication = create$3();
        tabris.JSX.install(createJsxProcessor());
        tabris.widgets = omit(WIDGETS, ['Widget', 'Drawer', 'ContentView']);
        Object.assign(tabris, tabris.JSX.processor.makeFactories(tabris.widgets));
    }
    tabris.$devTools = create$6();
    tabris.$sizeMeasurement = create$c();
    tabris.$device = create();
    tabris.$fs = create$5();
    publishDeviceProperties(tabris.device, global);
    tabris.$localStorage = create$7();
    tabris.$secureStorage = create$7(true);
    tabris.$crypto = new Crypto();
    if ('print' in global.console) {
        global.console = createConsole(global.console);
    }
    tabris.$pkcs5 = new Pkcs5();
    tabris.$process = create$a(tabrisMain);
    // @ts-ignore
    global.localStorage = tabrisMain.localStorage;
    // @ts-ignore
    global.secureStorage = tabrisMain.secureStorage;
    // @ts-ignore
    global.crypto = tabrisMain.crypto;
    // @ts-ignore
    global.JSX = tabrisMain.JSX;
    if (!global.process) { // Prevent damaging test environment
        global.process = tabrisMain.process;
    }
});
